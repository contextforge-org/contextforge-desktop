// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { AcceptTeamInvitationTeamsInvitationsTokenAcceptPostData, AcceptTeamInvitationTeamsInvitationsTokenAcceptPostErrors, AcceptTeamInvitationTeamsInvitationsTokenAcceptPostResponses, AddRootRootsPost2Data, AddRootRootsPost2Errors, AddRootRootsPost2Responses, AddRootRootsPostData, AddRootRootsPostErrors, AddRootRootsPostResponses, AdminActivateUserAdminUsersUserEmailActivatePostData, AdminActivateUserAdminUsersUserEmailActivatePostErrors, AdminActivateUserAdminUsersUserEmailActivatePostResponses, AdminAddA2aAgentAdminA2aPostData, AdminAddA2aAgentAdminA2aPostErrors, AdminAddA2aAgentAdminA2aPostResponses, AdminAddGatewayAdminGatewaysPostData, AdminAddGatewayAdminGatewaysPostErrors, AdminAddGatewayAdminGatewaysPostResponses, AdminAddPromptAdminPromptsPostData, AdminAddPromptAdminPromptsPostErrors, AdminAddPromptAdminPromptsPostResponses, AdminAddResourceAdminResourcesPostData, AdminAddResourceAdminResourcesPostErrors, AdminAddResourceAdminResourcesPostResponses, AdminAddRootAdminRootsPostData, AdminAddRootAdminRootsPostErrors, AdminAddRootAdminRootsPostResponses, AdminAddServerAdminServersPostData, AdminAddServerAdminServersPostErrors, AdminAddServerAdminServersPostResponses, AdminAddTeamMemberAdminTeamsTeamIdAddMemberPostData, AdminAddTeamMemberAdminTeamsTeamIdAddMemberPostErrors, AdminAddTeamMemberAdminTeamsTeamIdAddMemberPostResponses, AdminAddToolAdminToolsPost2Data, AdminAddToolAdminToolsPost2Errors, AdminAddToolAdminToolsPost2Responses, AdminAddToolAdminToolsPostData, AdminAddToolAdminToolsPostErrors, AdminAddToolAdminToolsPostResponses, AdminApproveJoinRequestAdminTeamsTeamIdJoinRequestsRequestIdApprovePostData, AdminApproveJoinRequestAdminTeamsTeamIdJoinRequestsRequestIdApprovePostErrors, AdminApproveJoinRequestAdminTeamsTeamIdJoinRequestsRequestIdApprovePostResponses, AdminCancelJoinRequestAdminTeamsTeamIdJoinRequestRequestIdDeleteData, AdminCancelJoinRequestAdminTeamsTeamIdJoinRequestRequestIdDeleteErrors, AdminCancelJoinRequestAdminTeamsTeamIdJoinRequestRequestIdDeleteResponses, AdminCreateGrpcServiceAdminGrpcPostData, AdminCreateGrpcServiceAdminGrpcPostErrors, AdminCreateGrpcServiceAdminGrpcPostResponses, AdminCreateJoinRequestAdminTeamsTeamIdJoinRequestPostData, AdminCreateJoinRequestAdminTeamsTeamIdJoinRequestPostErrors, AdminCreateJoinRequestAdminTeamsTeamIdJoinRequestPostResponses, AdminCreateTeamAdminTeamsPostData, AdminCreateTeamAdminTeamsPostErrors, AdminCreateTeamAdminTeamsPostResponses, AdminCreateUserAdminUsersPostData, AdminCreateUserAdminUsersPostErrors, AdminCreateUserAdminUsersPostResponses, AdminDeactivateUserAdminUsersUserEmailDeactivatePostData, AdminDeactivateUserAdminUsersUserEmailDeactivatePostErrors, AdminDeactivateUserAdminUsersUserEmailDeactivatePostResponses, AdminDeleteA2aAgentAdminA2aAgentIdDeletePostData, AdminDeleteA2aAgentAdminA2aAgentIdDeletePostErrors, AdminDeleteA2aAgentAdminA2aAgentIdDeletePostResponses, AdminDeleteGatewayAdminGatewaysGatewayIdDeletePostData, AdminDeleteGatewayAdminGatewaysGatewayIdDeletePostErrors, AdminDeleteGatewayAdminGatewaysGatewayIdDeletePostResponses, AdminDeleteGrpcServiceAdminGrpcServiceIdDeletePostData, AdminDeleteGrpcServiceAdminGrpcServiceIdDeletePostErrors, AdminDeleteGrpcServiceAdminGrpcServiceIdDeletePostResponses, AdminDeletePromptAdminPromptsPromptIdDeletePostData, AdminDeletePromptAdminPromptsPromptIdDeletePostErrors, AdminDeletePromptAdminPromptsPromptIdDeletePostResponses, AdminDeleteResourceAdminResourcesResourceIdDeletePostData, AdminDeleteResourceAdminResourcesResourceIdDeletePostErrors, AdminDeleteResourceAdminResourcesResourceIdDeletePostResponses, AdminDeleteRootAdminRootsUriDeletePostData, AdminDeleteRootAdminRootsUriDeletePostErrors, AdminDeleteRootAdminRootsUriDeletePostResponses, AdminDeleteServerAdminServersServerIdDeletePostData, AdminDeleteServerAdminServersServerIdDeletePostErrors, AdminDeleteServerAdminServersServerIdDeletePostResponses, AdminDeleteTeamAdminTeamsTeamIdDeleteData, AdminDeleteTeamAdminTeamsTeamIdDeleteErrors, AdminDeleteTeamAdminTeamsTeamIdDeleteResponses, AdminDeleteToolAdminToolsToolIdDeletePostData, AdminDeleteToolAdminToolsToolIdDeletePostErrors, AdminDeleteToolAdminToolsToolIdDeletePostResponses, AdminDeleteUserAdminUsersUserEmailDeleteData, AdminDeleteUserAdminUsersUserEmailDeleteErrors, AdminDeleteUserAdminUsersUserEmailDeleteResponses, AdminEditA2aAgentAdminA2aAgentIdEditPostData, AdminEditA2aAgentAdminA2aAgentIdEditPostErrors, AdminEditA2aAgentAdminA2aAgentIdEditPostResponses, AdminEditGatewayAdminGatewaysGatewayIdEditPostData, AdminEditGatewayAdminGatewaysGatewayIdEditPostErrors, AdminEditGatewayAdminGatewaysGatewayIdEditPostResponses, AdminEditPromptAdminPromptsPromptIdEditPostData, AdminEditPromptAdminPromptsPromptIdEditPostErrors, AdminEditPromptAdminPromptsPromptIdEditPostResponses, AdminEditResourceAdminResourcesResourceIdEditPostData, AdminEditResourceAdminResourcesResourceIdEditPostErrors, AdminEditResourceAdminResourcesResourceIdEditPostResponses, AdminEditServerAdminServersServerIdEditPostData, AdminEditServerAdminServersServerIdEditPostErrors, AdminEditServerAdminServersServerIdEditPostResponses, AdminEditToolAdminToolsToolIdEditPost2Data, AdminEditToolAdminToolsToolIdEditPost2Errors, AdminEditToolAdminToolsToolIdEditPost2Responses, AdminEditToolAdminToolsToolIdEditPostData, AdminEditToolAdminToolsToolIdEditPostErrors, AdminEditToolAdminToolsToolIdEditPostResponses, AdminExportConfigurationAdminExportConfigurationGetData, AdminExportConfigurationAdminExportConfigurationGetErrors, AdminExportConfigurationAdminExportConfigurationGetResponses, AdminExportLogsAdminLogsExportGetData, AdminExportLogsAdminLogsExportGetErrors, AdminExportLogsAdminLogsExportGetResponses, AdminExportSelectiveAdminExportSelectivePostData, AdminExportSelectiveAdminExportSelectivePostErrors, AdminExportSelectiveAdminExportSelectivePostResponses, AdminGenerateSupportBundleAdminSupportBundleGenerateGetData, AdminGenerateSupportBundleAdminSupportBundleGenerateGetErrors, AdminGenerateSupportBundleAdminSupportBundleGenerateGetResponses, AdminGetAgentAdminA2aAgentIdGetData, AdminGetAgentAdminA2aAgentIdGetErrors, AdminGetAgentAdminA2aAgentIdGetResponses, AdminGetAllPromptIdsAdminPromptsIdsGetData, AdminGetAllPromptIdsAdminPromptsIdsGetErrors, AdminGetAllPromptIdsAdminPromptsIdsGetResponses, AdminGetAllResourceIdsAdminResourcesIdsGetData, AdminGetAllResourceIdsAdminResourcesIdsGetErrors, AdminGetAllResourceIdsAdminResourcesIdsGetResponses, AdminGetAllToolIdsAdminToolsIdsGetData, AdminGetAllToolIdsAdminToolsIdsGetErrors, AdminGetAllToolIdsAdminToolsIdsGetResponses, AdminGetGatewayAdminGatewaysGatewayIdGetData, AdminGetGatewayAdminGatewaysGatewayIdGetErrors, AdminGetGatewayAdminGatewaysGatewayIdGetResponses, AdminGetGrpcMethodsAdminGrpcServiceIdMethodsGetData, AdminGetGrpcMethodsAdminGrpcServiceIdMethodsGetErrors, AdminGetGrpcMethodsAdminGrpcServiceIdMethodsGetResponses, AdminGetGrpcServiceAdminGrpcServiceIdGetData, AdminGetGrpcServiceAdminGrpcServiceIdGetErrors, AdminGetGrpcServiceAdminGrpcServiceIdGetResponses, AdminGetImportStatusAdminImportStatusImportIdGetData, AdminGetImportStatusAdminImportStatusImportIdGetErrors, AdminGetImportStatusAdminImportStatusImportIdGetResponses, AdminGetLogFileAdminLogsFileGetData, AdminGetLogFileAdminLogsFileGetErrors, AdminGetLogFileAdminLogsFileGetResponses, AdminGetLogsAdminLogsGetData, AdminGetLogsAdminLogsGetErrors, AdminGetLogsAdminLogsGetResponses, AdminGetPromptAdminPromptsPromptIdGetData, AdminGetPromptAdminPromptsPromptIdGetErrors, AdminGetPromptAdminPromptsPromptIdGetResponses, AdminGetResourceAdminResourcesResourceIdGetData, AdminGetResourceAdminResourcesResourceIdGetErrors, AdminGetResourceAdminResourcesResourceIdGetResponses, AdminGetServerAdminServersServerIdGetData, AdminGetServerAdminServersServerIdGetErrors, AdminGetServerAdminServersServerIdGetResponses, AdminGetTeamEditAdminTeamsTeamIdEditGetData, AdminGetTeamEditAdminTeamsTeamIdEditGetErrors, AdminGetTeamEditAdminTeamsTeamIdEditGetResponses, AdminGetToolAdminToolsToolIdGetData, AdminGetToolAdminToolsToolIdGetErrors, AdminGetToolAdminToolsToolIdGetResponses, AdminGetUserEditAdminUsersUserEmailEditGetData, AdminGetUserEditAdminUsersUserEmailEditGetErrors, AdminGetUserEditAdminUsersUserEmailEditGetResponses, AdminHomeAdminGetData, AdminHomeAdminGetErrors, AdminHomeAdminGetResponses, AdminImportConfigurationAdminImportConfigurationPostData, AdminImportConfigurationAdminImportConfigurationPostErrors, AdminImportConfigurationAdminImportConfigurationPostResponses, AdminImportPreviewAdminImportPreviewPostData, AdminImportPreviewAdminImportPreviewPostErrors, AdminImportPreviewAdminImportPreviewPostResponses, AdminImportToolsAdminToolsImportPost2Data, AdminImportToolsAdminToolsImportPost2Errors, AdminImportToolsAdminToolsImportPost2Responses, AdminImportToolsAdminToolsImportPostData, AdminImportToolsAdminToolsImportPostErrors, AdminImportToolsAdminToolsImportPostResponses, AdminLeaveTeamAdminTeamsTeamIdLeavePostData, AdminLeaveTeamAdminTeamsTeamIdLeavePostErrors, AdminLeaveTeamAdminTeamsTeamIdLeavePostResponses, AdminListA2aAgentsAdminA2aGetData, AdminListA2aAgentsAdminA2aGetErrors, AdminListA2aAgentsAdminA2aGetResponses, AdminListGatewayIdsAdminGatewaysIdsGetData, AdminListGatewayIdsAdminGatewaysIdsGetErrors, AdminListGatewayIdsAdminGatewaysIdsGetResponses, AdminListGatewaysAdminGatewaysGetData, AdminListGatewaysAdminGatewaysGetErrors, AdminListGatewaysAdminGatewaysGetResponses, AdminListGrpcServicesAdminGrpcGetData, AdminListGrpcServicesAdminGrpcGetErrors, AdminListGrpcServicesAdminGrpcGetResponses, AdminListImportStatusesAdminImportStatusGetData, AdminListImportStatusesAdminImportStatusGetErrors, AdminListImportStatusesAdminImportStatusGetResponses, AdminListJoinRequestsAdminTeamsTeamIdJoinRequestsGetData, AdminListJoinRequestsAdminTeamsTeamIdJoinRequestsGetErrors, AdminListJoinRequestsAdminTeamsTeamIdJoinRequestsGetResponses, AdminListPromptsAdminPromptsGetData, AdminListPromptsAdminPromptsGetErrors, AdminListPromptsAdminPromptsGetResponses, AdminListResourcesAdminResourcesGetData, AdminListResourcesAdminResourcesGetErrors, AdminListResourcesAdminResourcesGetResponses, AdminListServersAdminServersGetData, AdminListServersAdminServersGetErrors, AdminListServersAdminServersGetResponses, AdminListTagsAdminTagsGetData, AdminListTagsAdminTagsGetErrors, AdminListTagsAdminTagsGetResponses, AdminListTeamsAdminTeamsGetData, AdminListTeamsAdminTeamsGetErrors, AdminListTeamsAdminTeamsGetResponses, AdminListToolsAdminToolsGetData, AdminListToolsAdminToolsGetErrors, AdminListToolsAdminToolsGetResponses, AdminListUsersAdminUsersGetData, AdminListUsersAdminUsersGetErrors, AdminListUsersAdminUsersGetResponses, AdminLoginHandlerAdminLoginPostData, AdminLoginHandlerAdminLoginPostResponses, AdminLoginPageAdminLoginGetData, AdminLoginPageAdminLoginGetResponses, AdminLogoutAdminLogoutPostData, AdminLogoutAdminLogoutPostResponses, AdminPromptsPartialHtmlAdminPromptsPartialGetData, AdminPromptsPartialHtmlAdminPromptsPartialGetErrors, AdminPromptsPartialHtmlAdminPromptsPartialGetResponses, AdminReflectGrpcServiceAdminGrpcServiceIdReflectPostData, AdminReflectGrpcServiceAdminGrpcServiceIdReflectPostErrors, AdminReflectGrpcServiceAdminGrpcServiceIdReflectPostResponses, AdminRejectJoinRequestAdminTeamsTeamIdJoinRequestsRequestIdRejectPostData, AdminRejectJoinRequestAdminTeamsTeamIdJoinRequestsRequestIdRejectPostErrors, AdminRejectJoinRequestAdminTeamsTeamIdJoinRequestsRequestIdRejectPostResponses, AdminRemoveTeamMemberAdminTeamsTeamIdRemoveMemberPostData, AdminRemoveTeamMemberAdminTeamsTeamIdRemoveMemberPostErrors, AdminRemoveTeamMemberAdminTeamsTeamIdRemoveMemberPostResponses, AdminResetMetricsAdminMetricsResetPostData, AdminResetMetricsAdminMetricsResetPostErrors, AdminResetMetricsAdminMetricsResetPostResponses, AdminResourcesPartialHtmlAdminResourcesPartialGetData, AdminResourcesPartialHtmlAdminResourcesPartialGetErrors, AdminResourcesPartialHtmlAdminResourcesPartialGetResponses, AdminRevokeTokenTokensAdminTokenIdDeleteData, AdminRevokeTokenTokensAdminTokenIdDeleteErrors, AdminRevokeTokenTokensAdminTokenIdDeleteResponses, AdminSearchPromptsAdminPromptsSearchGetData, AdminSearchPromptsAdminPromptsSearchGetErrors, AdminSearchPromptsAdminPromptsSearchGetResponses, AdminSearchToolsAdminToolsSearchGetData, AdminSearchToolsAdminToolsSearchGetErrors, AdminSearchToolsAdminToolsSearchGetResponses, AdminStreamLogsAdminLogsStreamGetData, AdminStreamLogsAdminLogsStreamGetErrors, AdminStreamLogsAdminLogsStreamGetResponses, AdminTestA2aAgentAdminA2aAgentIdTestPostData, AdminTestA2aAgentAdminA2aAgentIdTestPostErrors, AdminTestA2aAgentAdminA2aAgentIdTestPostResponses, AdminTestGatewayAdminGatewaysTestPostData, AdminTestGatewayAdminGatewaysTestPostErrors, AdminTestGatewayAdminGatewaysTestPostResponses, AdminToggleA2aAgentAdminA2aAgentIdTogglePostData, AdminToggleA2aAgentAdminA2aAgentIdTogglePostErrors, AdminToggleA2aAgentAdminA2aAgentIdTogglePostResponses, AdminToggleGatewayAdminGatewaysGatewayIdTogglePostData, AdminToggleGatewayAdminGatewaysGatewayIdTogglePostErrors, AdminToggleGatewayAdminGatewaysGatewayIdTogglePostResponses, AdminToggleGrpcServiceAdminGrpcServiceIdTogglePostData, AdminToggleGrpcServiceAdminGrpcServiceIdTogglePostErrors, AdminToggleGrpcServiceAdminGrpcServiceIdTogglePostResponses, AdminTogglePromptAdminPromptsPromptIdTogglePostData, AdminTogglePromptAdminPromptsPromptIdTogglePostErrors, AdminTogglePromptAdminPromptsPromptIdTogglePostResponses, AdminToggleResourceAdminResourcesResourceIdTogglePostData, AdminToggleResourceAdminResourcesResourceIdTogglePostErrors, AdminToggleResourceAdminResourcesResourceIdTogglePostResponses, AdminToggleServerAdminServersServerIdTogglePostData, AdminToggleServerAdminServersServerIdTogglePostErrors, AdminToggleServerAdminServersServerIdTogglePostResponses, AdminToggleToolAdminToolsToolIdTogglePostData, AdminToggleToolAdminToolsToolIdTogglePostErrors, AdminToggleToolAdminToolsToolIdTogglePostResponses, AdminToolsPartialHtmlAdminToolsPartialGetData, AdminToolsPartialHtmlAdminToolsPartialGetErrors, AdminToolsPartialHtmlAdminToolsPartialGetResponses, AdminUpdateGrpcServiceAdminGrpcServiceIdPutData, AdminUpdateGrpcServiceAdminGrpcServiceIdPutErrors, AdminUpdateGrpcServiceAdminGrpcServiceIdPutResponses, AdminUpdateTeamAdminTeamsTeamIdUpdatePostData, AdminUpdateTeamAdminTeamsTeamIdUpdatePostErrors, AdminUpdateTeamAdminTeamsTeamIdUpdatePostResponses, AdminUpdateTeamMemberRoleAdminTeamsTeamIdUpdateMemberRolePostData, AdminUpdateTeamMemberRoleAdminTeamsTeamIdUpdateMemberRolePostErrors, AdminUpdateTeamMemberRoleAdminTeamsTeamIdUpdateMemberRolePostResponses, AdminUpdateUserAdminUsersUserEmailUpdatePostData, AdminUpdateUserAdminUsersUserEmailUpdatePostErrors, AdminUpdateUserAdminUsersUserEmailUpdatePostResponses, AdminViewTeamMembersAdminTeamsTeamIdMembersGetData, AdminViewTeamMembersAdminTeamsTeamIdMembersGetErrors, AdminViewTeamMembersAdminTeamsTeamIdMembersGetResponses, ApproveJoinRequestTeamsTeamIdJoinRequestsRequestIdApprovePostData, ApproveJoinRequestTeamsTeamIdJoinRequestsRequestIdApprovePostErrors, ApproveJoinRequestTeamsTeamIdJoinRequestsRequestIdApprovePostResponses, AssignRoleToUserRbacUsersUserEmailRolesPostData, AssignRoleToUserRbacUsersUserEmailRolesPostErrors, AssignRoleToUserRbacUsersUserEmailRolesPostResponses, BulkRegisterCatalogServersAdminMcpRegistryBulkRegisterPostData, BulkRegisterCatalogServersAdminMcpRegistryBulkRegisterPostErrors, BulkRegisterCatalogServersAdminMcpRegistryBulkRegisterPostResponses, CancelTeamInvitationTeamsInvitationsInvitationIdDeleteData, CancelTeamInvitationTeamsInvitationsInvitationIdDeleteErrors, CancelTeamInvitationTeamsInvitationsInvitationIdDeleteResponses, CatalogPartialAdminMcpRegistryPartialGetData, CatalogPartialAdminMcpRegistryPartialGetErrors, CatalogPartialAdminMcpRegistryPartialGetResponses, ChangePasswordAuthEmailChangePasswordPostData, ChangePasswordAuthEmailChangePasswordPostErrors, ChangePasswordAuthEmailChangePasswordPostResponses, ChatLlmchatChatPostData, ChatLlmchatChatPostErrors, ChatLlmchatChatPostResponses, CheckCatalogServerStatusAdminMcpRegistryServerIdStatusGetData, CheckCatalogServerStatusAdminMcpRegistryServerIdStatusGetErrors, CheckCatalogServerStatusAdminMcpRegistryServerIdStatusGetResponses, CheckPermissionRbacPermissionsCheckPostData, CheckPermissionRbacPermissionsCheckPostErrors, CheckPermissionRbacPermissionsCheckPostResponses, CleanupImportStatusesImportCleanupPostData, CleanupImportStatusesImportCleanupPostErrors, CleanupImportStatusesImportCleanupPostResponses, CleanupOldTracesObservabilityTracesCleanupDeleteData, CleanupOldTracesObservabilityTracesCleanupDeleteErrors, CleanupOldTracesObservabilityTracesCleanupDeleteResponses, ConnectLlmchatConnectPostData, ConnectLlmchatConnectPostErrors, ConnectLlmchatConnectPostResponses, CreateA2aAgentA2aPost2Data, CreateA2aAgentA2aPost2Errors, CreateA2aAgentA2aPost2Responses, CreateA2aAgentA2aPostData, CreateA2aAgentA2aPostErrors, CreateA2aAgentA2aPostResponses, CreatePromptPromptsPost2Data, CreatePromptPromptsPost2Errors, CreatePromptPromptsPost2Responses, CreatePromptPromptsPostData, CreatePromptPromptsPostErrors, CreatePromptPromptsPostResponses, CreateResourceResourcesPost2Data, CreateResourceResourcesPost2Errors, CreateResourceResourcesPost2Responses, CreateResourceResourcesPostData, CreateResourceResourcesPostErrors, CreateResourceResourcesPostResponses, CreateRoleRbacRolesPostData, CreateRoleRbacRolesPostErrors, CreateRoleRbacRolesPostResponses, CreateServerServersPost2Data, CreateServerServersPost2Errors, CreateServerServersPost2Responses, CreateServerServersPostData, CreateServerServersPostErrors, CreateServerServersPostResponses, CreateTeamTeamsPostData, CreateTeamTeamsPostErrors, CreateTeamTeamsPostResponses, CreateTeamTokenTokensTeamsTeamIdPostData, CreateTeamTokenTokensTeamsTeamIdPostErrors, CreateTeamTokenTokensTeamsTeamIdPostResponses, CreateTokenTokensPostData, CreateTokenTokensPostErrors, CreateTokenTokensPostResponses, CreateToolToolsPost2Data, CreateToolToolsPost2Errors, CreateToolToolsPost2Responses, CreateToolToolsPostData, CreateToolToolsPostErrors, CreateToolToolsPostResponses, CreateUserAuthEmailAdminUsersPostData, CreateUserAuthEmailAdminUsersPostErrors, CreateUserAuthEmailAdminUsersPostResponses, DeleteA2aAgentA2aAgentIdDeleteData, DeleteA2aAgentA2aAgentIdDeleteErrors, DeleteA2aAgentA2aAgentIdDeleteResponses, DeleteGatewayGatewaysGatewayIdDeleteData, DeleteGatewayGatewaysGatewayIdDeleteErrors, DeleteGatewayGatewaysGatewayIdDeleteResponses, DeleteObservabilityQueryAdminObservabilityQueriesQueryIdDeleteData, DeleteObservabilityQueryAdminObservabilityQueriesQueryIdDeleteErrors, DeleteObservabilityQueryAdminObservabilityQueriesQueryIdDeleteResponses, DeletePromptPromptsPromptIdDeleteData, DeletePromptPromptsPromptIdDeleteErrors, DeletePromptPromptsPromptIdDeleteResponses, DeleteRegisteredClientOauthRegisteredClientsClientIdDeleteData, DeleteRegisteredClientOauthRegisteredClientsClientIdDeleteErrors, DeleteRegisteredClientOauthRegisteredClientsClientIdDeleteResponses, DeleteResourceResourcesResourceIdDeleteData, DeleteResourceResourcesResourceIdDeleteErrors, DeleteResourceResourcesResourceIdDeleteResponses, DeleteRoleRbacRolesRoleIdDeleteData, DeleteRoleRbacRolesRoleIdDeleteErrors, DeleteRoleRbacRolesRoleIdDeleteResponses, DeleteServerServersServerIdDeleteData, DeleteServerServersServerIdDeleteErrors, DeleteServerServersServerIdDeleteResponses, DeleteTeamTeamsTeamIdDeleteData, DeleteTeamTeamsTeamIdDeleteErrors, DeleteTeamTeamsTeamIdDeleteResponses, DeleteToolToolsToolIdDeleteData, DeleteToolToolsToolIdDeleteErrors, DeleteToolToolsToolIdDeleteResponses, DeleteUserAuthEmailAdminUsersUserEmailDeleteData, DeleteUserAuthEmailAdminUsersUserEmailDeleteErrors, DeleteUserAuthEmailAdminUsersUserEmailDeleteResponses, DisconnectLlmchatDisconnectPostData, DisconnectLlmchatDisconnectPostErrors, DisconnectLlmchatDisconnectPostResponses, DisconnectSessionReverseProxySessionsSessionIdDeleteData, DisconnectSessionReverseProxySessionsSessionIdDeleteErrors, DisconnectSessionReverseProxySessionsSessionIdDeleteResponses, DiscoverPublicTeamsTeamsDiscoverGetData, DiscoverPublicTeamsTeamsDiscoverGetErrors, DiscoverPublicTeamsTeamsDiscoverGetResponses, ExportConfigurationExportGetData, ExportConfigurationExportGetErrors, ExportConfigurationExportGetResponses, ExportSelectiveConfigurationExportSelectivePostData, ExportSelectiveConfigurationExportSelectivePostErrors, ExportSelectiveConfigurationExportSelectivePostResponses, ExportTracesObservabilityTracesExportPostData, ExportTracesObservabilityTracesExportPostErrors, ExportTracesObservabilityTracesExportPostResponses, FetchToolsAfterOauthOauthFetchToolsGatewayIdPostData, FetchToolsAfterOauthOauthFetchToolsGatewayIdPostErrors, FetchToolsAfterOauthOauthFetchToolsGatewayIdPostResponses, GetA2aAgentA2aAgentIdGetData, GetA2aAgentA2aAgentIdGetErrors, GetA2aAgentA2aAgentIdGetResponses, GetAggregatedMetricsAdminMetricsGetData, GetAggregatedMetricsAdminMetricsGetErrors, GetAggregatedMetricsAdminMetricsGetResponses, GetAuthEventsAuthEmailEventsGetData, GetAuthEventsAuthEmailEventsGetErrors, GetAuthEventsAuthEmailEventsGetResponses, GetAvailablePermissionsRbacPermissionsAvailableGetData, GetAvailablePermissionsRbacPermissionsAvailableGetErrors, GetAvailablePermissionsRbacPermissionsAvailableGetResponses, GetConfigLlmchatConfigUserIdGetData, GetConfigLlmchatConfigUserIdGetErrors, GetConfigLlmchatConfigUserIdGetResponses, GetConfigurationSettingsAdminConfigSettingsGetData, GetConfigurationSettingsAdminConfigSettingsGetErrors, GetConfigurationSettingsAdminConfigSettingsGetResponses, GetCurrentUserProfileAuthEmailMeGetData, GetCurrentUserProfileAuthEmailMeGetErrors, GetCurrentUserProfileAuthEmailMeGetResponses, GetEntitiesByTagTagsTagNameEntitiesGetData, GetEntitiesByTagTagsTagNameEntitiesGetErrors, GetEntitiesByTagTagsTagNameEntitiesGetResponses, GetGatewayGatewaysGatewayIdGetData, GetGatewayGatewaysGatewayIdGetErrors, GetGatewayGatewaysGatewayIdGetResponses, GetGatewaysSectionAdminSectionsGatewaysGetData, GetGatewaysSectionAdminSectionsGatewaysGetErrors, GetGatewaysSectionAdminSectionsGatewaysGetResponses, GetGlobalPassthroughHeadersAdminConfigPassthroughHeadersGetData, GetGlobalPassthroughHeadersAdminConfigPassthroughHeadersGetErrors, GetGlobalPassthroughHeadersAdminConfigPassthroughHeadersGetResponses, GetImportStatusImportStatusImportIdGetData, GetImportStatusImportStatusImportIdGetErrors, GetImportStatusImportStatusImportIdGetResponses, GetLatencyHeatmapAdminObservabilityMetricsHeatmapGetData, GetLatencyHeatmapAdminObservabilityMetricsHeatmapGetErrors, GetLatencyHeatmapAdminObservabilityMetricsHeatmapGetResponses, GetLatencyPercentilesAdminObservabilityMetricsPercentilesGetData, GetLatencyPercentilesAdminObservabilityMetricsPercentilesGetErrors, GetLatencyPercentilesAdminObservabilityMetricsPercentilesGetResponses, GetMetricsMetricsGetData, GetMetricsMetricsGetErrors, GetMetricsMetricsGetResponses, GetMyPermissionsRbacMyPermissionsGetData, GetMyPermissionsRbacMyPermissionsGetErrors, GetMyPermissionsRbacMyPermissionsGetResponses, GetMyRolesRbacMyRolesGetData, GetMyRolesRbacMyRolesGetErrors, GetMyRolesRbacMyRolesGetResponses, GetOauthStatusOauthStatusGatewayIdGetData, GetOauthStatusOauthStatusGatewayIdGetErrors, GetOauthStatusOauthStatusGatewayIdGetResponses, GetObservabilityMetricsPartialAdminObservabilityMetricsPartialGetData, GetObservabilityMetricsPartialAdminObservabilityMetricsPartialGetErrors, GetObservabilityMetricsPartialAdminObservabilityMetricsPartialGetResponses, GetObservabilityPartialAdminObservabilityPartialGetData, GetObservabilityPartialAdminObservabilityPartialGetErrors, GetObservabilityPartialAdminObservabilityPartialGetResponses, GetObservabilityQueryAdminObservabilityQueriesQueryIdGetData, GetObservabilityQueryAdminObservabilityQueriesQueryIdGetErrors, GetObservabilityQueryAdminObservabilityQueriesQueryIdGetResponses, GetObservabilityStatsAdminObservabilityStatsGetData, GetObservabilityStatsAdminObservabilityStatsGetErrors, GetObservabilityStatsAdminObservabilityStatsGetResponses, GetObservabilityTraceDetailAdminObservabilityTraceTraceIdGetData, GetObservabilityTraceDetailAdminObservabilityTraceTraceIdGetErrors, GetObservabilityTraceDetailAdminObservabilityTraceTraceIdGetResponses, GetObservabilityTracesAdminObservabilityTracesGetData, GetObservabilityTracesAdminObservabilityTracesGetErrors, GetObservabilityTracesAdminObservabilityTracesGetResponses, GetPluginDetailsAdminPluginsNameGetData, GetPluginDetailsAdminPluginsNameGetErrors, GetPluginDetailsAdminPluginsNameGetResponses, GetPluginsPartialAdminPluginsPartialGetData, GetPluginsPartialAdminPluginsPartialGetErrors, GetPluginsPartialAdminPluginsPartialGetResponses, GetPluginStatsAdminPluginsStatsGetData, GetPluginStatsAdminPluginsStatsGetErrors, GetPluginStatsAdminPluginsStatsGetResponses, GetPromptNoArgsPromptsPromptIdGetData, GetPromptNoArgsPromptsPromptIdGetErrors, GetPromptNoArgsPromptsPromptIdGetResponses, GetPromptPerformanceAdminObservabilityPromptsPerformanceGetData, GetPromptPerformanceAdminObservabilityPromptsPerformanceGetErrors, GetPromptPerformanceAdminObservabilityPromptsPerformanceGetResponses, GetPromptPromptsPromptIdPostData, GetPromptPromptsPromptIdPostErrors, GetPromptPromptsPromptIdPostResponses, GetPromptsErrorsAdminObservabilityPromptsErrorsGetData, GetPromptsErrorsAdminObservabilityPromptsErrorsGetErrors, GetPromptsErrorsAdminObservabilityPromptsErrorsGetResponses, GetPromptsPartialAdminObservabilityPromptsPartialGetData, GetPromptsPartialAdminObservabilityPromptsPartialGetErrors, GetPromptsPartialAdminObservabilityPromptsPartialGetResponses, GetPromptsSectionAdminSectionsPromptsGetData, GetPromptsSectionAdminSectionsPromptsGetErrors, GetPromptsSectionAdminSectionsPromptsGetResponses, GetPromptUsageAdminObservabilityPromptsUsageGetData, GetPromptUsageAdminObservabilityPromptsUsageGetErrors, GetPromptUsageAdminObservabilityPromptsUsageGetResponses, GetQueryPerformanceObservabilityAnalyticsQueryPerformanceGetData, GetQueryPerformanceObservabilityAnalyticsQueryPerformanceGetErrors, GetQueryPerformanceObservabilityAnalyticsQueryPerformanceGetResponses, GetRegisteredClientForGatewayOauthRegisteredClientsGatewayIdGetData, GetRegisteredClientForGatewayOauthRegisteredClientsGatewayIdGetErrors, GetRegisteredClientForGatewayOauthRegisteredClientsGatewayIdGetResponses, GetResourcePerformanceAdminObservabilityResourcesPerformanceGetData, GetResourcePerformanceAdminObservabilityResourcesPerformanceGetErrors, GetResourcePerformanceAdminObservabilityResourcesPerformanceGetResponses, GetResourcesErrorsAdminObservabilityResourcesErrorsGetData, GetResourcesErrorsAdminObservabilityResourcesErrorsGetErrors, GetResourcesErrorsAdminObservabilityResourcesErrorsGetResponses, GetResourcesPartialAdminObservabilityResourcesPartialGetData, GetResourcesPartialAdminObservabilityResourcesPartialGetErrors, GetResourcesPartialAdminObservabilityResourcesPartialGetResponses, GetResourcesSectionAdminSectionsResourcesGetData, GetResourcesSectionAdminSectionsResourcesGetErrors, GetResourcesSectionAdminSectionsResourcesGetResponses, GetResourceUsageAdminObservabilityResourcesUsageGetData, GetResourceUsageAdminObservabilityResourcesUsageGetErrors, GetResourceUsageAdminObservabilityResourcesUsageGetResponses, GetRoleRbacRolesRoleIdGetData, GetRoleRbacRolesRoleIdGetErrors, GetRoleRbacRolesRoleIdGetResponses, GetServerServersServerIdGetData, GetServerServersServerIdGetErrors, GetServerServersServerIdGetResponses, GetServersSectionAdminSectionsServersGetData, GetServersSectionAdminSectionsServersGetErrors, GetServersSectionAdminSectionsServersGetResponses, GetStatsObservabilityStatsGetData, GetStatsObservabilityStatsGetErrors, GetStatsObservabilityStatsGetResponses, GetSystemStatsAdminSystemStatsGetData, GetSystemStatsAdminSystemStatsGetErrors, GetSystemStatsAdminSystemStatsGetResponses, GetTeamTeamsTeamIdGetData, GetTeamTeamsTeamIdGetErrors, GetTeamTeamsTeamIdGetResponses, GetTimeseriesMetricsAdminObservabilityMetricsTimeseriesGetData, GetTimeseriesMetricsAdminObservabilityMetricsTimeseriesGetErrors, GetTimeseriesMetricsAdminObservabilityMetricsTimeseriesGetResponses, GetTokenTokensTokenIdGetData, GetTokenTokensTokenIdGetErrors, GetTokenTokensTokenIdGetResponses, GetTokenUsageStatsTokensTokenIdUsageGetData, GetTokenUsageStatsTokensTokenIdUsageGetErrors, GetTokenUsageStatsTokensTokenIdUsageGetResponses, GetToolChainsAdminObservabilityToolsChainsGetData, GetToolChainsAdminObservabilityToolsChainsGetErrors, GetToolChainsAdminObservabilityToolsChainsGetResponses, GetToolErrorsAdminObservabilityToolsErrorsGetData, GetToolErrorsAdminObservabilityToolsErrorsGetErrors, GetToolErrorsAdminObservabilityToolsErrorsGetResponses, GetToolPerformanceAdminObservabilityToolsPerformanceGetData, GetToolPerformanceAdminObservabilityToolsPerformanceGetErrors, GetToolPerformanceAdminObservabilityToolsPerformanceGetResponses, GetToolsPartialAdminObservabilityToolsPartialGetData, GetToolsPartialAdminObservabilityToolsPartialGetErrors, GetToolsPartialAdminObservabilityToolsPartialGetResponses, GetToolsSectionAdminSectionsToolsGetData, GetToolsSectionAdminSectionsToolsGetErrors, GetToolsSectionAdminSectionsToolsGetResponses, GetToolToolsToolIdGetData, GetToolToolsToolIdGetErrors, GetToolToolsToolIdGetResponses, GetToolUsageAdminObservabilityToolsUsageGetData, GetToolUsageAdminObservabilityToolsUsageGetErrors, GetToolUsageAdminObservabilityToolsUsageGetResponses, GetTopErrorEndpointsAdminObservabilityMetricsTopErrorsGetData, GetTopErrorEndpointsAdminObservabilityMetricsTopErrorsGetErrors, GetTopErrorEndpointsAdminObservabilityMetricsTopErrorsGetResponses, GetTopSlowEndpointsAdminObservabilityMetricsTopSlowGetData, GetTopSlowEndpointsAdminObservabilityMetricsTopSlowGetErrors, GetTopSlowEndpointsAdminObservabilityMetricsTopSlowGetResponses, GetTopVolumeEndpointsAdminObservabilityMetricsTopVolumeGetData, GetTopVolumeEndpointsAdminObservabilityMetricsTopVolumeGetErrors, GetTopVolumeEndpointsAdminObservabilityMetricsTopVolumeGetResponses, GetTraceObservabilityTracesTraceIdGetData, GetTraceObservabilityTracesTraceIdGetErrors, GetTraceObservabilityTracesTraceIdGetResponses, GetUserAuthEmailAdminUsersUserEmailGetData, GetUserAuthEmailAdminUsersUserEmailGetErrors, GetUserAuthEmailAdminUsersUserEmailGetResponses, GetUserPermissionsRbacPermissionsUserUserEmailGetData, GetUserPermissionsRbacPermissionsUserUserEmailGetErrors, GetUserPermissionsRbacPermissionsUserUserEmailGetResponses, GetUserRolesRbacUsersUserEmailRolesGetData, GetUserRolesRbacUsersUserEmailRolesGetErrors, GetUserRolesRbacUsersUserEmailRolesGetResponses, GetWellKnownStatusAdminWellKnownGetData, GetWellKnownStatusAdminWellKnownGetErrors, GetWellKnownStatusAdminWellKnownGetResponses, HandleCompletionProtocolCompletionCompletePostData, HandleCompletionProtocolCompletionCompletePostErrors, HandleCompletionProtocolCompletionCompletePostResponses, HandleNotificationNotificationsPostData, HandleNotificationNotificationsPostErrors, HandleNotificationNotificationsPostResponses, HandleNotificationProtocolNotificationsPostData, HandleNotificationProtocolNotificationsPostErrors, HandleNotificationProtocolNotificationsPostResponses, HandleRpcRpcPost2Data, HandleRpcRpcPost2Errors, HandleRpcRpcPost2Responses, HandleRpcRpcPostData, HandleRpcRpcPostErrors, HandleRpcRpcPostResponses, HandleSamplingProtocolSamplingCreateMessagePostData, HandleSamplingProtocolSamplingCreateMessagePostErrors, HandleSamplingProtocolSamplingCreateMessagePostResponses, HealthcheckHealthGetData, HealthcheckHealthGetResponses, ImportConfigurationImportPostData, ImportConfigurationImportPostErrors, ImportConfigurationImportPostResponses, InitializeInitializePostData, InitializeInitializePostErrors, InitializeInitializePostResponses, InitializeProtocolInitializePostData, InitializeProtocolInitializePostErrors, InitializeProtocolInitializePostResponses, InitiateOauthFlowOauthAuthorizeGatewayIdGetData, InitiateOauthFlowOauthAuthorizeGatewayIdGetErrors, InitiateOauthFlowOauthAuthorizeGatewayIdGetResponses, InviteTeamMemberTeamsTeamIdInvitationsPostData, InviteTeamMemberTeamsTeamIdInvitationsPostErrors, InviteTeamMemberTeamsTeamIdInvitationsPostResponses, InvokeA2aAgentA2aAgentNameInvokePostData, InvokeA2aAgentA2aAgentNameInvokePostErrors, InvokeA2aAgentA2aAgentNameInvokePostResponses, LeaveTeamTeamsTeamIdLeaveDeleteData, LeaveTeamTeamsTeamIdLeaveDeleteErrors, LeaveTeamTeamsTeamIdLeaveDeleteResponses, ListA2aAgentsA2aGet2Data, ListA2aAgentsA2aGet2Errors, ListA2aAgentsA2aGet2Responses, ListA2aAgentsA2aGetData, ListA2aAgentsA2aGetErrors, ListA2aAgentsA2aGetResponses, ListAllAuthEventsAuthEmailAdminEventsGetData, ListAllAuthEventsAuthEmailAdminEventsGetErrors, ListAllAuthEventsAuthEmailAdminEventsGetResponses, ListAllTokensTokensAdminAllGetData, ListAllTokensTokensAdminAllGetErrors, ListAllTokensTokensAdminAllGetResponses, ListCatalogServersAdminMcpRegistryServersGetData, ListCatalogServersAdminMcpRegistryServersGetErrors, ListCatalogServersAdminMcpRegistryServersGetResponses, ListGatewaysGatewaysGet2Data, ListGatewaysGatewaysGet2Errors, ListGatewaysGatewaysGet2Responses, ListGatewaysGatewaysGetData, ListGatewaysGatewaysGetErrors, ListGatewaysGatewaysGetResponses, ListImportStatusesImportStatusGetData, ListImportStatusesImportStatusGetErrors, ListImportStatusesImportStatusGetResponses, ListObservabilityQueriesAdminObservabilityQueriesGetData, ListObservabilityQueriesAdminObservabilityQueriesGetErrors, ListObservabilityQueriesAdminObservabilityQueriesGetResponses, ListPluginsAdminPluginsGetData, ListPluginsAdminPluginsGetErrors, ListPluginsAdminPluginsGetResponses, ListPromptsPromptsGet2Data, ListPromptsPromptsGet2Errors, ListPromptsPromptsGet2Responses, ListPromptsPromptsGetData, ListPromptsPromptsGetErrors, ListPromptsPromptsGetResponses, ListRegisteredOauthClientsOauthRegisteredClientsGetData, ListRegisteredOauthClientsOauthRegisteredClientsGetErrors, ListRegisteredOauthClientsOauthRegisteredClientsGetResponses, ListResourcesResourcesGet2Data, ListResourcesResourcesGet2Errors, ListResourcesResourcesGet2Responses, ListResourcesResourcesGetData, ListResourcesResourcesGetErrors, ListResourcesResourcesGetResponses, ListResourceTemplatesResourcesTemplatesListGetData, ListResourceTemplatesResourcesTemplatesListGetErrors, ListResourceTemplatesResourcesTemplatesListGetResponses, ListRolesRbacRolesGetData, ListRolesRbacRolesGetErrors, ListRolesRbacRolesGetResponses, ListRootsRootsGet2Data, ListRootsRootsGet2Errors, ListRootsRootsGet2Responses, ListRootsRootsGetData, ListRootsRootsGetErrors, ListRootsRootsGetResponses, ListServersServersGet2Data, ListServersServersGet2Errors, ListServersServersGet2Responses, ListServersServersGetData, ListServersServersGetErrors, ListServersServersGetResponses, ListSessionsReverseProxySessionsGetData, ListSessionsReverseProxySessionsGetErrors, ListSessionsReverseProxySessionsGetResponses, ListSpansObservabilitySpansGetData, ListSpansObservabilitySpansGetErrors, ListSpansObservabilitySpansGetResponses, ListTagsTagsGet2Data, ListTagsTagsGet2Errors, ListTagsTagsGet2Responses, ListTagsTagsGetData, ListTagsTagsGetErrors, ListTagsTagsGetResponses, ListTeamInvitationsTeamsTeamIdInvitationsGetData, ListTeamInvitationsTeamsTeamIdInvitationsGetErrors, ListTeamInvitationsTeamsTeamIdInvitationsGetResponses, ListTeamJoinRequestsTeamsTeamIdJoinRequestsGetData, ListTeamJoinRequestsTeamsTeamIdJoinRequestsGetErrors, ListTeamJoinRequestsTeamsTeamIdJoinRequestsGetResponses, ListTeamMembersTeamsTeamIdMembersGetData, ListTeamMembersTeamsTeamIdMembersGetErrors, ListTeamMembersTeamsTeamIdMembersGetResponses, ListTeamsTeamsGetData, ListTeamsTeamsGetErrors, ListTeamsTeamsGetResponses, ListTeamTokensTokensTeamsTeamIdGetData, ListTeamTokensTokensTeamsTeamIdGetErrors, ListTeamTokensTokensTeamsTeamIdGetResponses, ListTokensTokensGetData, ListTokensTokensGetErrors, ListTokensTokensGetResponses, ListToolsToolsGet2Data, ListToolsToolsGet2Errors, ListToolsToolsGet2Responses, ListToolsToolsGetData, ListToolsToolsGetErrors, ListToolsToolsGetResponses, ListTracesObservabilityTracesGetData, ListTracesObservabilityTracesGetErrors, ListTracesObservabilityTracesGetResponses, ListUsersAuthEmailAdminUsersGetData, ListUsersAuthEmailAdminUsersGetErrors, ListUsersAuthEmailAdminUsersGetResponses, LoginAuthEmailLoginPostData, LoginAuthEmailLoginPostErrors, LoginAuthEmailLoginPostResponses, LoginAuthLoginPostData, LoginAuthLoginPostErrors, LoginAuthLoginPostResponses, MessageEndpointServersServerIdMessagePostData, MessageEndpointServersServerIdMessagePostErrors, MessageEndpointServersServerIdMessagePostResponses, MetricsMetricsPrometheusGetData, MetricsMetricsPrometheusGetResponses, OauthCallbackOauthCallbackGetData, OauthCallbackOauthCallbackGetErrors, OauthCallbackOauthCallbackGetResponses, PingProtocolPingPostData, PingProtocolPingPostErrors, PingProtocolPingPostResponses, QueryTracesAdvancedObservabilityTracesQueryPostData, QueryTracesAdvancedObservabilityTracesQueryPostErrors, QueryTracesAdvancedObservabilityTracesQueryPostResponses, ReadinessCheckReadyGetData, ReadinessCheckReadyGetResponses, ReadResourceResourcesResourceIdGetData, ReadResourceResourcesResourceIdGetErrors, ReadResourceResourcesResourceIdGetResponses, RegisterAuthEmailRegisterPostData, RegisterAuthEmailRegisterPostErrors, RegisterAuthEmailRegisterPostResponses, RegisterCatalogServerAdminMcpRegistryServerIdRegisterPostData, RegisterCatalogServerAdminMcpRegistryServerIdRegisterPostErrors, RegisterCatalogServerAdminMcpRegistryServerIdRegisterPostResponses, RegisterGatewayGatewaysPost2Data, RegisterGatewayGatewaysPost2Errors, RegisterGatewayGatewaysPost2Responses, RegisterGatewayGatewaysPostData, RegisterGatewayGatewaysPostErrors, RegisterGatewayGatewaysPostResponses, RejectJoinRequestTeamsTeamIdJoinRequestsRequestIdDeleteData, RejectJoinRequestTeamsTeamIdJoinRequestsRequestIdDeleteErrors, RejectJoinRequestTeamsTeamIdJoinRequestsRequestIdDeleteResponses, RemoveRootRootsUriDeleteData, RemoveRootRootsUriDeleteErrors, RemoveRootRootsUriDeleteResponses, RemoveTeamMemberTeamsTeamIdMembersUserEmailDeleteData, RemoveTeamMemberTeamsTeamIdMembersUserEmailDeleteErrors, RemoveTeamMemberTeamsTeamIdMembersUserEmailDeleteResponses, RequestToJoinTeamTeamsTeamIdJoinPostData, RequestToJoinTeamTeamsTeamIdJoinPostErrors, RequestToJoinTeamTeamsTeamIdJoinPostResponses, ResetMetricsMetricsResetPostData, ResetMetricsMetricsResetPostErrors, ResetMetricsMetricsResetPostResponses, RevokeTokenTokensTokenIdDeleteData, RevokeTokenTokensTokenIdDeleteErrors, RevokeTokenTokensTokenIdDeleteResponses, RevokeUserRoleRbacUsersUserEmailRolesRoleIdDeleteData, RevokeUserRoleRbacUsersUserEmailRolesRoleIdDeleteErrors, RevokeUserRoleRbacUsersUserEmailRolesRoleIdDeleteResponses, RootRedirectGetData, RootRedirectGetResponses, SaveObservabilityQueryAdminObservabilityQueriesPostData, SaveObservabilityQueryAdminObservabilityQueriesPostErrors, SaveObservabilityQueryAdminObservabilityQueriesPostResponses, SecurityHealthHealthSecurityGetData, SecurityHealthHealthSecurityGetResponses, SendRequestToSessionReverseProxySessionsSessionIdRequestPostData, SendRequestToSessionReverseProxySessionsSessionIdRequestPostErrors, SendRequestToSessionReverseProxySessionsSessionIdRequestPostResponses, ServerGetPromptsServersServerIdPromptsGetData, ServerGetPromptsServersServerIdPromptsGetErrors, ServerGetPromptsServersServerIdPromptsGetResponses, ServerGetResourcesServersServerIdResourcesGetData, ServerGetResourcesServersServerIdResourcesGetErrors, ServerGetResourcesServersServerIdResourcesGetResponses, ServerGetToolsServersServerIdToolsGetData, ServerGetToolsServersServerIdToolsGetErrors, ServerGetToolsServersServerIdToolsGetResponses, SetLogLevelLoggingSetLevelPostData, SetLogLevelLoggingSetLevelPostErrors, SetLogLevelLoggingSetLevelPostResponses, SseEndpointReverseProxySseSessionIdGetData, SseEndpointReverseProxySseSessionIdGetErrors, SseEndpointReverseProxySseSessionIdGetResponses, SseEndpointServersServerIdSseGetData, SseEndpointServersServerIdSseGetErrors, SseEndpointServersServerIdSseGetResponses, StatusLlmchatStatusUserIdGetData, StatusLlmchatStatusUserIdGetErrors, StatusLlmchatStatusUserIdGetResponses, SubscribeResourceResourcesSubscribeResourceIdPostData, SubscribeResourceResourcesSubscribeResourceIdPostErrors, SubscribeResourceResourcesSubscribeResourceIdPostResponses, SubscribeRootsChangesRootsChangesGetData, SubscribeRootsChangesRootsChangesGetErrors, SubscribeRootsChangesRootsChangesGetResponses, ToggleA2aAgentStatusA2aAgentIdTogglePostData, ToggleA2aAgentStatusA2aAgentIdTogglePostErrors, ToggleA2aAgentStatusA2aAgentIdTogglePostResponses, ToggleGatewayStatusGatewaysGatewayIdTogglePostData, ToggleGatewayStatusGatewaysGatewayIdTogglePostErrors, ToggleGatewayStatusGatewaysGatewayIdTogglePostResponses, TogglePromptStatusPromptsPromptIdTogglePostData, TogglePromptStatusPromptsPromptIdTogglePostErrors, TogglePromptStatusPromptsPromptIdTogglePostResponses, ToggleResourceStatusResourcesResourceIdTogglePostData, ToggleResourceStatusResourcesResourceIdTogglePostErrors, ToggleResourceStatusResourcesResourceIdTogglePostResponses, ToggleServerStatusServersServerIdTogglePostData, ToggleServerStatusServersServerIdTogglePostErrors, ToggleServerStatusServersServerIdTogglePostResponses, ToggleToolStatusToolsToolIdTogglePostData, ToggleToolStatusToolsToolIdTogglePostErrors, ToggleToolStatusToolsToolIdTogglePostResponses, TrackQueryUsageAdminObservabilityQueriesQueryIdUsePostData, TrackQueryUsageAdminObservabilityQueriesQueryIdUsePostErrors, TrackQueryUsageAdminObservabilityQueriesQueryIdUsePostResponses, UpdateA2aAgentA2aAgentIdPutData, UpdateA2aAgentA2aAgentIdPutErrors, UpdateA2aAgentA2aAgentIdPutResponses, UpdateGatewayGatewaysGatewayIdPutData, UpdateGatewayGatewaysGatewayIdPutErrors, UpdateGatewayGatewaysGatewayIdPutResponses, UpdateGlobalPassthroughHeadersAdminConfigPassthroughHeadersPutData, UpdateGlobalPassthroughHeadersAdminConfigPassthroughHeadersPutErrors, UpdateGlobalPassthroughHeadersAdminConfigPassthroughHeadersPutResponses, UpdateObservabilityQueryAdminObservabilityQueriesQueryIdPutData, UpdateObservabilityQueryAdminObservabilityQueriesQueryIdPutErrors, UpdateObservabilityQueryAdminObservabilityQueriesQueryIdPutResponses, UpdatePromptPromptsPromptIdPutData, UpdatePromptPromptsPromptIdPutErrors, UpdatePromptPromptsPromptIdPutResponses, UpdateResourceResourcesResourceIdPutData, UpdateResourceResourcesResourceIdPutErrors, UpdateResourceResourcesResourceIdPutResponses, UpdateRoleRbacRolesRoleIdPutData, UpdateRoleRbacRolesRoleIdPutErrors, UpdateRoleRbacRolesRoleIdPutResponses, UpdateServerServersServerIdPutData, UpdateServerServersServerIdPutErrors, UpdateServerServersServerIdPutResponses, UpdateTeamMemberTeamsTeamIdMembersUserEmailPutData, UpdateTeamMemberTeamsTeamIdMembersUserEmailPutErrors, UpdateTeamMemberTeamsTeamIdMembersUserEmailPutResponses, UpdateTeamTeamsTeamIdPutData, UpdateTeamTeamsTeamIdPutErrors, UpdateTeamTeamsTeamIdPutResponses, UpdateTokenTokensTokenIdPutData, UpdateTokenTokensTokenIdPutErrors, UpdateTokenTokensTokenIdPutResponses, UpdateToolToolsToolIdPutData, UpdateToolToolsToolIdPutErrors, UpdateToolToolsToolIdPutResponses, UpdateUserAuthEmailAdminUsersUserEmailPutData, UpdateUserAuthEmailAdminUsersUserEmailPutErrors, UpdateUserAuthEmailAdminUsersUserEmailPutResponses, UtilityMessageEndpointMessagePostData, UtilityMessageEndpointMessagePostErrors, UtilityMessageEndpointMessagePostResponses, UtilitySseEndpointSseGetData, UtilitySseEndpointSseGetErrors, UtilitySseEndpointSseGetResponses, VersionEndpointVersionGetData, VersionEndpointVersionGetErrors, VersionEndpointVersionGetResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Metrics
 *
 * Endpoint that serves Prometheus metrics.
 */
export const metricsMetricsPrometheusGet = <ThrowOnError extends boolean = false>(options?: Options<MetricsMetricsPrometheusGetData, ThrowOnError>) => (options?.client ?? client).get<MetricsMetricsPrometheusGetResponses, unknown, ThrowOnError>({ url: '/metrics/prometheus', ...options });

/**
 * Healthcheck
 *
 * Perform a basic health check to verify database connectivity.
 *
 * Args:
 * db: SQLAlchemy session dependency.
 *
 * Returns:
 * A dictionary with the health status and optional error message.
 */
export const healthcheckHealthGet = <ThrowOnError extends boolean = false>(options?: Options<HealthcheckHealthGetData, ThrowOnError>) => (options?.client ?? client).get<HealthcheckHealthGetResponses, unknown, ThrowOnError>({ url: '/health', ...options });

/**
 * Readiness Check
 *
 * Perform a readiness check to verify if the application is ready to receive traffic.
 *
 * Args:
 * db: SQLAlchemy session dependency.
 *
 * Returns:
 * JSONResponse with status 200 if ready, 503 if not.
 */
export const readinessCheckReadyGet = <ThrowOnError extends boolean = false>(options?: Options<ReadinessCheckReadyGetData, ThrowOnError>) => (options?.client ?? client).get<ReadinessCheckReadyGetResponses, unknown, ThrowOnError>({ url: '/ready', ...options });

/**
 * Security Health
 *
 * Get the security configuration health status.
 *
 * Args:
 * request (Request): The incoming HTTP request containing headers for authentication.
 *
 * Returns:
 * dict: A dictionary containing the overall security health status, score,
 * individual checks, warning count, and timestamp. Warnings are included
 * only if authentication passes or when running in development mode.
 *
 * Raises:
 * HTTPException: If authentication is required and the request does not
 * include a valid bearer token in the Authorization header.
 */
export const securityHealthHealthSecurityGet = <ThrowOnError extends boolean = false>(options?: Options<SecurityHealthHealthSecurityGetData, ThrowOnError>) => (options?.client ?? client).get<SecurityHealthHealthSecurityGetResponses, unknown, ThrowOnError>({ url: '/health/security', ...options });

/**
 * Diagnostics (auth required)
 *
 * Serve diagnostics as JSON, full HTML, or partial HTML.
 *
 * Main endpoint that gathers all diagnostic information and returns it in the
 * requested format. Requires authentication via HTTP Basic Auth or session.
 *
 * The endpoint supports three output formats:
 * - JSON (default): Machine-readable diagnostic data
 * - Full HTML: Complete HTML page with styled tables
 * - Partial HTML: HTML fragment for embedding (when partial=True)
 *
 * Args:
 * request (Request): The incoming FastAPI request object.
 * fmt (Optional[str]): Query parameter to force format ('html' for HTML output).
 * partial (Optional[bool]): Query parameter to request partial HTML fragment.
 * _user: Injected authenticated user from require_auth dependency.
 *
 * Returns:
 * Response: JSONResponse with diagnostic data, or HTMLResponse with formatted page.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import Mock, AsyncMock, patch
 * >>> from fastapi import Request
 * >>> from fastapi.responses import JSONResponse, HTMLResponse
 * >>>
 * >>> # Create mock request
 * >>> mock_request = Mock(spec=Request)
 * >>> mock_request.headers = {"accept": "application/json"}
 * >>>
 * >>> # Test JSON response (default)
 * >>> async def test_json():
 * ...     with patch('mcpgateway.version.REDIS_AVAILABLE', False):
 * ...         with patch('mcpgateway.version._build_payload') as mock_build:
 * ...             mock_build.return_value = {"test": "data"}
 * ...             response = await version_endpoint(mock_request, fmt=None, partial=False, _user="testuser")
 * ...             return response
 * >>>
 * >>> response = asyncio.run(test_json())
 * >>> isinstance(response, JSONResponse)
 * True
 *
 * >>> # Test HTML response with fmt parameter
 * >>> async def test_html_fmt():
 * ...     with patch('mcpgateway.version.REDIS_AVAILABLE', False):
 * ...         with patch('mcpgateway.version._build_payload') as mock_build:
 * ...             with patch('mcpgateway.version._render_html') as mock_render:
 * ...                 mock_build.return_value = {"test": "data"}
 * ...                 mock_render.return_value = "<html>test</html>"
 * ...                 response = await version_endpoint(mock_request, fmt="html", partial=False, _user="testuser")
 * ...                 return response
 * >>>
 * >>> response = asyncio.run(test_html_fmt())
 * >>> isinstance(response, HTMLResponse)
 * True
 *
 * >>> # Test with Redis available
 * >>> async def test_with_redis():
 * ...     mock_redis = AsyncMock()
 * ...     mock_redis.ping = AsyncMock(return_value=True)
 * ...     mock_redis.info = AsyncMock(return_value={"redis_version": "7.0.5"})
 * ...
 * ...     with patch('mcpgateway.version.REDIS_AVAILABLE', True):
 * ...         with patch('mcpgateway.version.settings') as mock_settings:
 * ...             mock_settings.cache_type = "redis"
 * ...             mock_settings.redis_url = "redis://localhost:6379"
 * ...             with patch('mcpgateway.version.aioredis.Redis.from_url', return_value=mock_redis):
 * ...                 with patch('mcpgateway.version._build_payload') as mock_build:
 * ...                     mock_build.return_value = {"redis": {"version": "7.0.5"}}
 * ...                     response = await version_endpoint(mock_request, _user="testuser")
 * ...                     # Verify Redis was checked
 * ...                     mock_redis.ping.assert_called_once()
 * ...                     mock_redis.info.assert_called_once()
 * ...                     # Verify payload was built with Redis info
 * ...                     mock_build.assert_called_once_with("7.0.5", True)
 * ...                     return response
 * >>>
 * >>> response = asyncio.run(test_with_redis())
 * >>> isinstance(response, JSONResponse)
 * True
 */
export const versionEndpointVersionGet = <ThrowOnError extends boolean = false>(options?: Options<VersionEndpointVersionGetData, ThrowOnError>) => (options?.client ?? client).get<VersionEndpointVersionGetResponses, VersionEndpointVersionGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/version',
    ...options
});

/**
 * Initialize
 *
 * Initialize a protocol.
 *
 * This endpoint handles the initialization process of a protocol by accepting
 * a JSON request body and processing it. The `require_auth` dependency ensures that
 * the user is authenticated before proceeding.
 *
 * Args:
 * request (Request): The incoming request object containing the JSON body.
 * user (str): The authenticated user (from `require_auth` dependency).
 *
 * Returns:
 * InitializeResult: The result of the initialization process.
 *
 * Raises:
 * HTTPException: If the request body contains invalid JSON, a 400 Bad Request error is raised.
 */
export const initializeProtocolInitializePost = <ThrowOnError extends boolean = false>(options?: Options<InitializeProtocolInitializePostData, ThrowOnError>) => (options?.client ?? client).post<InitializeProtocolInitializePostResponses, InitializeProtocolInitializePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/protocol/initialize',
    ...options
});

/**
 * Ping
 *
 * Handle a ping request according to the MCP specification.
 *
 * This endpoint expects a JSON-RPC request with the method "ping" and responds
 * with a JSON-RPC response containing an empty result, as required by the protocol.
 *
 * Args:
 * request (Request): The incoming FastAPI request.
 * user (str): The authenticated user (dependency injection).
 *
 * Returns:
 * JSONResponse: A JSON-RPC response with an empty result or an error response.
 *
 * Raises:
 * HTTPException: If the request method is not "ping".
 */
export const pingProtocolPingPost = <ThrowOnError extends boolean = false>(options?: Options<PingProtocolPingPostData, ThrowOnError>) => (options?.client ?? client).post<PingProtocolPingPostResponses, PingProtocolPingPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/protocol/ping',
    ...options
});

/**
 * Handle Notification
 *
 * Handles incoming notifications from clients. Depending on the notification method,
 * different actions are taken (e.g., logging initialization, cancellation, or messages).
 *
 * Args:
 * request (Request): The incoming request containing the notification data.
 * user (str): The authenticated user making the request.
 */
export const handleNotificationProtocolNotificationsPost = <ThrowOnError extends boolean = false>(options?: Options<HandleNotificationProtocolNotificationsPostData, ThrowOnError>) => (options?.client ?? client).post<HandleNotificationProtocolNotificationsPostResponses, HandleNotificationProtocolNotificationsPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/protocol/notifications',
    ...options
});

/**
 * Handle Completion
 *
 * Handles the completion of tasks by processing a completion request.
 *
 * Args:
 * request (Request): The incoming request with completion data.
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * The result of the completion process.
 */
export const handleCompletionProtocolCompletionCompletePost = <ThrowOnError extends boolean = false>(options?: Options<HandleCompletionProtocolCompletionCompletePostData, ThrowOnError>) => (options?.client ?? client).post<HandleCompletionProtocolCompletionCompletePostResponses, HandleCompletionProtocolCompletionCompletePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/protocol/completion/complete',
    ...options
});

/**
 * Handle Sampling
 *
 * Handles the creation of a new message for sampling.
 *
 * Args:
 * request (Request): The incoming request with sampling data.
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * The result of the message creation process.
 */
export const handleSamplingProtocolSamplingCreateMessagePost = <ThrowOnError extends boolean = false>(options?: Options<HandleSamplingProtocolSamplingCreateMessagePostData, ThrowOnError>) => (options?.client ?? client).post<HandleSamplingProtocolSamplingCreateMessagePostResponses, HandleSamplingProtocolSamplingCreateMessagePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/protocol/sampling/createMessage',
    ...options
});

/**
 * List Tools
 *
 * List all registered tools with team-based filtering and pagination support.
 *
 * Args:
 * request (Request): The FastAPI request object for team_id retrieval
 * cursor: Pagination cursor for fetching the next set of results
 * include_inactive: Whether to include inactive tools in the results
 * tags: Comma-separated list of tags to filter by (e.g., "api,data")
 * team_id: Optional team ID to filter tools by specific team
 * visibility: Optional visibility filter (private, team, public)
 * gateway_id: Optional gateway ID to filter tools by specific gateway
 * db: Database session
 * apijsonpath: JSON path modifier to filter or transform the response
 * user: Authenticated user with permissions
 *
 * Returns:
 * List of tools or modified result based on jsonpath
 */
export const listToolsToolsGet = <ThrowOnError extends boolean = false>(options?: Options<ListToolsToolsGetData, ThrowOnError>) => (options?.client ?? client).get<ListToolsToolsGetResponses, ListToolsToolsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tools/',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Create Tool
 *
 * Creates a new tool in the system with team assignment support.
 *
 * Args:
 * tool (ToolCreate): The data needed to create the tool.
 * request (Request): The FastAPI request object for metadata extraction.
 * team_id (Optional[str]): Team ID to assign the tool to.
 * visibility (str): Tool visibility (private, team, public).
 * db (Session): The database session dependency.
 * user: The authenticated user making the request.
 *
 * Returns:
 * ToolRead: The created tool data.
 *
 * Raises:
 * HTTPException: If the tool name already exists or other validation errors occur.
 */
export const createToolToolsPost = <ThrowOnError extends boolean = false>(options: Options<CreateToolToolsPostData, ThrowOnError>) => (options.client ?? client).post<CreateToolToolsPostResponses, CreateToolToolsPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tools/',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List Tools
 *
 * List all registered tools with team-based filtering and pagination support.
 *
 * Args:
 * request (Request): The FastAPI request object for team_id retrieval
 * cursor: Pagination cursor for fetching the next set of results
 * include_inactive: Whether to include inactive tools in the results
 * tags: Comma-separated list of tags to filter by (e.g., "api,data")
 * team_id: Optional team ID to filter tools by specific team
 * visibility: Optional visibility filter (private, team, public)
 * gateway_id: Optional gateway ID to filter tools by specific gateway
 * db: Database session
 * apijsonpath: JSON path modifier to filter or transform the response
 * user: Authenticated user with permissions
 *
 * Returns:
 * List of tools or modified result based on jsonpath
 */
export const listToolsToolsGet2 = <ThrowOnError extends boolean = false>(options?: Options<ListToolsToolsGet2Data, ThrowOnError>) => (options?.client ?? client).get<ListToolsToolsGet2Responses, ListToolsToolsGet2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tools',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Create Tool
 *
 * Creates a new tool in the system with team assignment support.
 *
 * Args:
 * tool (ToolCreate): The data needed to create the tool.
 * request (Request): The FastAPI request object for metadata extraction.
 * team_id (Optional[str]): Team ID to assign the tool to.
 * visibility (str): Tool visibility (private, team, public).
 * db (Session): The database session dependency.
 * user: The authenticated user making the request.
 *
 * Returns:
 * ToolRead: The created tool data.
 *
 * Raises:
 * HTTPException: If the tool name already exists or other validation errors occur.
 */
export const createToolToolsPost2 = <ThrowOnError extends boolean = false>(options: Options<CreateToolToolsPost2Data, ThrowOnError>) => (options.client ?? client).post<CreateToolToolsPost2Responses, CreateToolToolsPost2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tools',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete Tool
 *
 * Permanently deletes a tool by ID.
 *
 * Args:
 * tool_id (str): The ID of the tool to delete.
 * db (Session): The database session dependency.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * Dict[str, str]: A confirmation message upon successful deletion.
 *
 * Raises:
 * HTTPException: If an error occurs during deletion.
 */
export const deleteToolToolsToolIdDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteToolToolsToolIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<DeleteToolToolsToolIdDeleteResponses, DeleteToolToolsToolIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tools/{tool_id}',
    ...options
});

/**
 * Get Tool
 *
 * Retrieve a tool by ID, optionally applying a JSONPath post-filter.
 *
 * Args:
 * tool_id: The numeric ID of the tool.
 * db:     Active SQLAlchemy session (dependency).
 * user:   Authenticated username (dependency).
 * apijsonpath: Optional JSON-Path modifier supplied in the body.
 *
 * Returns:
 * The raw ``ToolRead`` model **or** a JSON-transformed ``dict`` if
 * a JSONPath filter/mapping was supplied.
 *
 * Raises:
 * HTTPException: If the tool does not exist or the transformation fails.
 */
export const getToolToolsToolIdGet = <ThrowOnError extends boolean = false>(options: Options<GetToolToolsToolIdGetData, ThrowOnError>) => (options.client ?? client).get<GetToolToolsToolIdGetResponses, GetToolToolsToolIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tools/{tool_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Update Tool
 *
 * Updates an existing tool with new data.
 *
 * Args:
 * tool_id (str): The ID of the tool to update.
 * tool (ToolUpdate): The updated tool information.
 * request (Request): The FastAPI request object for metadata extraction.
 * db (Session): The database session dependency.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * ToolRead: The updated tool data.
 *
 * Raises:
 * HTTPException: If an error occurs during the update.
 */
export const updateToolToolsToolIdPut = <ThrowOnError extends boolean = false>(options: Options<UpdateToolToolsToolIdPutData, ThrowOnError>) => (options.client ?? client).put<UpdateToolToolsToolIdPutResponses, UpdateToolToolsToolIdPutErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tools/{tool_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Toggle Tool Status
 *
 * Activates or deactivates a tool.
 *
 * Args:
 * tool_id (str): The ID of the tool to toggle.
 * activate (bool): Whether to activate (`True`) or deactivate (`False`) the tool.
 * db (Session): The database session dependency.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * Dict[str, Any]: The status, message, and updated tool data.
 *
 * Raises:
 * HTTPException: If an error occurs during status toggling.
 */
export const toggleToolStatusToolsToolIdTogglePost = <ThrowOnError extends boolean = false>(options: Options<ToggleToolStatusToolsToolIdTogglePostData, ThrowOnError>) => (options.client ?? client).post<ToggleToolStatusToolsToolIdTogglePostResponses, ToggleToolStatusToolsToolIdTogglePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tools/{tool_id}/toggle',
    ...options
});

/**
 * List Resource Templates
 *
 * List all available resource templates.
 *
 * Args:
 * db (Session): Database session.
 * user (str): Authenticated user.
 *
 * Returns:
 * ListResourceTemplatesResult: A paginated list of resource templates.
 */
export const listResourceTemplatesResourcesTemplatesListGet = <ThrowOnError extends boolean = false>(options?: Options<ListResourceTemplatesResourcesTemplatesListGetData, ThrowOnError>) => (options?.client ?? client).get<ListResourceTemplatesResourcesTemplatesListGetResponses, ListResourceTemplatesResourcesTemplatesListGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/resources/templates/list',
    ...options
});

/**
 * Toggle Resource Status
 *
 * Activate or deactivate a resource by its ID.
 *
 * Args:
 * resource_id (int): The ID of the resource.
 * activate (bool): True to activate, False to deactivate.
 * db (Session): Database session.
 * user (str): Authenticated user.
 *
 * Returns:
 * Dict[str, Any]: Status message and updated resource data.
 *
 * Raises:
 * HTTPException: If toggling fails.
 */
export const toggleResourceStatusResourcesResourceIdTogglePost = <ThrowOnError extends boolean = false>(options: Options<ToggleResourceStatusResourcesResourceIdTogglePostData, ThrowOnError>) => (options.client ?? client).post<ToggleResourceStatusResourcesResourceIdTogglePostResponses, ToggleResourceStatusResourcesResourceIdTogglePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/resources/{resource_id}/toggle',
    ...options
});

/**
 * List Resources
 *
 * Retrieve a list of resources accessible to the user, with team filtering support.
 *
 * Args:
 * request (Request): The FastAPI request object for team_id retrieval
 * cursor (Optional[str]): Optional cursor for pagination.
 * include_inactive (bool): Whether to include inactive resources.
 * tags (Optional[str]): Comma-separated list of tags to filter by.
 * team_id (Optional[str]): Filter by specific team ID.
 * visibility (Optional[str]): Filter by visibility (private, team, public).
 * db (Session): Database session.
 * user (str): Authenticated user.
 *
 * Returns:
 * List[ResourceRead]: List of resources the user has access to.
 */
export const listResourcesResourcesGet = <ThrowOnError extends boolean = false>(options?: Options<ListResourcesResourcesGetData, ThrowOnError>) => (options?.client ?? client).get<ListResourcesResourcesGetResponses, ListResourcesResourcesGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/resources/',
    ...options
});

/**
 * Create Resource
 *
 * Create a new resource.
 *
 * Args:
 * resource (ResourceCreate): Data for the new resource.
 * request (Request): FastAPI request object for metadata extraction.
 * team_id (Optional[str]): Team ID to assign the resource to.
 * visibility (str): Resource visibility level (private, team, public).
 * db (Session): Database session.
 * user (str): Authenticated user.
 *
 * Returns:
 * ResourceRead: The created resource.
 *
 * Raises:
 * HTTPException: On conflict or validation errors or IntegrityError.
 */
export const createResourceResourcesPost = <ThrowOnError extends boolean = false>(options: Options<CreateResourceResourcesPostData, ThrowOnError>) => (options.client ?? client).post<CreateResourceResourcesPostResponses, CreateResourceResourcesPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/resources/',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List Resources
 *
 * Retrieve a list of resources accessible to the user, with team filtering support.
 *
 * Args:
 * request (Request): The FastAPI request object for team_id retrieval
 * cursor (Optional[str]): Optional cursor for pagination.
 * include_inactive (bool): Whether to include inactive resources.
 * tags (Optional[str]): Comma-separated list of tags to filter by.
 * team_id (Optional[str]): Filter by specific team ID.
 * visibility (Optional[str]): Filter by visibility (private, team, public).
 * db (Session): Database session.
 * user (str): Authenticated user.
 *
 * Returns:
 * List[ResourceRead]: List of resources the user has access to.
 */
export const listResourcesResourcesGet2 = <ThrowOnError extends boolean = false>(options?: Options<ListResourcesResourcesGet2Data, ThrowOnError>) => (options?.client ?? client).get<ListResourcesResourcesGet2Responses, ListResourcesResourcesGet2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/resources',
    ...options
});

/**
 * Create Resource
 *
 * Create a new resource.
 *
 * Args:
 * resource (ResourceCreate): Data for the new resource.
 * request (Request): FastAPI request object for metadata extraction.
 * team_id (Optional[str]): Team ID to assign the resource to.
 * visibility (str): Resource visibility level (private, team, public).
 * db (Session): Database session.
 * user (str): Authenticated user.
 *
 * Returns:
 * ResourceRead: The created resource.
 *
 * Raises:
 * HTTPException: On conflict or validation errors or IntegrityError.
 */
export const createResourceResourcesPost2 = <ThrowOnError extends boolean = false>(options: Options<CreateResourceResourcesPost2Data, ThrowOnError>) => (options.client ?? client).post<CreateResourceResourcesPost2Responses, CreateResourceResourcesPost2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/resources',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete Resource
 *
 * Delete a resource by its ID.
 *
 * Args:
 * resource_id (str): ID of the resource to delete.
 * db (Session): Database session.
 * user (str): Authenticated user.
 *
 * Returns:
 * Dict[str, str]: Status message indicating deletion success.
 *
 * Raises:
 * HTTPException: If the resource is not found or deletion fails.
 */
export const deleteResourceResourcesResourceIdDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteResourceResourcesResourceIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<DeleteResourceResourcesResourceIdDeleteResponses, DeleteResourceResourcesResourceIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/resources/{resource_id}',
    ...options
});

/**
 * Read Resource
 *
 * Read a resource by its ID with plugin support.
 *
 * Args:
 * resource_id (str): ID of the resource.
 * request (Request): FastAPI request object for context.
 * db (Session): Database session.
 * user (str): Authenticated user.
 *
 * Returns:
 * Any: The content of the resource.
 *
 * Raises:
 * HTTPException: If the resource cannot be found or read.
 */
export const readResourceResourcesResourceIdGet = <ThrowOnError extends boolean = false>(options: Options<ReadResourceResourcesResourceIdGetData, ThrowOnError>) => (options.client ?? client).get<ReadResourceResourcesResourceIdGetResponses, ReadResourceResourcesResourceIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/resources/{resource_id}',
    ...options
});

/**
 * Update Resource
 *
 * Update a resource identified by its ID.
 *
 * Args:
 * resource_id (str): ID of the resource.
 * resource (ResourceUpdate): New resource data.
 * request (Request): The FastAPI request object for metadata extraction.
 * db (Session): Database session.
 * user (str): Authenticated user.
 *
 * Returns:
 * ResourceRead: The updated resource.
 *
 * Raises:
 * HTTPException: If the resource is not found or update fails.
 */
export const updateResourceResourcesResourceIdPut = <ThrowOnError extends boolean = false>(options: Options<UpdateResourceResourcesResourceIdPutData, ThrowOnError>) => (options.client ?? client).put<UpdateResourceResourcesResourceIdPutResponses, UpdateResourceResourcesResourceIdPutErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/resources/{resource_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Subscribe Resource
 *
 * Subscribe to server-sent events (SSE) for a specific resource.
 *
 * Args:
 * resource_id (str): ID of the resource to subscribe to.
 * user (str): Authenticated user.
 *
 * Returns:
 * StreamingResponse: A streaming response with event updates.
 */
export const subscribeResourceResourcesSubscribeResourceIdPost = <ThrowOnError extends boolean = false>(options: Options<SubscribeResourceResourcesSubscribeResourceIdPostData, ThrowOnError>) => (options.client ?? client).post<SubscribeResourceResourcesSubscribeResourceIdPostResponses, SubscribeResourceResourcesSubscribeResourceIdPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/resources/subscribe/{resource_id}',
    ...options
});

/**
 * Toggle Prompt Status
 *
 * Toggle the activation status of a prompt.
 *
 * Args:
 * prompt_id: ID of the prompt to toggle.
 * activate: True to activate, False to deactivate.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * Status message and updated prompt details.
 *
 * Raises:
 * HTTPException: If the toggle fails (e.g., prompt not found or database error); emitted with *400 Bad Request* status and an error message.
 */
export const togglePromptStatusPromptsPromptIdTogglePost = <ThrowOnError extends boolean = false>(options: Options<TogglePromptStatusPromptsPromptIdTogglePostData, ThrowOnError>) => (options.client ?? client).post<TogglePromptStatusPromptsPromptIdTogglePostResponses, TogglePromptStatusPromptsPromptIdTogglePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/prompts/{prompt_id}/toggle',
    ...options
});

/**
 * List Prompts
 *
 * List prompts accessible to the user, with team filtering support.
 *
 * Args:
 * request (Request): The FastAPI request object for team_id retrieval
 * cursor: Cursor for pagination.
 * include_inactive: Include inactive prompts.
 * tags: Comma-separated list of tags to filter by.
 * team_id: Filter by specific team ID.
 * visibility: Filter by visibility (private, team, public).
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * List of prompt records the user has access to.
 */
export const listPromptsPromptsGet = <ThrowOnError extends boolean = false>(options?: Options<ListPromptsPromptsGetData, ThrowOnError>) => (options?.client ?? client).get<ListPromptsPromptsGetResponses, ListPromptsPromptsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/prompts/',
    ...options
});

/**
 * Create Prompt
 *
 * Create a new prompt.
 *
 * Args:
 * prompt (PromptCreate): Payload describing the prompt to create.
 * request (Request): The FastAPI request object for metadata extraction.
 * team_id (Optional[str]): Team ID to assign the prompt to.
 * visibility (str): Prompt visibility level (private, team, public).
 * db (Session): Active SQLAlchemy session.
 * user (str): Authenticated username.
 *
 * Returns:
 * PromptRead: The newly-created prompt.
 *
 * Raises:
 * HTTPException: * **409 Conflict** - another prompt with the same name already exists.
 * * **400 Bad Request** - validation or persistence error raised
 * by :pyclass:`~mcpgateway.services.prompt_service.PromptService`.
 */
export const createPromptPromptsPost = <ThrowOnError extends boolean = false>(options: Options<CreatePromptPromptsPostData, ThrowOnError>) => (options.client ?? client).post<CreatePromptPromptsPostResponses, CreatePromptPromptsPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/prompts/',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List Prompts
 *
 * List prompts accessible to the user, with team filtering support.
 *
 * Args:
 * request (Request): The FastAPI request object for team_id retrieval
 * cursor: Cursor for pagination.
 * include_inactive: Include inactive prompts.
 * tags: Comma-separated list of tags to filter by.
 * team_id: Filter by specific team ID.
 * visibility: Filter by visibility (private, team, public).
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * List of prompt records the user has access to.
 */
export const listPromptsPromptsGet2 = <ThrowOnError extends boolean = false>(options?: Options<ListPromptsPromptsGet2Data, ThrowOnError>) => (options?.client ?? client).get<ListPromptsPromptsGet2Responses, ListPromptsPromptsGet2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/prompts',
    ...options
});

/**
 * Create Prompt
 *
 * Create a new prompt.
 *
 * Args:
 * prompt (PromptCreate): Payload describing the prompt to create.
 * request (Request): The FastAPI request object for metadata extraction.
 * team_id (Optional[str]): Team ID to assign the prompt to.
 * visibility (str): Prompt visibility level (private, team, public).
 * db (Session): Active SQLAlchemy session.
 * user (str): Authenticated username.
 *
 * Returns:
 * PromptRead: The newly-created prompt.
 *
 * Raises:
 * HTTPException: * **409 Conflict** - another prompt with the same name already exists.
 * * **400 Bad Request** - validation or persistence error raised
 * by :pyclass:`~mcpgateway.services.prompt_service.PromptService`.
 */
export const createPromptPromptsPost2 = <ThrowOnError extends boolean = false>(options: Options<CreatePromptPromptsPost2Data, ThrowOnError>) => (options.client ?? client).post<CreatePromptPromptsPost2Responses, CreatePromptPromptsPost2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/prompts',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete Prompt
 *
 * Delete a prompt by ID.
 *
 * Args:
 * prompt_id: ID of the prompt.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * Status message.
 *
 * Raises:
 * HTTPException: If the prompt is not found, a prompt error occurs, or an unexpected error occurs during deletion.
 */
export const deletePromptPromptsPromptIdDelete = <ThrowOnError extends boolean = false>(options: Options<DeletePromptPromptsPromptIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<DeletePromptPromptsPromptIdDeleteResponses, DeletePromptPromptsPromptIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/prompts/{prompt_id}',
    ...options
});

/**
 * Get Prompt No Args
 *
 * Get a prompt by ID without arguments.
 *
 * This endpoint is for convenience when no arguments are needed.
 *
 * Args:
 * prompt_id: The ID of the prompt to retrieve
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * The prompt template information
 *
 * Raises:
 * Exception: Re-raised from prompt service.
 */
export const getPromptNoArgsPromptsPromptIdGet = <ThrowOnError extends boolean = false>(options: Options<GetPromptNoArgsPromptsPromptIdGetData, ThrowOnError>) => (options.client ?? client).get<GetPromptNoArgsPromptsPromptIdGetResponses, GetPromptNoArgsPromptsPromptIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/prompts/{prompt_id}',
    ...options
});

/**
 * Get Prompt
 *
 * Get a prompt by prompt_id with arguments.
 *
 * This implements the prompts/get functionality from the MCP spec,
 * which requires a POST request with arguments in the body.
 *
 *
 * Args:
 * prompt_id: ID of the prompt.
 * args: Template arguments.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * Rendered prompt or metadata.
 *
 * Raises:
 * Exception: Re-raised if not a handled exception type.
 */
export const getPromptPromptsPromptIdPost = <ThrowOnError extends boolean = false>(options: Options<GetPromptPromptsPromptIdPostData, ThrowOnError>) => (options.client ?? client).post<GetPromptPromptsPromptIdPostResponses, GetPromptPromptsPromptIdPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/prompts/{prompt_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Update Prompt
 *
 * Update (overwrite) an existing prompt definition.
 *
 * Args:
 * prompt_id (str): Identifier of the prompt to update.
 * prompt (PromptUpdate): New prompt content and metadata.
 * request (Request): The FastAPI request object for metadata extraction.
 * db (Session): Active SQLAlchemy session.
 * user (str): Authenticated username.
 *
 * Returns:
 * PromptRead: The updated prompt object.
 *
 * Raises:
 * HTTPException: * **409 Conflict** - a different prompt with the same *name* already exists and is still active.
 * * **400 Bad Request** - validation or persistence error raised by :pyclass:`~mcpgateway.services.prompt_service.PromptService`.
 */
export const updatePromptPromptsPromptIdPut = <ThrowOnError extends boolean = false>(options: Options<UpdatePromptPromptsPromptIdPutData, ThrowOnError>) => (options.client ?? client).put<UpdatePromptPromptsPromptIdPutResponses, UpdatePromptPromptsPromptIdPutErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/prompts/{prompt_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Toggle Gateway Status
 *
 * Toggle the activation status of a gateway.
 *
 * Args:
 * gateway_id (str): String ID of the gateway to toggle.
 * activate (bool): ``True`` to activate, ``False`` to deactivate.
 * db (Session): Active SQLAlchemy session.
 * user (str): Authenticated username.
 *
 * Returns:
 * Dict[str, Any]: A dict containing the operation status, a message, and the updated gateway object.
 *
 * Raises:
 * HTTPException: Returned with **400 Bad Request** if the toggle operation fails (e.g., the gateway does not exist or the database raises an unexpected error).
 */
export const toggleGatewayStatusGatewaysGatewayIdTogglePost = <ThrowOnError extends boolean = false>(options: Options<ToggleGatewayStatusGatewaysGatewayIdTogglePostData, ThrowOnError>) => (options.client ?? client).post<ToggleGatewayStatusGatewaysGatewayIdTogglePostResponses, ToggleGatewayStatusGatewaysGatewayIdTogglePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/gateways/{gateway_id}/toggle',
    ...options
});

/**
 * List Gateways
 *
 * List all gateways.
 *
 * Args:
 * request (Request): The FastAPI request object for team_id retrieval
 * include_inactive: Include inactive gateways.
 * team_id (Optional): Filter by specific team ID.
 * visibility (Optional): Filter by visibility (private, team, public).
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * List of gateway records.
 */
export const listGatewaysGatewaysGet = <ThrowOnError extends boolean = false>(options?: Options<ListGatewaysGatewaysGetData, ThrowOnError>) => (options?.client ?? client).get<ListGatewaysGatewaysGetResponses, ListGatewaysGatewaysGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/gateways/',
    ...options
});

/**
 * Register Gateway
 *
 * Register a new gateway.
 *
 * Args:
 * gateway: Gateway creation data.
 * request: The FastAPI request object for metadata extraction.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * Created gateway.
 */
export const registerGatewayGatewaysPost = <ThrowOnError extends boolean = false>(options: Options<RegisterGatewayGatewaysPostData, ThrowOnError>) => (options.client ?? client).post<RegisterGatewayGatewaysPostResponses, RegisterGatewayGatewaysPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/gateways/',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List Gateways
 *
 * List all gateways.
 *
 * Args:
 * request (Request): The FastAPI request object for team_id retrieval
 * include_inactive: Include inactive gateways.
 * team_id (Optional): Filter by specific team ID.
 * visibility (Optional): Filter by visibility (private, team, public).
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * List of gateway records.
 */
export const listGatewaysGatewaysGet2 = <ThrowOnError extends boolean = false>(options?: Options<ListGatewaysGatewaysGet2Data, ThrowOnError>) => (options?.client ?? client).get<ListGatewaysGatewaysGet2Responses, ListGatewaysGatewaysGet2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/gateways',
    ...options
});

/**
 * Register Gateway
 *
 * Register a new gateway.
 *
 * Args:
 * gateway: Gateway creation data.
 * request: The FastAPI request object for metadata extraction.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * Created gateway.
 */
export const registerGatewayGatewaysPost2 = <ThrowOnError extends boolean = false>(options: Options<RegisterGatewayGatewaysPost2Data, ThrowOnError>) => (options.client ?? client).post<RegisterGatewayGatewaysPost2Responses, RegisterGatewayGatewaysPost2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/gateways',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete Gateway
 *
 * Delete a gateway by ID.
 *
 * Args:
 * gateway_id: ID of the gateway.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * Status message.
 *
 * Raises:
 * HTTPException: If permission denied (403), gateway not found (404), or other gateway error (400).
 */
export const deleteGatewayGatewaysGatewayIdDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteGatewayGatewaysGatewayIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<DeleteGatewayGatewaysGatewayIdDeleteResponses, DeleteGatewayGatewaysGatewayIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/gateways/{gateway_id}',
    ...options
});

/**
 * Get Gateway
 *
 * Retrieve a gateway by ID.
 *
 * Args:
 * gateway_id: ID of the gateway.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * Gateway data.
 */
export const getGatewayGatewaysGatewayIdGet = <ThrowOnError extends boolean = false>(options: Options<GetGatewayGatewaysGatewayIdGetData, ThrowOnError>) => (options.client ?? client).get<GetGatewayGatewaysGatewayIdGetResponses, GetGatewayGatewaysGatewayIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/gateways/{gateway_id}',
    ...options
});

/**
 * Update Gateway
 *
 * Update a gateway.
 *
 * Args:
 * gateway_id: Gateway ID.
 * gateway: Gateway update data.
 * request (Request): The FastAPI request object for metadata extraction.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * Updated gateway.
 */
export const updateGatewayGatewaysGatewayIdPut = <ThrowOnError extends boolean = false>(options: Options<UpdateGatewayGatewaysGatewayIdPutData, ThrowOnError>) => (options.client ?? client).put<UpdateGatewayGatewaysGatewayIdPutResponses, UpdateGatewayGatewaysGatewayIdPutErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/gateways/{gateway_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List Roots
 *
 * Retrieve a list of all registered roots.
 *
 * Args:
 * user: Authenticated user.
 *
 * Returns:
 * List of Root objects.
 */
export const listRootsRootsGet = <ThrowOnError extends boolean = false>(options?: Options<ListRootsRootsGetData, ThrowOnError>) => (options?.client ?? client).get<ListRootsRootsGetResponses, ListRootsRootsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/roots/',
    ...options
});

/**
 * Add Root
 *
 * Add a new root.
 *
 * Args:
 * root: Root object containing URI and name.
 * user: Authenticated user.
 *
 * Returns:
 * The added Root object.
 */
export const addRootRootsPost = <ThrowOnError extends boolean = false>(options: Options<AddRootRootsPostData, ThrowOnError>) => (options.client ?? client).post<AddRootRootsPostResponses, AddRootRootsPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/roots/',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List Roots
 *
 * Retrieve a list of all registered roots.
 *
 * Args:
 * user: Authenticated user.
 *
 * Returns:
 * List of Root objects.
 */
export const listRootsRootsGet2 = <ThrowOnError extends boolean = false>(options?: Options<ListRootsRootsGet2Data, ThrowOnError>) => (options?.client ?? client).get<ListRootsRootsGet2Responses, ListRootsRootsGet2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/roots',
    ...options
});

/**
 * Add Root
 *
 * Add a new root.
 *
 * Args:
 * root: Root object containing URI and name.
 * user: Authenticated user.
 *
 * Returns:
 * The added Root object.
 */
export const addRootRootsPost2 = <ThrowOnError extends boolean = false>(options: Options<AddRootRootsPost2Data, ThrowOnError>) => (options.client ?? client).post<AddRootRootsPost2Responses, AddRootRootsPost2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/roots',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Remove Root
 *
 * Remove a registered root by URI.
 *
 * Args:
 * uri: URI of the root to remove.
 * user: Authenticated user.
 *
 * Returns:
 * Status message indicating result.
 */
export const removeRootRootsUriDelete = <ThrowOnError extends boolean = false>(options: Options<RemoveRootRootsUriDeleteData, ThrowOnError>) => (options.client ?? client).delete<RemoveRootRootsUriDeleteResponses, RemoveRootRootsUriDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/roots/{uri}',
    ...options
});

/**
 * Subscribe Roots Changes
 *
 * Subscribe to real-time changes in root list via Server-Sent Events (SSE).
 *
 * Args:
 * user: Authenticated user.
 *
 * Returns:
 * StreamingResponse with event-stream media type.
 */
export const subscribeRootsChangesRootsChangesGet = <ThrowOnError extends boolean = false>(options?: Options<SubscribeRootsChangesRootsChangesGetData, ThrowOnError>) => (options?.client ?? client).get<SubscribeRootsChangesRootsChangesGetResponses, SubscribeRootsChangesRootsChangesGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/roots/changes',
    ...options
});

/**
 * Handle Rpc
 *
 * Handle RPC requests.
 *
 * Args:
 * request (Request): The incoming FastAPI request.
 * db (Session): Database session.
 * user: The authenticated user (dict with RBAC context).
 *
 * Returns:
 * Response with the RPC result or error.
 *
 * Raises:
 * PluginError: If encounters issue with plugin
 * PluginViolationError: If plugin violated the request. Example - In case of OPA plugin, if the request is denied by policy.
 */
export const handleRpcRpcPost = <ThrowOnError extends boolean = false>(options?: Options<HandleRpcRpcPostData, ThrowOnError>) => (options?.client ?? client).post<HandleRpcRpcPostResponses, HandleRpcRpcPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/rpc',
    ...options
});

/**
 * Handle Rpc
 *
 * Handle RPC requests.
 *
 * Args:
 * request (Request): The incoming FastAPI request.
 * db (Session): Database session.
 * user: The authenticated user (dict with RBAC context).
 *
 * Returns:
 * Response with the RPC result or error.
 *
 * Raises:
 * PluginError: If encounters issue with plugin
 * PluginViolationError: If plugin violated the request. Example - In case of OPA plugin, if the request is denied by policy.
 */
export const handleRpcRpcPost2 = <ThrowOnError extends boolean = false>(options?: Options<HandleRpcRpcPost2Data, ThrowOnError>) => (options?.client ?? client).post<HandleRpcRpcPost2Responses, HandleRpcRpcPost2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/rpc/',
    ...options
});

/**
 * Utility Sse Endpoint
 *
 * Establish a Server-Sent Events (SSE) connection for real-time updates.
 *
 * Args:
 * request (Request): The incoming HTTP request.
 * user (str): Authenticated username.
 *
 * Returns:
 * StreamingResponse: A streaming response that keeps the connection
 * open and pushes events to the client.
 *
 * Raises:
 * HTTPException: Returned with **500 Internal Server Error** if the SSE connection cannot be established or an unexpected error occurs while creating the transport.
 */
export const utilitySseEndpointSseGet = <ThrowOnError extends boolean = false>(options?: Options<UtilitySseEndpointSseGetData, ThrowOnError>) => (options?.client ?? client).get<UtilitySseEndpointSseGetResponses, UtilitySseEndpointSseGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/sse',
    ...options
});

/**
 * Utility Message Endpoint
 *
 * Handle a JSON-RPC message directed to a specific SSE session.
 *
 * Args:
 * request (Request): Incoming request containing the JSON-RPC payload.
 * user (str): Authenticated user.
 *
 * Returns:
 * JSONResponse: ``{"status": "success"}`` with HTTP 202 on success.
 *
 * Raises:
 * HTTPException: * **400 Bad Request** - ``session_id`` query parameter is missing or the payload cannot be parsed as JSON.
 * * **500 Internal Server Error** - An unexpected error occurs while broadcasting the message.
 */
export const utilityMessageEndpointMessagePost = <ThrowOnError extends boolean = false>(options?: Options<UtilityMessageEndpointMessagePostData, ThrowOnError>) => (options?.client ?? client).post<UtilityMessageEndpointMessagePostResponses, UtilityMessageEndpointMessagePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/message',
    ...options
});

/**
 * Set Log Level
 *
 * Update the server's log level at runtime.
 *
 * Args:
 * request: HTTP request with log level JSON body.
 * user: Authenticated user.
 *
 * Returns:
 * None
 */
export const setLogLevelLoggingSetLevelPost = <ThrowOnError extends boolean = false>(options?: Options<SetLogLevelLoggingSetLevelPostData, ThrowOnError>) => (options?.client ?? client).post<SetLogLevelLoggingSetLevelPostResponses, SetLogLevelLoggingSetLevelPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/logging/setLevel',
    ...options
});

/**
 * List Servers
 *
 * Lists servers accessible to the user, with team filtering support.
 *
 * Args:
 * request (Request): The incoming request object for team_id retrieval.
 * include_inactive (bool): Whether to include inactive servers in the response.
 * tags (Optional[str]): Comma-separated list of tags to filter by.
 * team_id (Optional[str]): Filter by specific team ID.
 * visibility (Optional[str]): Filter by visibility (private, team, public).
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * List[ServerRead]: A list of server objects the user has access to.
 */
export const listServersServersGet = <ThrowOnError extends boolean = false>(options?: Options<ListServersServersGetData, ThrowOnError>) => (options?.client ?? client).get<ListServersServersGetResponses, ListServersServersGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/servers/',
    ...options
});

/**
 * Create Server
 *
 * Creates a new server.
 *
 * Args:
 * server (ServerCreate): The data for the new server.
 * request (Request): The incoming request object for extracting metadata.
 * team_id (Optional[str]): Team ID to assign the server to.
 * visibility (str): Server visibility level (private, team, public).
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * ServerRead: The created server object.
 *
 * Raises:
 * HTTPException: If there is a conflict with the server name or other errors.
 */
export const createServerServersPost = <ThrowOnError extends boolean = false>(options: Options<CreateServerServersPostData, ThrowOnError>) => (options.client ?? client).post<CreateServerServersPostResponses, CreateServerServersPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/servers/',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List Servers
 *
 * Lists servers accessible to the user, with team filtering support.
 *
 * Args:
 * request (Request): The incoming request object for team_id retrieval.
 * include_inactive (bool): Whether to include inactive servers in the response.
 * tags (Optional[str]): Comma-separated list of tags to filter by.
 * team_id (Optional[str]): Filter by specific team ID.
 * visibility (Optional[str]): Filter by visibility (private, team, public).
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * List[ServerRead]: A list of server objects the user has access to.
 */
export const listServersServersGet2 = <ThrowOnError extends boolean = false>(options?: Options<ListServersServersGet2Data, ThrowOnError>) => (options?.client ?? client).get<ListServersServersGet2Responses, ListServersServersGet2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/servers',
    ...options
});

/**
 * Create Server
 *
 * Creates a new server.
 *
 * Args:
 * server (ServerCreate): The data for the new server.
 * request (Request): The incoming request object for extracting metadata.
 * team_id (Optional[str]): Team ID to assign the server to.
 * visibility (str): Server visibility level (private, team, public).
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * ServerRead: The created server object.
 *
 * Raises:
 * HTTPException: If there is a conflict with the server name or other errors.
 */
export const createServerServersPost2 = <ThrowOnError extends boolean = false>(options: Options<CreateServerServersPost2Data, ThrowOnError>) => (options.client ?? client).post<CreateServerServersPost2Responses, CreateServerServersPost2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/servers',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete Server
 *
 * Deletes a server by its ID.
 *
 * Args:
 * server_id (str): The ID of the server to delete.
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * Dict[str, str]: A success message indicating the server was deleted.
 *
 * Raises:
 * HTTPException: If the server is not found or there is an error.
 */
export const deleteServerServersServerIdDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteServerServersServerIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<DeleteServerServersServerIdDeleteResponses, DeleteServerServersServerIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/servers/{server_id}',
    ...options
});

/**
 * Get Server
 *
 * Retrieves a server by its ID.
 *
 * Args:
 * server_id (str): The ID of the server to retrieve.
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * ServerRead: The server object with the specified ID.
 *
 * Raises:
 * HTTPException: If the server is not found.
 */
export const getServerServersServerIdGet = <ThrowOnError extends boolean = false>(options: Options<GetServerServersServerIdGetData, ThrowOnError>) => (options.client ?? client).get<GetServerServersServerIdGetResponses, GetServerServersServerIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/servers/{server_id}',
    ...options
});

/**
 * Update Server
 *
 * Updates the information of an existing server.
 *
 * Args:
 * server_id (str): The ID of the server to update.
 * server (ServerUpdate): The updated server data.
 * request (Request): The incoming request object containing metadata.
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * ServerRead: The updated server object.
 *
 * Raises:
 * HTTPException: If the server is not found, there is a name conflict, or other errors.
 */
export const updateServerServersServerIdPut = <ThrowOnError extends boolean = false>(options: Options<UpdateServerServersServerIdPutData, ThrowOnError>) => (options.client ?? client).put<UpdateServerServersServerIdPutResponses, UpdateServerServersServerIdPutErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/servers/{server_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Toggle Server Status
 *
 * Toggles the status of a server (activate or deactivate).
 *
 * Args:
 * server_id (str): The ID of the server to toggle.
 * activate (bool): Whether to activate or deactivate the server.
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * ServerRead: The server object after the status change.
 *
 * Raises:
 * HTTPException: If the server is not found or there is an error.
 */
export const toggleServerStatusServersServerIdTogglePost = <ThrowOnError extends boolean = false>(options: Options<ToggleServerStatusServersServerIdTogglePostData, ThrowOnError>) => (options.client ?? client).post<ToggleServerStatusServersServerIdTogglePostResponses, ToggleServerStatusServersServerIdTogglePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/servers/{server_id}/toggle',
    ...options
});

/**
 * Sse Endpoint
 *
 * Establishes a Server-Sent Events (SSE) connection for real-time updates about a server.
 *
 * Args:
 * request (Request): The incoming request.
 * server_id (str): The ID of the server for which updates are received.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * The SSE response object for the established connection.
 *
 * Raises:
 * HTTPException: If there is an error in establishing the SSE connection.
 */
export const sseEndpointServersServerIdSseGet = <ThrowOnError extends boolean = false>(options: Options<SseEndpointServersServerIdSseGetData, ThrowOnError>) => (options.client ?? client).get<SseEndpointServersServerIdSseGetResponses, SseEndpointServersServerIdSseGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/servers/{server_id}/sse',
    ...options
});

/**
 * Message Endpoint
 *
 * Handles incoming messages for a specific server.
 *
 * Args:
 * request (Request): The incoming message request.
 * server_id (str): The ID of the server receiving the message.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * JSONResponse: A success status after processing the message.
 *
 * Raises:
 * HTTPException: If there are errors processing the message.
 */
export const messageEndpointServersServerIdMessagePost = <ThrowOnError extends boolean = false>(options: Options<MessageEndpointServersServerIdMessagePostData, ThrowOnError>) => (options.client ?? client).post<MessageEndpointServersServerIdMessagePostResponses, MessageEndpointServersServerIdMessagePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/servers/{server_id}/message',
    ...options
});

/**
 * Server Get Tools
 *
 * List tools for the server  with an option to include inactive tools.
 *
 * This endpoint retrieves a list of tools from the database, optionally including
 * those that are inactive. The inactive filter helps administrators manage tools
 * that have been deactivated but not deleted from the system.
 *
 * Args:
 * server_id (str): ID of the server
 * include_inactive (bool): Whether to include inactive tools in the results.
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * List[ToolRead]: A list of tool records formatted with by_alias=True.
 */
export const serverGetToolsServersServerIdToolsGet = <ThrowOnError extends boolean = false>(options: Options<ServerGetToolsServersServerIdToolsGetData, ThrowOnError>) => (options.client ?? client).get<ServerGetToolsServersServerIdToolsGetResponses, ServerGetToolsServersServerIdToolsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/servers/{server_id}/tools',
    ...options
});

/**
 * Server Get Resources
 *
 * List resources for the server with an option to include inactive resources.
 *
 * This endpoint retrieves a list of resources from the database, optionally including
 * those that are inactive. The inactive filter is useful for administrators who need
 * to view or manage resources that have been deactivated but not deleted.
 *
 * Args:
 * server_id (str): ID of the server
 * include_inactive (bool): Whether to include inactive resources in the results.
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * List[ResourceRead]: A list of resource records formatted with by_alias=True.
 */
export const serverGetResourcesServersServerIdResourcesGet = <ThrowOnError extends boolean = false>(options: Options<ServerGetResourcesServersServerIdResourcesGetData, ThrowOnError>) => (options.client ?? client).get<ServerGetResourcesServersServerIdResourcesGetResponses, ServerGetResourcesServersServerIdResourcesGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/servers/{server_id}/resources',
    ...options
});

/**
 * Server Get Prompts
 *
 * List prompts for the server with an option to include inactive prompts.
 *
 * This endpoint retrieves a list of prompts from the database, optionally including
 * those that are inactive. The inactive filter helps administrators see and manage
 * prompts that have been deactivated but not deleted from the system.
 *
 * Args:
 * server_id (str): ID of the server
 * include_inactive (bool): Whether to include inactive prompts in the results.
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * List[PromptRead]: A list of prompt records formatted with by_alias=True.
 */
export const serverGetPromptsServersServerIdPromptsGet = <ThrowOnError extends boolean = false>(options: Options<ServerGetPromptsServersServerIdPromptsGetData, ThrowOnError>) => (options.client ?? client).get<ServerGetPromptsServersServerIdPromptsGetResponses, ServerGetPromptsServersServerIdPromptsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/servers/{server_id}/prompts',
    ...options
});

/**
 * Get Metrics
 *
 * Retrieve aggregated metrics for all entity types (Tools, Resources, Servers, Prompts, A2A Agents).
 *
 * Args:
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * A dictionary with keys for each entity type and their aggregated metrics.
 */
export const getMetricsMetricsGet = <ThrowOnError extends boolean = false>(options?: Options<GetMetricsMetricsGetData, ThrowOnError>) => (options?.client ?? client).get<GetMetricsMetricsGetResponses, GetMetricsMetricsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/metrics',
    ...options
});

/**
 * Reset Metrics
 *
 * Reset metrics for a specific entity type and optionally a specific entity ID,
 * or perform a global reset if no entity is specified.
 *
 * Args:
 * entity: One of "tool", "resource", "server", "prompt", "a2a_agent", or None for global reset.
 * entity_id: Specific entity ID to reset metrics for (optional).
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * A success message in a dictionary.
 *
 * Raises:
 * HTTPException: If an invalid entity type is specified.
 */
export const resetMetricsMetricsResetPost = <ThrowOnError extends boolean = false>(options?: Options<ResetMetricsMetricsResetPostData, ThrowOnError>) => (options?.client ?? client).post<ResetMetricsMetricsResetPostResponses, ResetMetricsMetricsResetPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/metrics/reset',
    ...options
});

/**
 * List Tags
 *
 * Retrieve all unique tags across specified entity types.
 *
 * Args:
 * entity_types: Comma-separated list of entity types to filter by
 * (e.g., "tools,resources,prompts,servers,gateways").
 * If not provided, returns tags from all entity types.
 * include_entities: Whether to include the list of entities that have each tag
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * List of TagInfo objects containing tag names, statistics, and optionally entities
 *
 * Raises:
 * HTTPException: If tag retrieval fails
 */
export const listTagsTagsGet = <ThrowOnError extends boolean = false>(options?: Options<ListTagsTagsGetData, ThrowOnError>) => (options?.client ?? client).get<ListTagsTagsGetResponses, ListTagsTagsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tags/',
    ...options
});

/**
 * List Tags
 *
 * Retrieve all unique tags across specified entity types.
 *
 * Args:
 * entity_types: Comma-separated list of entity types to filter by
 * (e.g., "tools,resources,prompts,servers,gateways").
 * If not provided, returns tags from all entity types.
 * include_entities: Whether to include the list of entities that have each tag
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * List of TagInfo objects containing tag names, statistics, and optionally entities
 *
 * Raises:
 * HTTPException: If tag retrieval fails
 */
export const listTagsTagsGet2 = <ThrowOnError extends boolean = false>(options?: Options<ListTagsTagsGet2Data, ThrowOnError>) => (options?.client ?? client).get<ListTagsTagsGet2Responses, ListTagsTagsGet2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tags',
    ...options
});

/**
 * Get Entities By Tag
 *
 * Get all entities that have a specific tag.
 *
 * Args:
 * tag_name: The tag to search for
 * entity_types: Comma-separated list of entity types to filter by
 * (e.g., "tools,resources,prompts,servers,gateways").
 * If not provided, returns entities from all types.
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * List of TaggedEntity objects
 *
 * Raises:
 * HTTPException: If entity retrieval fails
 */
export const getEntitiesByTagTagsTagNameEntitiesGet = <ThrowOnError extends boolean = false>(options: Options<GetEntitiesByTagTagsTagNameEntitiesGetData, ThrowOnError>) => (options.client ?? client).get<GetEntitiesByTagTagsTagNameEntitiesGetResponses, GetEntitiesByTagTagsTagNameEntitiesGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tags/{tag_name}/entities',
    ...options
});

/**
 * Export Configuration
 *
 * Export gateway configuration to JSON format.
 *
 * Args:
 * request: FastAPI request object for extracting root path
 * export_format: Export format (currently only 'json' supported)
 * types: Comma-separated list of entity types to include (tools,gateways,servers,prompts,resources,roots)
 * exclude_types: Comma-separated list of entity types to exclude
 * tags: Comma-separated list of tags to filter by
 * include_inactive: Whether to include inactive entities
 * include_dependencies: Whether to include dependent entities
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * Export data in the specified format
 *
 * Raises:
 * HTTPException: If export fails
 */
export const exportConfigurationExportGet = <ThrowOnError extends boolean = false>(options?: Options<ExportConfigurationExportGetData, ThrowOnError>) => (options?.client ?? client).get<ExportConfigurationExportGetResponses, ExportConfigurationExportGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/export',
    ...options
});

/**
 * Export Selective Configuration
 *
 * Export specific entities by their IDs/names.
 *
 * Args:
 * entity_selections: Dict mapping entity types to lists of IDs/names to export
 * include_dependencies: Whether to include dependent entities
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * Selective export data
 *
 * Raises:
 * HTTPException: If export fails
 *
 * Example request body:
 * {
 * "tools": ["tool1", "tool2"],
 * "servers": ["server1"],
 * "prompts": ["prompt1"]
 * }
 */
export const exportSelectiveConfigurationExportSelectivePost = <ThrowOnError extends boolean = false>(options: Options<ExportSelectiveConfigurationExportSelectivePostData, ThrowOnError>) => (options.client ?? client).post<ExportSelectiveConfigurationExportSelectivePostResponses, ExportSelectiveConfigurationExportSelectivePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/export/selective',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Import Configuration
 *
 * Import configuration data with conflict resolution.
 *
 * Args:
 * import_data: The configuration data to import
 * conflict_strategy: How to handle conflicts: skip, update, rename, fail
 * dry_run: If true, validate but don't make changes
 * rekey_secret: New encryption secret for cross-environment imports
 * selected_entities: Dict of entity types to specific entity names/ids to import
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * Import status and results
 *
 * Raises:
 * HTTPException: If import fails or validation errors occur
 */
export const importConfigurationImportPost = <ThrowOnError extends boolean = false>(options: Options<ImportConfigurationImportPostData, ThrowOnError>) => (options.client ?? client).post<ImportConfigurationImportPostResponses, ImportConfigurationImportPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/import',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get Import Status
 *
 * Get the status of an import operation.
 *
 * Args:
 * import_id: The import operation ID
 * user: Authenticated user
 *
 * Returns:
 * Import status information
 *
 * Raises:
 * HTTPException: If import not found
 */
export const getImportStatusImportStatusImportIdGet = <ThrowOnError extends boolean = false>(options: Options<GetImportStatusImportStatusImportIdGetData, ThrowOnError>) => (options.client ?? client).get<GetImportStatusImportStatusImportIdGetResponses, GetImportStatusImportStatusImportIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/import/status/{import_id}',
    ...options
});

/**
 * List Import Statuses
 *
 * List all import operation statuses.
 *
 * Args:
 * user: Authenticated user
 *
 * Returns:
 * List of import status information
 */
export const listImportStatusesImportStatusGet = <ThrowOnError extends boolean = false>(options?: Options<ListImportStatusesImportStatusGetData, ThrowOnError>) => (options?.client ?? client).get<ListImportStatusesImportStatusGetResponses, ListImportStatusesImportStatusGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/import/status',
    ...options
});

/**
 * Cleanup Import Statuses
 *
 * Clean up completed import statuses older than specified age.
 *
 * Args:
 * max_age_hours: Maximum age in hours for keeping completed imports
 * user: Authenticated user
 *
 * Returns:
 * Cleanup results
 */
export const cleanupImportStatusesImportCleanupPost = <ThrowOnError extends boolean = false>(options?: Options<CleanupImportStatusesImportCleanupPostData, ThrowOnError>) => (options?.client ?? client).post<CleanupImportStatusesImportCleanupPostResponses, CleanupImportStatusesImportCleanupPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/import/cleanup',
    ...options
});

/**
 * List Traces
 *
 * List traces with optional filtering.
 *
 * Query traces with various filters including time range, duration, status, HTTP method,
 * HTTP status code, user email, and attribute search. Results are paginated.
 *
 * Note: For structured attribute filtering (key-value pairs with AND logic),
 * use a JSON request body via POST endpoint or the Python SDK.
 *
 * Args:
 * start_time: Filter traces after this time
 * end_time: Filter traces before this time
 * min_duration_ms: Minimum duration in milliseconds
 * max_duration_ms: Maximum duration in milliseconds
 * status: Filter by status (ok, error)
 * http_status_code: Filter by HTTP status code
 * http_method: Filter by HTTP method (GET, POST, etc.)
 * user_email: Filter by user email
 * attribute_search: Free-text search across all trace attributes
 * limit: Maximum results
 * offset: Result offset
 * db: Database session
 *
 * Returns:
 * List[ObservabilityTraceRead]: List of traces matching filters
 *
 * Examples:
 * >>> import mcpgateway.routers.observability as obs
 * >>> class FakeTrace:
 * ...     def __init__(self, trace_id='t1'):
 * ...         self.trace_id = trace_id
 * ...         self.name = 'n'
 * ...         self.start_time = None
 * ...         self.end_time = None
 * ...         self.duration_ms = 100
 * ...         self.status = 'ok'
 * ...         self.http_method = 'GET'
 * ...         self.http_url = '/'
 * ...         self.http_status_code = 200
 * ...         self.user_email = 'u'
 * >>> class FakeService:
 * ...     def query_traces(self, **kwargs):
 * ...         return [FakeTrace('t1')]
 * >>> obs.ObservabilityService = FakeService
 * >>> obs.list_traces(db=None)[0].trace_id
 * 't1'
 */
export const listTracesObservabilityTracesGet = <ThrowOnError extends boolean = false>(options?: Options<ListTracesObservabilityTracesGetData, ThrowOnError>) => (options?.client ?? client).get<ListTracesObservabilityTracesGetResponses, ListTracesObservabilityTracesGetErrors, ThrowOnError>({ url: '/observability/traces', ...options });

/**
 * Query Traces Advanced
 *
 * Advanced trace querying with attribute filtering.
 *
 * POST endpoint that accepts a JSON body with complex filtering criteria,
 * including structured attribute filters with AND logic.
 *
 * Request Body:
 * {
 * "start_time": "2025-01-01T00:00:00Z",  # Optional datetime
 * "end_time": "2025-01-02T00:00:00Z",    # Optional datetime
 * "min_duration_ms": 100.0,               # Optional float
 * "max_duration_ms": 5000.0,              # Optional float
 * "status": "error",                      # Optional string
 * "http_status_code": 500,                # Optional int
 * "http_method": "POST",                  # Optional string
 * "user_email": "user@example.com",       # Optional string
 * "attribute_filters": {                  # Optional dict (AND logic)
 * "http.route": "/api/tools",
 * "service.name": "mcp-gateway"
 * },
 * "attribute_search": "error",            # Optional string (OR logic)
 * "limit": 100,                           # Optional int
 * "offset": 0                             # Optional int
 * }
 *
 * Args:
 * request_body: JSON request body with filter criteria
 * db: Database session
 *
 * Returns:
 * List[ObservabilityTraceRead]: List of traces matching filters
 *
 * Raises:
 * HTTPException: 400 error if request body is invalid
 *
 * Examples:
 * >>> from fastapi import HTTPException
 * >>> try:
 * ...     query_traces_advanced({"start_time": "not-a-date"}, db=None)
 * ... except HTTPException as e:
 * ...     (e.status_code, "Invalid request body" in str(e.detail))
 * (400, True)
 *
 * >>> import mcpgateway.routers.observability as obs
 * >>> class FakeTrace:
 * ...     def __init__(self):
 * ...         self.trace_id = 'tx'
 * ...         self.name = 'n'
 *
 * >>> class FakeService2:
 * ...     def query_traces(self, **kwargs):
 * ...         return [FakeTrace()]
 * >>> obs.ObservabilityService = FakeService2
 * >>> obs.query_traces_advanced({}, db=None)[0].trace_id
 * 'tx'
 */
export const queryTracesAdvancedObservabilityTracesQueryPost = <ThrowOnError extends boolean = false>(options: Options<QueryTracesAdvancedObservabilityTracesQueryPostData, ThrowOnError>) => (options.client ?? client).post<QueryTracesAdvancedObservabilityTracesQueryPostResponses, QueryTracesAdvancedObservabilityTracesQueryPostErrors, ThrowOnError>({
    url: '/observability/traces/query',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get Trace
 *
 * Get a trace by ID with all its spans and events.
 *
 * Returns a complete trace with all nested spans and their events,
 * providing a full view of the request flow.
 *
 * Args:
 * trace_id: UUID of the trace to retrieve
 * db: Database session
 *
 * Returns:
 * ObservabilityTraceWithSpans: Complete trace with all spans and events
 *
 * Raises:
 * HTTPException: 404 if trace not found
 *
 * Examples:
 * >>> import mcpgateway.routers.observability as obs
 * >>> class FakeService:
 * ...     def get_trace_with_spans(self, db, trace_id):
 * ...         return None
 * >>> obs.ObservabilityService = FakeService
 * >>> try:
 * ...     obs.get_trace('missing', db=None)
 * ... except obs.HTTPException as e:
 * ...     e.status_code
 * 404
 * >>> class FakeService2:
 * ...     def get_trace_with_spans(self, db, trace_id):
 * ...         return {'trace_id': trace_id}
 * >>> obs.ObservabilityService = FakeService2
 * >>> obs.get_trace('found', db=None)['trace_id']
 * 'found'
 */
export const getTraceObservabilityTracesTraceIdGet = <ThrowOnError extends boolean = false>(options: Options<GetTraceObservabilityTracesTraceIdGetData, ThrowOnError>) => (options.client ?? client).get<GetTraceObservabilityTracesTraceIdGetResponses, GetTraceObservabilityTracesTraceIdGetErrors, ThrowOnError>({ url: '/observability/traces/{trace_id}', ...options });

/**
 * List Spans
 *
 * List spans with optional filtering.
 *
 * Query spans by trace ID, resource type, resource name, or time range.
 * Useful for analyzing specific operations or resource performance.
 *
 * Args:
 * trace_id: Filter by trace ID
 * resource_type: Filter by resource type
 * resource_name: Filter by resource name
 * start_time: Filter spans after this time
 * end_time: Filter spans before this time
 * limit: Maximum results
 * offset: Result offset
 * db: Database session
 *
 * Returns:
 * List[ObservabilitySpanRead]: List of spans matching filters
 *
 * Examples:
 * >>> import mcpgateway.routers.observability as obs
 * >>> class FakeSpan:
 * ...     def __init__(self):
 * ...         self.span_id = 's1'
 * ...         self.trace_id = 't1'
 * ...         self.name = 'op'
 * >>> class FakeService:
 * ...     def query_spans(self, **kwargs):
 * ...         return [FakeSpan()]
 * >>> obs.ObservabilityService = FakeService
 * >>> obs.list_spans(db=None)[0].span_id
 * 's1'
 */
export const listSpansObservabilitySpansGet = <ThrowOnError extends boolean = false>(options?: Options<ListSpansObservabilitySpansGetData, ThrowOnError>) => (options?.client ?? client).get<ListSpansObservabilitySpansGetResponses, ListSpansObservabilitySpansGetErrors, ThrowOnError>({ url: '/observability/spans', ...options });

/**
 * Cleanup Old Traces
 *
 * Delete traces older than a specified number of days.
 *
 * Cleans up old trace data to manage storage. Cascading deletes will
 * also remove associated spans, events, and metrics.
 *
 * Args:
 * days: Delete traces older than this many days
 * db: Database session
 *
 * Returns:
 * dict: Number of deleted traces and cutoff time
 *
 * Examples:
 * >>> import mcpgateway.routers.observability as obs
 * >>> class FakeService:
 * ...     def delete_old_traces(self, db, cutoff):
 * ...         return 5
 * >>> obs.ObservabilityService = FakeService
 * >>> res = obs.cleanup_old_traces(days=7, db=None)
 * >>> res['deleted']
 * 5
 */
export const cleanupOldTracesObservabilityTracesCleanupDelete = <ThrowOnError extends boolean = false>(options?: Options<CleanupOldTracesObservabilityTracesCleanupDeleteData, ThrowOnError>) => (options?.client ?? client).delete<CleanupOldTracesObservabilityTracesCleanupDeleteResponses, CleanupOldTracesObservabilityTracesCleanupDeleteErrors, ThrowOnError>({ url: '/observability/traces/cleanup', ...options });

/**
 * Get Stats
 *
 * Get observability statistics.
 *
 * Returns summary statistics including:
 * - Total traces in time window
 * - Success/error counts
 * - Average response time
 * - Top slowest endpoints
 *
 * Args:
 * hours: Time window in hours
 * db: Database session
 *
 * Returns:
 * dict: Statistics including counts, error rate, and slowest endpoints
 */
export const getStatsObservabilityStatsGet = <ThrowOnError extends boolean = false>(options?: Options<GetStatsObservabilityStatsGetData, ThrowOnError>) => (options?.client ?? client).get<GetStatsObservabilityStatsGetResponses, GetStatsObservabilityStatsGetErrors, ThrowOnError>({ url: '/observability/stats', ...options });

/**
 * Export Traces
 *
 * Export traces in various formats.
 *
 * POST endpoint that accepts filter criteria (same as /traces/query) and exports
 * matching traces in the specified format.
 *
 * Supported formats:
 * - json: Standard JSON array
 * - csv: Comma-separated values
 * - ndjson: Newline-delimited JSON (streaming)
 *
 * Args:
 * request_body: JSON request body with filter criteria (same as /traces/query)
 * format: Export format (json, csv, ndjson)
 * db: Database session
 *
 * Returns:
 * StreamingResponse or JSONResponse with exported data
 *
 * Raises:
 * HTTPException: 400 error if format is invalid or export fails
 *
 * Examples:
 * >>> from fastapi import HTTPException
 * >>> try:
 * ...     export_traces({}, format="xml", db=None)
 * ... except HTTPException as e:
 * ...     (e.status_code, "format must be one of" in str(e.detail))
 * (400, True)
 * >>> import mcpgateway.routers.observability as obs
 * >>> from datetime import datetime
 * >>> class FakeTrace:
 * ...     def __init__(self):
 * ...         self.trace_id = 'tx'
 * ...         self.name = 'name'
 * ...         self.start_time = datetime(2025,1,1)
 * ...         self.end_time = None
 * ...         self.duration_ms = 100
 * ...         self.status = 'ok'
 * ...         self.http_method = 'GET'
 * ...         self.http_url = '/'
 * ...         self.http_status_code = 200
 * ...         self.user_email = 'u'
 * >>> class FakeService:
 * ...     def query_traces(self, **kwargs):
 * ...         return [FakeTrace()]
 * >>> obs.ObservabilityService = FakeService
 * >>> out = obs.export_traces({}, format='json', db=None)
 * >>> out[0]['trace_id']
 * 'tx'
 * >>> resp = obs.export_traces({}, format='csv', db=None)
 * >>> hasattr(resp, 'media_type') and 'csv' in resp.media_type
 * True
 * >>> resp2 = obs.export_traces({}, format='ndjson', db=None)
 * >>> type(resp2).__name__
 * 'StreamingResponse'
 */
export const exportTracesObservabilityTracesExportPost = <ThrowOnError extends boolean = false>(options: Options<ExportTracesObservabilityTracesExportPostData, ThrowOnError>) => (options.client ?? client).post<ExportTracesObservabilityTracesExportPostResponses, ExportTracesObservabilityTracesExportPostErrors, ThrowOnError>({
    url: '/observability/traces/export',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get Query Performance
 *
 * Get query performance analytics.
 *
 * Returns performance metrics about trace queries including:
 * - Average, min, max, p50, p95, p99 durations
 * - Query volume over time
 * - Error rate trends
 *
 * Args:
 * hours: Time window in hours
 * db: Database session
 *
 * Returns:
 * dict: Performance analytics
 *
 * Examples:
 * >>> import mcpgateway.routers.observability as obs
 * >>> class EmptyDB:
 * ...     def query(self, *a, **k):
 * ...         return self
 * ...     def filter(self, *a, **k):
 * ...         return self
 * ...     def all(self):
 * ...         return []
 * >>> obs.get_query_performance(hours=1, db=EmptyDB())['total_traces']
 * 0
 *
 * >>> class SmallDB:
 * ...     def query(self, *a, **k):
 * ...         return self
 * ...     def filter(self, *a, **k):
 * ...         return self
 * ...     def all(self):
 * ...         return [(10,), (20,), (30,), (40,)]
 * >>> res = obs.get_query_performance(hours=1, db=SmallDB())
 * >>> res['total_traces']
 * 4
 */
export const getQueryPerformanceObservabilityAnalyticsQueryPerformanceGet = <ThrowOnError extends boolean = false>(options?: Options<GetQueryPerformanceObservabilityAnalyticsQueryPerformanceGetData, ThrowOnError>) => (options?.client ?? client).get<GetQueryPerformanceObservabilityAnalyticsQueryPerformanceGetResponses, GetQueryPerformanceObservabilityAnalyticsQueryPerformanceGetErrors, ThrowOnError>({ url: '/observability/analytics/query-performance', ...options });

/**
 * List A2A Agents
 *
 * Lists A2A agents user has access to with team filtering.
 *
 * Args:
 * include_inactive (bool): Whether to include inactive agents in the response.
 * tags (Optional[str]): Comma-separated list of tags to filter by.
 * team_id (Optional[str]): Team ID to filter by.
 * visibility (Optional[str]): Visibility level to filter by.
 * skip (int): Number of agents to skip for pagination.
 * limit (int): Maximum number of agents to return.
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * List[A2AAgentRead]: A list of A2A agent objects the user has access to.
 *
 * Raises:
 * HTTPException: If A2A service is not available.
 */
export const listA2aAgentsA2aGet = <ThrowOnError extends boolean = false>(options?: Options<ListA2aAgentsA2aGetData, ThrowOnError>) => (options?.client ?? client).get<ListA2aAgentsA2aGetResponses, ListA2aAgentsA2aGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/a2a/',
    ...options
});

/**
 * Create A2A Agent
 *
 * Creates a new A2A agent.
 *
 * Args:
 * agent (A2AAgentCreate): The data for the new agent.
 * request (Request): The FastAPI request object for metadata extraction.
 * team_id (Optional[str]): Team ID to assign the agent to.
 * visibility (str): Agent visibility level (private, team, public).
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * A2AAgentRead: The created agent object.
 *
 * Raises:
 * HTTPException: If there is a conflict with the agent name or other errors.
 */
export const createA2aAgentA2aPost = <ThrowOnError extends boolean = false>(options: Options<CreateA2aAgentA2aPostData, ThrowOnError>) => (options.client ?? client).post<CreateA2aAgentA2aPostResponses, CreateA2aAgentA2aPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/a2a/',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List A2A Agents
 *
 * Lists A2A agents user has access to with team filtering.
 *
 * Args:
 * include_inactive (bool): Whether to include inactive agents in the response.
 * tags (Optional[str]): Comma-separated list of tags to filter by.
 * team_id (Optional[str]): Team ID to filter by.
 * visibility (Optional[str]): Visibility level to filter by.
 * skip (int): Number of agents to skip for pagination.
 * limit (int): Maximum number of agents to return.
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * List[A2AAgentRead]: A list of A2A agent objects the user has access to.
 *
 * Raises:
 * HTTPException: If A2A service is not available.
 */
export const listA2aAgentsA2aGet2 = <ThrowOnError extends boolean = false>(options?: Options<ListA2aAgentsA2aGet2Data, ThrowOnError>) => (options?.client ?? client).get<ListA2aAgentsA2aGet2Responses, ListA2aAgentsA2aGet2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/a2a',
    ...options
});

/**
 * Create A2A Agent
 *
 * Creates a new A2A agent.
 *
 * Args:
 * agent (A2AAgentCreate): The data for the new agent.
 * request (Request): The FastAPI request object for metadata extraction.
 * team_id (Optional[str]): Team ID to assign the agent to.
 * visibility (str): Agent visibility level (private, team, public).
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * A2AAgentRead: The created agent object.
 *
 * Raises:
 * HTTPException: If there is a conflict with the agent name or other errors.
 */
export const createA2aAgentA2aPost2 = <ThrowOnError extends boolean = false>(options: Options<CreateA2aAgentA2aPost2Data, ThrowOnError>) => (options.client ?? client).post<CreateA2aAgentA2aPost2Responses, CreateA2aAgentA2aPost2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/a2a',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete A2A Agent
 *
 * Deletes an A2A agent by its ID.
 *
 * Args:
 * agent_id (str): The ID of the agent to delete.
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * Dict[str, str]: A success message indicating the agent was deleted.
 *
 * Raises:
 * HTTPException: If the agent is not found or there is an error.
 */
export const deleteA2aAgentA2aAgentIdDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteA2aAgentA2aAgentIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<DeleteA2aAgentA2aAgentIdDeleteResponses, DeleteA2aAgentA2aAgentIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/a2a/{agent_id}',
    ...options
});

/**
 * Get A2A Agent
 *
 * Retrieves an A2A agent by its ID.
 *
 * Args:
 * agent_id (str): The ID of the agent to retrieve.
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * A2AAgentRead: The agent object with the specified ID.
 *
 * Raises:
 * HTTPException: If the agent is not found.
 */
export const getA2aAgentA2aAgentIdGet = <ThrowOnError extends boolean = false>(options: Options<GetA2aAgentA2aAgentIdGetData, ThrowOnError>) => (options.client ?? client).get<GetA2aAgentA2aAgentIdGetResponses, GetA2aAgentA2aAgentIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/a2a/{agent_id}',
    ...options
});

/**
 * Update A2A Agent
 *
 * Updates the information of an existing A2A agent.
 *
 * Args:
 * agent_id (str): The ID of the agent to update.
 * agent (A2AAgentUpdate): The updated agent data.
 * request (Request): The FastAPI request object for metadata extraction.
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * A2AAgentRead: The updated agent object.
 *
 * Raises:
 * HTTPException: If the agent is not found, there is a name conflict, or other errors.
 */
export const updateA2aAgentA2aAgentIdPut = <ThrowOnError extends boolean = false>(options: Options<UpdateA2aAgentA2aAgentIdPutData, ThrowOnError>) => (options.client ?? client).put<UpdateA2aAgentA2aAgentIdPutResponses, UpdateA2aAgentA2aAgentIdPutErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/a2a/{agent_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Toggle A2A Agent Status
 *
 * Toggles the status of an A2A agent (activate or deactivate).
 *
 * Args:
 * agent_id (str): The ID of the agent to toggle.
 * activate (bool): Whether to activate or deactivate the agent.
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * A2AAgentRead: The agent object after the status change.
 *
 * Raises:
 * HTTPException: If the agent is not found or there is an error.
 */
export const toggleA2aAgentStatusA2aAgentIdTogglePost = <ThrowOnError extends boolean = false>(options: Options<ToggleA2aAgentStatusA2aAgentIdTogglePostData, ThrowOnError>) => (options.client ?? client).post<ToggleA2aAgentStatusA2aAgentIdTogglePostResponses, ToggleA2aAgentStatusA2aAgentIdTogglePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/a2a/{agent_id}/toggle',
    ...options
});

/**
 * Invoke A2A Agent
 *
 * Invokes an A2A agent with the specified parameters.
 *
 * Args:
 * agent_name (str): The name of the agent to invoke.
 * parameters (Dict[str, Any]): Parameters for the agent interaction.
 * interaction_type (str): Type of interaction (query, execute, etc.).
 * db (Session): The database session used to interact with the data store.
 * user (str): The authenticated user making the request.
 *
 * Returns:
 * Dict[str, Any]: The response from the A2A agent.
 *
 * Raises:
 * HTTPException: If the agent is not found or there is an error during invocation.
 */
export const invokeA2aAgentA2aAgentNameInvokePost = <ThrowOnError extends boolean = false>(options: Options<InvokeA2aAgentA2aAgentNameInvokePostData, ThrowOnError>) => (options.client ?? client).post<InvokeA2aAgentA2aAgentNameInvokePostResponses, InvokeA2aAgentA2aAgentNameInvokePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/a2a/{agent_name}/invoke',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get Well Known Status
 *
 * Get status of well-known URI configuration.
 *
 * Args:
 * user: Authenticated user from dependency injection.
 *
 * Returns:
 * Dict containing well-known configuration status and available files.
 */
export const getWellKnownStatusAdminWellKnownGet = <ThrowOnError extends boolean = false>(options?: Options<GetWellKnownStatusAdminWellKnownGetData, ThrowOnError>) => (options?.client ?? client).get<GetWellKnownStatusAdminWellKnownGetResponses, GetWellKnownStatusAdminWellKnownGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/well-known',
    ...options
});

/**
 * Login
 *
 * Authenticate user with email and password.
 *
 * Args:
 * login_request: Login credentials
 * request: FastAPI request object
 * db: Database session
 *
 * Returns:
 * AuthenticationResponse: Access token and user info
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(login)
 * True
 *
 * Raises:
 * HTTPException: If authentication fails
 *
 * Examples:
 * Request JSON:
 * {
 * "email": "user@example.com",
 * "password": "secure_password"
 * }
 */
export const loginAuthEmailLoginPost = <ThrowOnError extends boolean = false>(options: Options<LoginAuthEmailLoginPostData, ThrowOnError>) => (options.client ?? client).post<LoginAuthEmailLoginPostResponses, LoginAuthEmailLoginPostErrors, ThrowOnError>({
    url: '/auth/email/login',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Register
 *
 * Register a new user account.
 *
 * Args:
 * registration_request: Registration information
 * request: FastAPI request object
 * db: Database session
 *
 * Returns:
 * AuthenticationResponse: Access token and user info
 *
 * Raises:
 * HTTPException: If registration fails
 *
 * Examples:
 * Request JSON:
 * {
 * "email": "new@example.com",
 * "password": "secure_password",
 * "full_name": "New User"
 * }
 */
export const registerAuthEmailRegisterPost = <ThrowOnError extends boolean = false>(options: Options<RegisterAuthEmailRegisterPostData, ThrowOnError>) => (options.client ?? client).post<RegisterAuthEmailRegisterPostResponses, RegisterAuthEmailRegisterPostErrors, ThrowOnError>({
    url: '/auth/email/register',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Change Password
 *
 * Change user's password.
 *
 * Args:
 * password_request: Old and new passwords
 * request: FastAPI request object
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * SuccessResponse: Success confirmation
 *
 * Raises:
 * HTTPException: If password change fails
 *
 * Examples:
 * Request JSON (with Bearer token in Authorization header):
 * {
 * "old_password": "current_password",
 * "new_password": "new_secure_password"
 * }
 */
export const changePasswordAuthEmailChangePasswordPost = <ThrowOnError extends boolean = false>(options: Options<ChangePasswordAuthEmailChangePasswordPostData, ThrowOnError>) => (options.client ?? client).post<ChangePasswordAuthEmailChangePasswordPostResponses, ChangePasswordAuthEmailChangePasswordPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/email/change-password',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get Current User Profile
 *
 * Get current user's profile information.
 *
 * Args:
 * current_user: Currently authenticated user
 *
 * Returns:
 * EmailUserResponse: User profile information
 *
 * Raises:
 * HTTPException: If user authentication fails
 *
 * Examples:
 * >>> # GET /auth/email/me
 * >>> # Headers: Authorization: Bearer <token>
 */
export const getCurrentUserProfileAuthEmailMeGet = <ThrowOnError extends boolean = false>(options?: Options<GetCurrentUserProfileAuthEmailMeGetData, ThrowOnError>) => (options?.client ?? client).get<GetCurrentUserProfileAuthEmailMeGetResponses, GetCurrentUserProfileAuthEmailMeGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/email/me',
    ...options
});

/**
 * Get Auth Events
 *
 * Get authentication events for the current user.
 *
 * Args:
 * limit: Maximum number of events to return
 * offset: Number of events to skip
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * List[AuthEventResponse]: Authentication events
 *
 * Raises:
 * HTTPException: If user authentication fails
 *
 * Examples:
 * >>> # GET /auth/email/events?limit=10&offset=0
 * >>> # Headers: Authorization: Bearer <token>
 */
export const getAuthEventsAuthEmailEventsGet = <ThrowOnError extends boolean = false>(options?: Options<GetAuthEventsAuthEmailEventsGetData, ThrowOnError>) => (options?.client ?? client).get<GetAuthEventsAuthEmailEventsGetResponses, GetAuthEventsAuthEmailEventsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/email/events',
    ...options
});

/**
 * List Users
 *
 * List all users (admin only).
 *
 * Args:
 * limit: Maximum number of users to return
 * offset: Number of users to skip
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * UserListResponse: List of users with pagination
 *
 * Raises:
 * HTTPException: If user is not admin
 *
 * Examples:
 * >>> # GET /auth/email/admin/users?limit=10&offset=0
 * >>> # Headers: Authorization: Bearer <admin_token>
 */
export const listUsersAuthEmailAdminUsersGet = <ThrowOnError extends boolean = false>(options?: Options<ListUsersAuthEmailAdminUsersGetData, ThrowOnError>) => (options?.client ?? client).get<ListUsersAuthEmailAdminUsersGetResponses, ListUsersAuthEmailAdminUsersGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/email/admin/users',
    ...options
});

/**
 * Create User
 *
 * Create a new user account (admin only).
 *
 * Args:
 * user_request: User creation information
 * current_user: Currently authenticated admin user
 * db: Database session
 *
 * Returns:
 * EmailUserResponse: Created user information
 *
 * Raises:
 * HTTPException: If user creation fails
 *
 * Examples:
 * Request JSON:
 * {
 * "email": "newuser@example.com",
 * "password": "secure_password",
 * "full_name": "New User",
 * "is_admin": false
 * }
 */
export const createUserAuthEmailAdminUsersPost = <ThrowOnError extends boolean = false>(options: Options<CreateUserAuthEmailAdminUsersPostData, ThrowOnError>) => (options.client ?? client).post<CreateUserAuthEmailAdminUsersPostResponses, CreateUserAuthEmailAdminUsersPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/email/admin/users',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List All Auth Events
 *
 * List authentication events for all users (admin only).
 *
 * Args:
 * limit: Maximum number of events to return
 * offset: Number of events to skip
 * user_email: Filter events by specific user email
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * List[AuthEventResponse]: Authentication events
 *
 * Raises:
 * HTTPException: If user is not admin
 *
 * Examples:
 * >>> # GET /auth/email/admin/events?limit=50&user_email=user@example.com
 * >>> # Headers: Authorization: Bearer <admin_token>
 */
export const listAllAuthEventsAuthEmailAdminEventsGet = <ThrowOnError extends boolean = false>(options?: Options<ListAllAuthEventsAuthEmailAdminEventsGetData, ThrowOnError>) => (options?.client ?? client).get<ListAllAuthEventsAuthEmailAdminEventsGetResponses, ListAllAuthEventsAuthEmailAdminEventsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/email/admin/events',
    ...options
});

/**
 * Delete User
 *
 * Delete/deactivate user (admin only).
 *
 * Args:
 * user_email: Email of user to delete
 * current_user: Currently authenticated admin user
 * db: Database session
 *
 * Returns:
 * SuccessResponse: Success confirmation
 *
 * Raises:
 * HTTPException: If user not found or deletion fails
 */
export const deleteUserAuthEmailAdminUsersUserEmailDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteUserAuthEmailAdminUsersUserEmailDeleteData, ThrowOnError>) => (options.client ?? client).delete<DeleteUserAuthEmailAdminUsersUserEmailDeleteResponses, DeleteUserAuthEmailAdminUsersUserEmailDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/email/admin/users/{user_email}',
    ...options
});

/**
 * Get User
 *
 * Get user by email (admin only).
 *
 * Args:
 * user_email: Email of user to retrieve
 * current_user: Currently authenticated admin user
 * db: Database session
 *
 * Returns:
 * EmailUserResponse: User information
 *
 * Raises:
 * HTTPException: If user not found
 */
export const getUserAuthEmailAdminUsersUserEmailGet = <ThrowOnError extends boolean = false>(options: Options<GetUserAuthEmailAdminUsersUserEmailGetData, ThrowOnError>) => (options.client ?? client).get<GetUserAuthEmailAdminUsersUserEmailGetResponses, GetUserAuthEmailAdminUsersUserEmailGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/email/admin/users/{user_email}',
    ...options
});

/**
 * Update User
 *
 * Update user information (admin only).
 *
 * Args:
 * user_email: Email of user to update
 * user_request: Updated user information
 * current_user: Currently authenticated admin user
 * db: Database session
 *
 * Returns:
 * EmailUserResponse: Updated user information
 *
 * Raises:
 * HTTPException: If user not found or update fails
 */
export const updateUserAuthEmailAdminUsersUserEmailPut = <ThrowOnError extends boolean = false>(options: Options<UpdateUserAuthEmailAdminUsersUserEmailPutData, ThrowOnError>) => (options.client ?? client).put<UpdateUserAuthEmailAdminUsersUserEmailPutResponses, UpdateUserAuthEmailAdminUsersUserEmailPutErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/email/admin/users/{user_email}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Login
 *
 * Authenticate user and return session JWT token.
 *
 * This endpoint provides Tier 1 authentication for session-based access.
 * The returned JWT token should be used for UI access and API key management.
 *
 * Args:
 * login_request: Login credentials (email/username + password)
 * request: FastAPI request object
 * db: Database session
 *
 * Returns:
 * AuthenticationResponse: Session JWT token and user info
 *
 * Raises:
 * HTTPException: If authentication fails
 *
 * Examples:
 * Email format (recommended):
 * {
 * "email": "admin@example.com",
 * "password": "ChangeMe_12345678$"
 * }
 *
 * Username format (compatibility):
 * {
 * "username": "admin@example.com",
 * "password": "ChangeMe_12345678$"
 * }
 */
export const loginAuthLoginPost = <ThrowOnError extends boolean = false>(options: Options<LoginAuthLoginPostData, ThrowOnError>) => (options.client ?? client).post<LoginAuthLoginPostResponses, LoginAuthLoginPostErrors, ThrowOnError>({
    url: '/auth/login',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List Teams
 *
 * List teams visible to the caller.
 *
 * - Administrators see all non-personal teams (paginated)
 * - Regular users see only teams they are a member of (paginated client-side)
 *
 * Args:
 * skip: Number of teams to skip for pagination
 * limit: Maximum number of teams to return
 * current_user_ctx: Current user context with permissions and database session
 *
 * Returns:
 * TeamListResponse: List of teams and total count
 *
 * Raises:
 * HTTPException: If there's an error listing teams
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(list_teams)
 * True
 */
export const listTeamsTeamsGet = <ThrowOnError extends boolean = false>(options?: Options<ListTeamsTeamsGetData, ThrowOnError>) => (options?.client ?? client).get<ListTeamsTeamsGetResponses, ListTeamsTeamsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/',
    ...options
});

/**
 * Create Team
 *
 * Create a new team.
 *
 * Args:
 * request: Team creation request data
 * current_user_ctx: Currently authenticated user context
 *
 * Returns:
 * TeamResponse: Created team data
 *
 * Raises:
 * HTTPException: If team creation fails
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(create_team)
 * True
 */
export const createTeamTeamsPost = <ThrowOnError extends boolean = false>(options: Options<CreateTeamTeamsPostData, ThrowOnError>) => (options.client ?? client).post<CreateTeamTeamsPostResponses, CreateTeamTeamsPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete Team
 *
 * Delete a team.
 *
 * Args:
 * team_id: Team UUID
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * SuccessResponse: Success confirmation
 *
 * Raises:
 * HTTPException: If team not found, access denied, or deletion fails
 */
export const deleteTeamTeamsTeamIdDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteTeamTeamsTeamIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<DeleteTeamTeamsTeamIdDeleteResponses, DeleteTeamTeamsTeamIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/{team_id}',
    ...options
});

/**
 * Get Team
 *
 * Get a specific team by ID.
 *
 * Args:
 * team_id: Team UUID
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * TeamResponse: Team data
 *
 * Raises:
 * HTTPException: If team not found or access denied
 */
export const getTeamTeamsTeamIdGet = <ThrowOnError extends boolean = false>(options: Options<GetTeamTeamsTeamIdGetData, ThrowOnError>) => (options.client ?? client).get<GetTeamTeamsTeamIdGetResponses, GetTeamTeamsTeamIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/{team_id}',
    ...options
});

/**
 * Update Team
 *
 * Update a team.
 *
 * Args:
 * team_id: Team UUID
 * request: Team update request data
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * TeamResponse: Updated team data
 *
 * Raises:
 * HTTPException: If team not found, access denied, or update fails
 */
export const updateTeamTeamsTeamIdPut = <ThrowOnError extends boolean = false>(options: Options<UpdateTeamTeamsTeamIdPutData, ThrowOnError>) => (options.client ?? client).put<UpdateTeamTeamsTeamIdPutResponses, UpdateTeamTeamsTeamIdPutErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/{team_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List Team Members
 *
 * List team members.
 *
 * Args:
 * team_id: Team UUID
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * List[TeamMemberResponse]: List of team members
 *
 * Raises:
 * HTTPException: If team not found or access denied
 */
export const listTeamMembersTeamsTeamIdMembersGet = <ThrowOnError extends boolean = false>(options: Options<ListTeamMembersTeamsTeamIdMembersGetData, ThrowOnError>) => (options.client ?? client).get<ListTeamMembersTeamsTeamIdMembersGetResponses, ListTeamMembersTeamsTeamIdMembersGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/{team_id}/members',
    ...options
});

/**
 * Remove Team Member
 *
 * Remove a team member.
 *
 * Args:
 * team_id: Team UUID
 * user_email: Email of the member to remove
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * SuccessResponse: Success confirmation
 *
 * Raises:
 * HTTPException: If member not found, access denied, or removal fails
 */
export const removeTeamMemberTeamsTeamIdMembersUserEmailDelete = <ThrowOnError extends boolean = false>(options: Options<RemoveTeamMemberTeamsTeamIdMembersUserEmailDeleteData, ThrowOnError>) => (options.client ?? client).delete<RemoveTeamMemberTeamsTeamIdMembersUserEmailDeleteResponses, RemoveTeamMemberTeamsTeamIdMembersUserEmailDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/{team_id}/members/{user_email}',
    ...options
});

/**
 * Update Team Member
 *
 * Update a team member's role.
 *
 * Args:
 * team_id: Team UUID
 * user_email: Email of the member to update
 * request: Member update request data
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * TeamMemberResponse: Updated member data
 *
 * Raises:
 * HTTPException: If member not found, access denied, or update fails
 */
export const updateTeamMemberTeamsTeamIdMembersUserEmailPut = <ThrowOnError extends boolean = false>(options: Options<UpdateTeamMemberTeamsTeamIdMembersUserEmailPutData, ThrowOnError>) => (options.client ?? client).put<UpdateTeamMemberTeamsTeamIdMembersUserEmailPutResponses, UpdateTeamMemberTeamsTeamIdMembersUserEmailPutErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/{team_id}/members/{user_email}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List Team Invitations
 *
 * List team invitations.
 *
 * Args:
 * team_id: Team UUID
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * List[TeamInvitationResponse]: List of team invitations
 *
 * Raises:
 * HTTPException: If team not found or access denied
 */
export const listTeamInvitationsTeamsTeamIdInvitationsGet = <ThrowOnError extends boolean = false>(options: Options<ListTeamInvitationsTeamsTeamIdInvitationsGetData, ThrowOnError>) => (options.client ?? client).get<ListTeamInvitationsTeamsTeamIdInvitationsGetResponses, ListTeamInvitationsTeamsTeamIdInvitationsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/{team_id}/invitations',
    ...options
});

/**
 * Invite Team Member
 *
 * Invite a user to join a team.
 *
 * Args:
 * team_id: Team UUID
 * request: Invitation request data
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * TeamInvitationResponse: Created invitation data
 *
 * Raises:
 * HTTPException: If team not found, access denied, or invitation fails
 */
export const inviteTeamMemberTeamsTeamIdInvitationsPost = <ThrowOnError extends boolean = false>(options: Options<InviteTeamMemberTeamsTeamIdInvitationsPostData, ThrowOnError>) => (options.client ?? client).post<InviteTeamMemberTeamsTeamIdInvitationsPostResponses, InviteTeamMemberTeamsTeamIdInvitationsPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/{team_id}/invitations',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Accept Team Invitation
 *
 * Accept a team invitation.
 *
 * Args:
 * token: Invitation token
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * TeamMemberResponse: New team member data
 *
 * Raises:
 * HTTPException: If invitation not found, expired, or acceptance fails
 */
export const acceptTeamInvitationTeamsInvitationsTokenAcceptPost = <ThrowOnError extends boolean = false>(options: Options<AcceptTeamInvitationTeamsInvitationsTokenAcceptPostData, ThrowOnError>) => (options.client ?? client).post<AcceptTeamInvitationTeamsInvitationsTokenAcceptPostResponses, AcceptTeamInvitationTeamsInvitationsTokenAcceptPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/invitations/{token}/accept',
    ...options
});

/**
 * Cancel Team Invitation
 *
 * Cancel a team invitation.
 *
 * Args:
 * invitation_id: Invitation UUID
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * SuccessResponse: Success confirmation
 *
 * Raises:
 * HTTPException: If invitation not found, access denied, or cancellation fails
 */
export const cancelTeamInvitationTeamsInvitationsInvitationIdDelete = <ThrowOnError extends boolean = false>(options: Options<CancelTeamInvitationTeamsInvitationsInvitationIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<CancelTeamInvitationTeamsInvitationsInvitationIdDeleteResponses, CancelTeamInvitationTeamsInvitationsInvitationIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/invitations/{invitation_id}',
    ...options
});

/**
 * Discover Public Teams
 *
 * Discover public teams that can be joined.
 *
 * Returns public teams that are discoverable to all authenticated users.
 * Only shows teams where the current user is not already a member.
 *
 * Args:
 * skip: Number of teams to skip for pagination
 * limit: Maximum number of teams to return
 * current_user_ctx: Current user context with permissions and database session
 *
 * Returns:
 * List[TeamDiscoveryResponse]: List of discoverable public teams
 *
 * Raises:
 * HTTPException: If there's an error discovering teams
 */
export const discoverPublicTeamsTeamsDiscoverGet = <ThrowOnError extends boolean = false>(options?: Options<DiscoverPublicTeamsTeamsDiscoverGetData, ThrowOnError>) => (options?.client ?? client).get<DiscoverPublicTeamsTeamsDiscoverGetResponses, DiscoverPublicTeamsTeamsDiscoverGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/discover',
    ...options
});

/**
 * Request To Join Team
 *
 * Request to join a public team.
 *
 * Allows users to request membership in public teams. The request will be
 * pending until approved by a team owner.
 *
 * Args:
 * team_id: ID of the team to join
 * join_request: Join request details including optional message
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * TeamJoinRequestResponse: Created join request details
 *
 * Raises:
 * HTTPException: If team not found, not public, user already member, or request fails
 */
export const requestToJoinTeamTeamsTeamIdJoinPost = <ThrowOnError extends boolean = false>(options: Options<RequestToJoinTeamTeamsTeamIdJoinPostData, ThrowOnError>) => (options.client ?? client).post<RequestToJoinTeamTeamsTeamIdJoinPostResponses, RequestToJoinTeamTeamsTeamIdJoinPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/{team_id}/join',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Leave Team
 *
 * Leave a team.
 *
 * Allows users to remove themselves from a team. Cannot leave personal teams
 * or if they are the last owner of a team.
 *
 * Args:
 * team_id: ID of the team to leave
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * SuccessResponse: Confirmation of leaving the team
 *
 * Raises:
 * HTTPException: If team not found, user not member, cannot leave personal team, or last owner
 */
export const leaveTeamTeamsTeamIdLeaveDelete = <ThrowOnError extends boolean = false>(options: Options<LeaveTeamTeamsTeamIdLeaveDeleteData, ThrowOnError>) => (options.client ?? client).delete<LeaveTeamTeamsTeamIdLeaveDeleteResponses, LeaveTeamTeamsTeamIdLeaveDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/{team_id}/leave',
    ...options
});

/**
 * List Team Join Requests
 *
 * List pending join requests for a team.
 *
 * Only team owners can view join requests for their teams.
 *
 * Args:
 * team_id: ID of the team
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * List[TeamJoinRequestResponse]: List of pending join requests
 *
 * Raises:
 * HTTPException: If team not found or user not authorized
 */
export const listTeamJoinRequestsTeamsTeamIdJoinRequestsGet = <ThrowOnError extends boolean = false>(options: Options<ListTeamJoinRequestsTeamsTeamIdJoinRequestsGetData, ThrowOnError>) => (options.client ?? client).get<ListTeamJoinRequestsTeamsTeamIdJoinRequestsGetResponses, ListTeamJoinRequestsTeamsTeamIdJoinRequestsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/{team_id}/join-requests',
    ...options
});

/**
 * Approve Join Request
 *
 * Approve a team join request.
 *
 * Only team owners can approve join requests for their teams.
 *
 * Args:
 * team_id: ID of the team
 * request_id: ID of the join request
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * TeamMemberResponse: New team member data
 *
 * Raises:
 * HTTPException: If request not found or user not authorized
 */
export const approveJoinRequestTeamsTeamIdJoinRequestsRequestIdApprovePost = <ThrowOnError extends boolean = false>(options: Options<ApproveJoinRequestTeamsTeamIdJoinRequestsRequestIdApprovePostData, ThrowOnError>) => (options.client ?? client).post<ApproveJoinRequestTeamsTeamIdJoinRequestsRequestIdApprovePostResponses, ApproveJoinRequestTeamsTeamIdJoinRequestsRequestIdApprovePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/{team_id}/join-requests/{request_id}/approve',
    ...options
});

/**
 * Reject Join Request
 *
 * Reject a team join request.
 *
 * Only team owners can reject join requests for their teams.
 *
 * Args:
 * team_id: ID of the team
 * request_id: ID of the join request
 * current_user: Currently authenticated user
 * db: Database session
 *
 * Returns:
 * SuccessResponse: Confirmation of rejection
 *
 * Raises:
 * HTTPException: If request not found or user not authorized
 */
export const rejectJoinRequestTeamsTeamIdJoinRequestsRequestIdDelete = <ThrowOnError extends boolean = false>(options: Options<RejectJoinRequestTeamsTeamIdJoinRequestsRequestIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<RejectJoinRequestTeamsTeamIdJoinRequestsRequestIdDeleteResponses, RejectJoinRequestTeamsTeamIdJoinRequestsRequestIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/teams/{team_id}/join-requests/{request_id}',
    ...options
});

/**
 * List Tokens
 *
 * List API tokens for the current user.
 *
 * Args:
 * include_inactive: Include inactive/expired tokens
 * limit: Maximum number of tokens to return (default 50)
 * offset: Number of tokens to skip for pagination
 * current_user: Authenticated user from JWT
 * db: Database session
 *
 * Returns:
 * TokenListResponse: List of user's API tokens
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(list_tokens)
 * True
 */
export const listTokensTokensGet = <ThrowOnError extends boolean = false>(options?: Options<ListTokensTokensGetData, ThrowOnError>) => (options?.client ?? client).get<ListTokensTokensGetResponses, ListTokensTokensGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tokens',
    ...options
});

/**
 * Create Token
 *
 * Create a new API token for the current user.
 *
 * Args:
 * request: Token creation request with name, description, scoping, etc.
 * current_user: Authenticated user from JWT
 * db: Database session
 *
 * Returns:
 * TokenCreateResponse: Created token details with raw token
 *
 * Raises:
 * HTTPException: If token name already exists or validation fails
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(create_token)
 * True
 */
export const createTokenTokensPost = <ThrowOnError extends boolean = false>(options: Options<CreateTokenTokensPostData, ThrowOnError>) => (options.client ?? client).post<CreateTokenTokensPostResponses, CreateTokenTokensPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tokens',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Revoke Token
 *
 * Revoke (delete) a token.
 *
 * Args:
 * token_id: Token ID to revoke
 * request: Optional revocation request with reason
 * current_user: Authenticated user from JWT
 * db: Database session
 *
 * Raises:
 * HTTPException: If token not found
 */
export const revokeTokenTokensTokenIdDelete = <ThrowOnError extends boolean = false>(options: Options<RevokeTokenTokensTokenIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<RevokeTokenTokensTokenIdDeleteResponses, RevokeTokenTokensTokenIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tokens/{token_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get Token
 *
 * Get details of a specific token.
 *
 * Args:
 * token_id: Token ID to retrieve
 * current_user: Authenticated user from JWT
 * db: Database session
 *
 * Returns:
 * TokenResponse: Token details
 *
 * Raises:
 * HTTPException: If token not found or not owned by user
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(get_token)
 * True
 */
export const getTokenTokensTokenIdGet = <ThrowOnError extends boolean = false>(options: Options<GetTokenTokensTokenIdGetData, ThrowOnError>) => (options.client ?? client).get<GetTokenTokensTokenIdGetResponses, GetTokenTokensTokenIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tokens/{token_id}',
    ...options
});

/**
 * Update Token
 *
 * Update an existing token.
 *
 * Args:
 * token_id: Token ID to update
 * request: Token update request
 * current_user: Authenticated user from JWT
 * db: Database session
 *
 * Returns:
 * TokenResponse: Updated token details
 *
 * Raises:
 * HTTPException: If token not found or validation fails
 */
export const updateTokenTokensTokenIdPut = <ThrowOnError extends boolean = false>(options: Options<UpdateTokenTokensTokenIdPutData, ThrowOnError>) => (options.client ?? client).put<UpdateTokenTokensTokenIdPutResponses, UpdateTokenTokensTokenIdPutErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tokens/{token_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get Token Usage Stats
 *
 * Get usage statistics for a specific token.
 *
 * Args:
 * token_id: Token ID to get stats for
 * days: Number of days to analyze (default 30)
 * current_user: Authenticated user from JWT
 * db: Database session
 *
 * Returns:
 * TokenUsageStatsResponse: Token usage statistics
 *
 * Raises:
 * HTTPException: If token not found or not owned by user
 */
export const getTokenUsageStatsTokensTokenIdUsageGet = <ThrowOnError extends boolean = false>(options: Options<GetTokenUsageStatsTokensTokenIdUsageGetData, ThrowOnError>) => (options.client ?? client).get<GetTokenUsageStatsTokensTokenIdUsageGetResponses, GetTokenUsageStatsTokensTokenIdUsageGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tokens/{token_id}/usage',
    ...options
});

/**
 * List All Tokens
 *
 * Admin endpoint to list all tokens or tokens for a specific user.
 *
 * Args:
 * user_email: Filter tokens by user email (admin only)
 * include_inactive: Include inactive/expired tokens
 * limit: Maximum number of tokens to return
 * offset: Number of tokens to skip
 * current_user: Authenticated admin user
 * db: Database session
 *
 * Returns:
 * TokenListResponse: List of tokens
 *
 * Raises:
 * HTTPException: If user is not admin
 */
export const listAllTokensTokensAdminAllGet = <ThrowOnError extends boolean = false>(options?: Options<ListAllTokensTokensAdminAllGetData, ThrowOnError>) => (options?.client ?? client).get<ListAllTokensTokensAdminAllGetResponses, ListAllTokensTokensAdminAllGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tokens/admin/all',
    ...options
});

/**
 * Admin Revoke Token
 *
 * Admin endpoint to revoke any token.
 *
 * Args:
 * token_id: Token ID to revoke
 * request: Optional revocation request with reason
 * current_user: Authenticated admin user
 * db: Database session
 *
 * Raises:
 * HTTPException: If user is not admin or token not found
 */
export const adminRevokeTokenTokensAdminTokenIdDelete = <ThrowOnError extends boolean = false>(options: Options<AdminRevokeTokenTokensAdminTokenIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<AdminRevokeTokenTokensAdminTokenIdDeleteResponses, AdminRevokeTokenTokensAdminTokenIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tokens/admin/{token_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List Team Tokens
 *
 * List API tokens for a team (only team owners can do this).
 *
 * Args:
 * team_id: Team ID to list tokens for
 * include_inactive: Include inactive/expired tokens
 * limit: Maximum number of tokens to return (default 50)
 * offset: Number of tokens to skip for pagination
 * current_user: Authenticated user (must be team owner)
 * db: Database session
 *
 * Returns:
 * TokenListResponse: List of teams API tokens
 *
 * Raises:
 * HTTPException: If user is not team owner
 */
export const listTeamTokensTokensTeamsTeamIdGet = <ThrowOnError extends boolean = false>(options: Options<ListTeamTokensTokensTeamsTeamIdGetData, ThrowOnError>) => (options.client ?? client).get<ListTeamTokensTokensTeamsTeamIdGetResponses, ListTeamTokensTokensTeamsTeamIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tokens/teams/{team_id}',
    ...options
});

/**
 * Create Team Token
 *
 * Create a new API token for a team (only team owners can do this).
 *
 * Args:
 * team_id: Team ID to create token for
 * request: Token creation request with name, description, scoping, etc.
 * current_user: Authenticated user (must be team owner)
 * db: Database session
 *
 * Returns:
 * TokenCreateResponse: Created token details with raw token
 *
 * Raises:
 * HTTPException: If user is not team owner or validation fails
 */
export const createTeamTokenTokensTeamsTeamIdPost = <ThrowOnError extends boolean = false>(options: Options<CreateTeamTokenTokensTeamsTeamIdPostData, ThrowOnError>) => (options.client ?? client).post<CreateTeamTokenTokensTeamsTeamIdPostResponses, CreateTeamTokenTokensTeamsTeamIdPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tokens/teams/{team_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List Roles
 *
 * List all roles.
 *
 * Args:
 * scope: Optional scope filter
 * active_only: Whether to show only active roles
 * user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * List[RoleResponse]: List of roles
 *
 * Raises:
 * HTTPException: If user lacks required permissions
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(list_roles)
 * True
 */
export const listRolesRbacRolesGet = <ThrowOnError extends boolean = false>(options?: Options<ListRolesRbacRolesGetData, ThrowOnError>) => (options?.client ?? client).get<ListRolesRbacRolesGetResponses, ListRolesRbacRolesGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/rbac/roles',
    ...options
});

/**
 * Create Role
 *
 * Create a new role.
 *
 * Requires admin permissions to create roles.
 *
 * Args:
 * role_data: Role creation data
 * user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * RoleResponse: Created role details
 *
 * Raises:
 * HTTPException: If role creation fails
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(create_role)
 * True
 */
export const createRoleRbacRolesPost = <ThrowOnError extends boolean = false>(options: Options<CreateRoleRbacRolesPostData, ThrowOnError>) => (options.client ?? client).post<CreateRoleRbacRolesPostResponses, CreateRoleRbacRolesPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/rbac/roles',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete Role
 *
 * Delete a role.
 *
 * Args:
 * role_id: Role identifier
 * user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * dict: Success message
 *
 * Raises:
 * HTTPException: If role not found or deletion fails
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(delete_role)
 * True
 */
export const deleteRoleRbacRolesRoleIdDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteRoleRbacRolesRoleIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<DeleteRoleRbacRolesRoleIdDeleteResponses, DeleteRoleRbacRolesRoleIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/rbac/roles/{role_id}',
    ...options
});

/**
 * Get Role
 *
 * Get role details by ID.
 *
 * Args:
 * role_id: Role identifier
 * user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * RoleResponse: Role details
 *
 * Raises:
 * HTTPException: If role not found
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(get_role)
 * True
 */
export const getRoleRbacRolesRoleIdGet = <ThrowOnError extends boolean = false>(options: Options<GetRoleRbacRolesRoleIdGetData, ThrowOnError>) => (options.client ?? client).get<GetRoleRbacRolesRoleIdGetResponses, GetRoleRbacRolesRoleIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/rbac/roles/{role_id}',
    ...options
});

/**
 * Update Role
 *
 * Update an existing role.
 *
 * Args:
 * role_id: Role identifier
 * role_data: Role update data
 * user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * RoleResponse: Updated role details
 *
 * Raises:
 * HTTPException: If role not found or update fails
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(update_role)
 * True
 */
export const updateRoleRbacRolesRoleIdPut = <ThrowOnError extends boolean = false>(options: Options<UpdateRoleRbacRolesRoleIdPutData, ThrowOnError>) => (options.client ?? client).put<UpdateRoleRbacRolesRoleIdPutResponses, UpdateRoleRbacRolesRoleIdPutErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/rbac/roles/{role_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get User Roles
 *
 * Get roles assigned to a user.
 *
 * Args:
 * user_email: User email address
 * scope: Optional scope filter
 * active_only: Whether to show only active assignments
 * user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * List[UserRoleResponse]: User's role assignments
 *
 * Raises:
 * HTTPException: If role retrieval fails
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(get_user_roles)
 * True
 */
export const getUserRolesRbacUsersUserEmailRolesGet = <ThrowOnError extends boolean = false>(options: Options<GetUserRolesRbacUsersUserEmailRolesGetData, ThrowOnError>) => (options.client ?? client).get<GetUserRolesRbacUsersUserEmailRolesGetResponses, GetUserRolesRbacUsersUserEmailRolesGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/rbac/users/{user_email}/roles',
    ...options
});

/**
 * Assign Role To User
 *
 * Assign a role to a user.
 *
 * Args:
 * user_email: User email address
 * assignment_data: Role assignment data
 * user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * UserRoleResponse: Created role assignment
 *
 * Raises:
 * HTTPException: If assignment fails
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(assign_role_to_user)
 * True
 */
export const assignRoleToUserRbacUsersUserEmailRolesPost = <ThrowOnError extends boolean = false>(options: Options<AssignRoleToUserRbacUsersUserEmailRolesPostData, ThrowOnError>) => (options.client ?? client).post<AssignRoleToUserRbacUsersUserEmailRolesPostResponses, AssignRoleToUserRbacUsersUserEmailRolesPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/rbac/users/{user_email}/roles',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Revoke User Role
 *
 * Revoke a role from a user.
 *
 * Args:
 * user_email: User email address
 * role_id: Role identifier
 * scope: Optional scope filter
 * scope_id: Optional scope ID filter
 * user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * dict: Success message
 *
 * Raises:
 * HTTPException: If revocation fails
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(revoke_user_role)
 * True
 */
export const revokeUserRoleRbacUsersUserEmailRolesRoleIdDelete = <ThrowOnError extends boolean = false>(options: Options<RevokeUserRoleRbacUsersUserEmailRolesRoleIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<RevokeUserRoleRbacUsersUserEmailRolesRoleIdDeleteResponses, RevokeUserRoleRbacUsersUserEmailRolesRoleIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/rbac/users/{user_email}/roles/{role_id}',
    ...options
});

/**
 * Check Permission
 *
 * Check if a user has specific permission.
 *
 * Args:
 * check_data: Permission check request
 * user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * PermissionCheckResponse: Permission check result
 *
 * Raises:
 * HTTPException: If permission check fails
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(check_permission)
 * True
 */
export const checkPermissionRbacPermissionsCheckPost = <ThrowOnError extends boolean = false>(options: Options<CheckPermissionRbacPermissionsCheckPostData, ThrowOnError>) => (options.client ?? client).post<CheckPermissionRbacPermissionsCheckPostResponses, CheckPermissionRbacPermissionsCheckPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/rbac/permissions/check',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get User Permissions
 *
 * Get all effective permissions for a user.
 *
 * Args:
 * user_email: User email address
 * team_id: Optional team context
 * user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * List[str]: User's effective permissions
 *
 * Raises:
 * HTTPException: If retrieving user permissions fails
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(get_user_permissions)
 * True
 */
export const getUserPermissionsRbacPermissionsUserUserEmailGet = <ThrowOnError extends boolean = false>(options: Options<GetUserPermissionsRbacPermissionsUserUserEmailGetData, ThrowOnError>) => (options.client ?? client).get<GetUserPermissionsRbacPermissionsUserUserEmailGetResponses, GetUserPermissionsRbacPermissionsUserUserEmailGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/rbac/permissions/user/{user_email}',
    ...options
});

/**
 * Get Available Permissions
 *
 * Get all available permissions in the system.
 *
 * Args:
 * user: Current authenticated user
 *
 * Returns:
 * PermissionListResponse: Available permissions organized by resource type
 *
 * Raises:
 * HTTPException: If retrieving available permissions fails
 */
export const getAvailablePermissionsRbacPermissionsAvailableGet = <ThrowOnError extends boolean = false>(options?: Options<GetAvailablePermissionsRbacPermissionsAvailableGetData, ThrowOnError>) => (options?.client ?? client).get<GetAvailablePermissionsRbacPermissionsAvailableGetResponses, GetAvailablePermissionsRbacPermissionsAvailableGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/rbac/permissions/available',
    ...options
});

/**
 * Get My Roles
 *
 * Get current user's role assignments.
 *
 * Args:
 * user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * List[UserRoleResponse]: Current user's role assignments
 *
 * Raises:
 * HTTPException: If retrieving user roles fails
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(get_my_roles)
 * True
 */
export const getMyRolesRbacMyRolesGet = <ThrowOnError extends boolean = false>(options?: Options<GetMyRolesRbacMyRolesGetData, ThrowOnError>) => (options?.client ?? client).get<GetMyRolesRbacMyRolesGetResponses, GetMyRolesRbacMyRolesGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/rbac/my/roles',
    ...options
});

/**
 * Get My Permissions
 *
 * Get current user's effective permissions.
 *
 * Args:
 * team_id: Optional team context
 * user: Current authenticated user
 * db: Database session
 *
 * Returns:
 * List[str]: Current user's effective permissions
 *
 * Raises:
 * HTTPException: If retrieving user permissions fails
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(get_my_permissions)
 * True
 */
export const getMyPermissionsRbacMyPermissionsGet = <ThrowOnError extends boolean = false>(options?: Options<GetMyPermissionsRbacMyPermissionsGetData, ThrowOnError>) => (options?.client ?? client).get<GetMyPermissionsRbacMyPermissionsGetResponses, GetMyPermissionsRbacMyPermissionsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/rbac/my/permissions',
    ...options
});

/**
 * Initiate Oauth Flow
 *
 * Initiates the OAuth 2.0 Authorization Code flow for a specified gateway.
 *
 * This endpoint retrieves the OAuth configuration for the given gateway, validates that
 * the gateway supports the Authorization Code flow, and redirects the user to the OAuth
 * provider's authorization URL to begin the OAuth process.
 *
 * **Phase 1.4: DCR Integration**
 * If the gateway has an issuer but no client_id, and DCR is enabled, this endpoint will
 * automatically register the gateway as an OAuth client with the Authorization Server
 * using Dynamic Client Registration (RFC 7591).
 *
 * Args:
 * gateway_id: The unique identifier of the gateway to authorize.
 * request: The FastAPI request object.
 * current_user: The authenticated user initiating the OAuth flow.
 * db: The database session dependency.
 *
 * Returns:
 * A redirect response to the OAuth provider's authorization URL.
 *
 * Raises:
 * HTTPException: If the gateway is not found, not configured for OAuth, or not using
 * the Authorization Code flow. If an unexpected error occurs during the initiation process.
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(initiate_oauth_flow)
 * True
 */
export const initiateOauthFlowOauthAuthorizeGatewayIdGet = <ThrowOnError extends boolean = false>(options: Options<InitiateOauthFlowOauthAuthorizeGatewayIdGetData, ThrowOnError>) => (options.client ?? client).get<InitiateOauthFlowOauthAuthorizeGatewayIdGetResponses, InitiateOauthFlowOauthAuthorizeGatewayIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/oauth/authorize/{gateway_id}',
    ...options
});

/**
 * Oauth Callback
 *
 * Handle the OAuth callback and complete the authorization process.
 *
 * This endpoint is called by the OAuth provider after the user authorizes access.
 * It receives the authorization code and state parameters, verifies the state,
 * retrieves the corresponding gateway configuration, and exchanges the code for an access token.
 *
 * Args:
 * code (str): The authorization code returned by the OAuth provider.
 * state (str): The state parameter for CSRF protection, which encodes the gateway ID.
 * request (Request): The incoming HTTP request object.
 * db (Session): The database session dependency.
 *
 * Returns:
 * HTMLResponse: An HTML response indicating the result of the OAuth authorization process.
 *
 * Raises:
 * ValueError: Raised internally when state parameter is missing gateway_id (caught and handled).
 *
 * Examples:
 * >>> import asyncio
 * >>> asyncio.iscoroutinefunction(oauth_callback)
 * True
 */
export const oauthCallbackOauthCallbackGet = <ThrowOnError extends boolean = false>(options: Options<OauthCallbackOauthCallbackGetData, ThrowOnError>) => (options.client ?? client).get<OauthCallbackOauthCallbackGetResponses, OauthCallbackOauthCallbackGetErrors, ThrowOnError>({ url: '/oauth/callback', ...options });

/**
 * Get Oauth Status
 *
 * Get OAuth status for a gateway.
 *
 * Args:
 * gateway_id: ID of the gateway
 * db: Database session
 *
 * Returns:
 * OAuth status information
 *
 * Raises:
 * HTTPException: If gateway not found or error retrieving status
 */
export const getOauthStatusOauthStatusGatewayIdGet = <ThrowOnError extends boolean = false>(options: Options<GetOauthStatusOauthStatusGatewayIdGetData, ThrowOnError>) => (options.client ?? client).get<GetOauthStatusOauthStatusGatewayIdGetResponses, GetOauthStatusOauthStatusGatewayIdGetErrors, ThrowOnError>({ url: '/oauth/status/{gateway_id}', ...options });

/**
 * Fetch Tools After Oauth
 *
 * Fetch tools from MCP server after OAuth completion for Authorization Code flow.
 *
 * Args:
 * gateway_id: ID of the gateway to fetch tools for
 * current_user: The authenticated user fetching tools
 * db: Database session
 *
 * Returns:
 * Dict containing success status and message with number of tools fetched
 *
 * Raises:
 * HTTPException: If fetching tools fails
 */
export const fetchToolsAfterOauthOauthFetchToolsGatewayIdPost = <ThrowOnError extends boolean = false>(options: Options<FetchToolsAfterOauthOauthFetchToolsGatewayIdPostData, ThrowOnError>) => (options.client ?? client).post<FetchToolsAfterOauthOauthFetchToolsGatewayIdPostResponses, FetchToolsAfterOauthOauthFetchToolsGatewayIdPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/oauth/fetch-tools/{gateway_id}',
    ...options
});

/**
 * List Registered Oauth Clients
 *
 * List all registered OAuth clients (created via DCR).
 *
 * This endpoint shows OAuth clients that were dynamically registered with external
 * Authorization Servers using RFC 7591 Dynamic Client Registration.
 *
 * Args:
 * current_user: The authenticated user (admin access required)
 * db: Database session
 *
 * Returns:
 * Dict containing list of registered OAuth clients with metadata
 *
 * Raises:
 * HTTPException: If user lacks permissions or database error occurs
 */
export const listRegisteredOauthClientsOauthRegisteredClientsGet = <ThrowOnError extends boolean = false>(options?: Options<ListRegisteredOauthClientsOauthRegisteredClientsGetData, ThrowOnError>) => (options?.client ?? client).get<ListRegisteredOauthClientsOauthRegisteredClientsGetResponses, ListRegisteredOauthClientsOauthRegisteredClientsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/oauth/registered-clients',
    ...options
});

/**
 * Get Registered Client For Gateway
 *
 * Get the registered OAuth client for a specific gateway.
 *
 * Args:
 * gateway_id: The gateway ID to lookup
 * current_user: The authenticated user
 * db: Database session
 *
 * Returns:
 * Dict containing registered client information
 *
 * Raises:
 * HTTPException: If gateway or registered client not found
 */
export const getRegisteredClientForGatewayOauthRegisteredClientsGatewayIdGet = <ThrowOnError extends boolean = false>(options: Options<GetRegisteredClientForGatewayOauthRegisteredClientsGatewayIdGetData, ThrowOnError>) => (options.client ?? client).get<GetRegisteredClientForGatewayOauthRegisteredClientsGatewayIdGetResponses, GetRegisteredClientForGatewayOauthRegisteredClientsGatewayIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/oauth/registered-clients/{gateway_id}',
    ...options
});

/**
 * Delete Registered Client
 *
 * Delete a registered OAuth client.
 *
 * This will revoke the client registration locally. Note: This does not automatically
 * revoke the client at the Authorization Server. You may need to manually revoke the
 * client using the registration_client_uri if available.
 *
 * Args:
 * client_id: The registered client ID to delete
 * current_user: The authenticated user (admin access required)
 * db: Database session
 *
 * Returns:
 * Dict containing success message
 *
 * Raises:
 * HTTPException: If client not found or deletion fails
 */
export const deleteRegisteredClientOauthRegisteredClientsClientIdDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteRegisteredClientOauthRegisteredClientsClientIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<DeleteRegisteredClientOauthRegisteredClientsClientIdDeleteResponses, DeleteRegisteredClientOauthRegisteredClientsClientIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/oauth/registered-clients/{client_id}',
    ...options
});

/**
 * List Sessions
 *
 * List all active reverse proxy sessions.
 *
 * Args:
 * request: HTTP request.
 * _: Authenticated user info (used for auth check).
 *
 * Returns:
 * List of session information.
 */
export const listSessionsReverseProxySessionsGet = <ThrowOnError extends boolean = false>(options?: Options<ListSessionsReverseProxySessionsGetData, ThrowOnError>) => (options?.client ?? client).get<ListSessionsReverseProxySessionsGetResponses, ListSessionsReverseProxySessionsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/reverse-proxy/sessions',
    ...options
});

/**
 * Disconnect Session
 *
 * Disconnect a reverse proxy session.
 *
 * Args:
 * session_id: Session ID to disconnect.
 * request: HTTP request.
 * _: Authenticated user info (used for auth check).
 *
 * Returns:
 * Disconnection status.
 *
 * Raises:
 * HTTPException: If session is not found.
 */
export const disconnectSessionReverseProxySessionsSessionIdDelete = <ThrowOnError extends boolean = false>(options: Options<DisconnectSessionReverseProxySessionsSessionIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<DisconnectSessionReverseProxySessionsSessionIdDeleteResponses, DisconnectSessionReverseProxySessionsSessionIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/reverse-proxy/sessions/{session_id}',
    ...options
});

/**
 * Send Request To Session
 *
 * Send an MCP request to a reverse proxy session.
 *
 * Args:
 * session_id: Session ID to send request to.
 * mcp_request: MCP request to send.
 * request: HTTP request.
 * _: Authenticated user info (used for auth check).
 *
 * Returns:
 * Request acknowledgment.
 *
 * Raises:
 * HTTPException: If session is not found or request fails.
 */
export const sendRequestToSessionReverseProxySessionsSessionIdRequestPost = <ThrowOnError extends boolean = false>(options: Options<SendRequestToSessionReverseProxySessionsSessionIdRequestPostData, ThrowOnError>) => (options.client ?? client).post<SendRequestToSessionReverseProxySessionsSessionIdRequestPostResponses, SendRequestToSessionReverseProxySessionsSessionIdRequestPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/reverse-proxy/sessions/{session_id}/request',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Sse Endpoint
 *
 * SSE endpoint for receiving messages from a reverse proxy session.
 *
 * Args:
 * session_id: Session ID to subscribe to.
 * request: HTTP request.
 *
 * Returns:
 * SSE stream.
 *
 * Raises:
 * HTTPException: If session is not found.
 */
export const sseEndpointReverseProxySseSessionIdGet = <ThrowOnError extends boolean = false>(options: Options<SseEndpointReverseProxySseSessionIdGetData, ThrowOnError>) => (options.client ?? client).get<SseEndpointReverseProxySseSessionIdGetResponses, SseEndpointReverseProxySseSessionIdGetErrors, ThrowOnError>({ url: '/reverse-proxy/sse/{session_id}', ...options });

/**
 * Connect
 *
 * Create or refresh a chat session for a user.
 *
 * Initializes a new MCPChatService instance for the specified user, establishing
 * connections to both the MCP server and the configured LLM provider. If a session
 * already exists for the user, it is gracefully shutdown before creating a new one.
 *
 * Authentication is handled via JWT token from cookies if not explicitly provided
 * in the request body.
 *
 * Args:
 * input_data: ConnectInput containing user_id, optional server/LLM config, and streaming preference.
 * request: FastAPI Request object for accessing cookies and headers.
 *
 * Returns:
 * dict: Connection status response containing:
 * - status: 'connected'
 * - user_id: The connected user's identifier
 * - provider: The LLM provider being used
 * - tool_count: Number of available MCP tools
 * - tools: List of tool names
 *
 * Raises:
 * HTTPException: If an error occurs.
 * 400: Invalid user_id, invalid configuration, or LLM config error.
 * 401: Missing authentication token.
 * 503: Failed to connect to MCP server.
 * 500: Service initialization failure or unexpected error.
 *
 * Examples:
 * This endpoint is called via HTTP POST and cannot be directly tested with doctest.
 * Example request body:
 *
 * {
 * "user_id": "user123",
 * "server": {
 * "url": "http://localhost:8000/mcp",
 * "auth_token": "jwt_token_here"
 * },
 * "llm": {
 * "provider": "ollama",
 * "config": {"model": "llama3"}
 * },
 * "streaming": false
 * }
 *
 * Example response:
 *
 * {
 * "status": "connected",
 * "user_id": "user123",
 * "provider": "ollama",
 * "tool_count": 5,
 * "tools": ["search", "calculator", "weather", "translate", "summarize"]
 * }
 *
 * Note:
 * Existing sessions are automatically terminated before establishing new ones.
 * All configuration values support environment variable fallbacks.
 */
export const connectLlmchatConnectPost = <ThrowOnError extends boolean = false>(options: Options<ConnectLlmchatConnectPostData, ThrowOnError>) => (options.client ?? client).post<ConnectLlmchatConnectPostResponses, ConnectLlmchatConnectPostErrors, ThrowOnError>({
    url: '/llmchat/connect',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Chat
 *
 * Send a message to the user's active chat session and receive a response.
 *
 * Processes user messages through the configured LLM with MCP tool integration.
 * Supports both streaming (SSE) and non-streaming response modes. Chat history
 * is managed automatically via the unified ChatHistoryManager.
 *
 * Args:
 * input_data: ChatInput containing user_id, message, and streaming preference.
 *
 * Returns:
 * For streaming=False:
 * dict: Response containing:
 * - user_id: Session identifier
 * - response: Complete LLM response text
 * - tool_used: Boolean indicating if tools were invoked
 * - tools: List of tool names used
 * - tool_invocations: Detailed tool call information
 * - elapsed_ms: Processing time in milliseconds
 * For streaming=True:
 * StreamingResponse: SSE stream of token and event data.
 *
 * Raises:
 * HTTPException: Raised when an HTTP-related error occurs.
 * 400: Missing user_id, empty message, or no active session.
 * 503: Session not initialized, chat service error, or connection lost.
 * 504: Request timeout.
 * 500: Unexpected error.
 *
 * Examples:
 * This endpoint is called via HTTP POST and cannot be directly tested with doctest.
 *
 * Example non-streaming request:
 *
 * {
 * "user_id": "user123",
 * "message": "What's the weather like?",
 * "streaming": false
 * }
 *
 * Example non-streaming response:
 *
 * {
 * "user_id": "user123",
 * "response": "The weather is sunny and 72F.",
 * "tool_used": true,
 * "tools": ["weather"],
 * "tool_invocations": 1,
 * "elapsed_ms": 450
 * }
 *
 * Example streaming request:
 *
 * {
 * "user_id": "user123",
 * "message": "Tell me a story",
 * "streaming": true
 * }
 *
 * Note:
 * Streaming responses use Server-Sent Events (SSE) with 'text/event-stream' MIME type.
 * Client must maintain persistent connection for streaming.
 */
export const chatLlmchatChatPost = <ThrowOnError extends boolean = false>(options: Options<ChatLlmchatChatPostData, ThrowOnError>) => (options.client ?? client).post<ChatLlmchatChatPostResponses, ChatLlmchatChatPostErrors, ThrowOnError>({
    url: '/llmchat/chat',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Disconnect
 *
 * End the chat session for a user and clean up resources.
 *
 * Gracefully shuts down the MCPChatService instance, closes connections,
 * and removes session data from active storage. Safe to call even if
 * no active session exists.
 *
 * Args:
 * input_data: DisconnectInput containing the user_id to disconnect.
 *
 * Returns:
 * dict: Disconnection status containing:
 * - status: One of 'disconnected', 'no_active_session', or 'disconnected_with_errors'
 * - user_id: The user identifier
 * - message: Human-readable status description
 * - warning: (Optional) Error details if cleanup encountered issues
 *
 * Raises:
 * HTTPException: Raised when an HTTP-related error occurs.
 * 400: Missing user_id.
 *
 * Examples:
 * This endpoint is called via HTTP POST and cannot be directly tested with doctest.
 *
 * Example request:
 *
 * {
 * "user_id": "user123"
 * }
 *
 * Example successful response:
 *
 * {
 * "status": "disconnected",
 * "user_id": "user123",
 * "message": "Successfully disconnected"
 * }
 *
 * Example response when no session exists:
 *
 * {
 * "status": "no_active_session",
 * "user_id": "user123",
 * "message": "No active session to disconnect"
 * }
 *
 * Note:
 * This operation is idempotent - calling it multiple times for the same
 * user_id is safe and will not raise errors.
 */
export const disconnectLlmchatDisconnectPost = <ThrowOnError extends boolean = false>(options: Options<DisconnectLlmchatDisconnectPostData, ThrowOnError>) => (options.client ?? client).post<DisconnectLlmchatDisconnectPostResponses, DisconnectLlmchatDisconnectPostErrors, ThrowOnError>({
    url: '/llmchat/disconnect',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Status
 *
 * Check if an active chat session exists for the specified user.
 *
 * Lightweight endpoint for verifying session state without modifying data.
 * Useful for health checks and UI state management.
 *
 * Args:
 * user_id: User identifier to check session status for.
 *
 * Returns:
 * dict: Status information containing:
 * - user_id: The queried user identifier
 * - connected: Boolean indicating if an active session exists
 *
 * Examples:
 * This endpoint is called via HTTP GET and cannot be directly tested with doctest.
 *
 * Example request:
 * GET /llmchat/status/user123
 *
 * Example response (connected):
 *
 * {
 * "user_id": "user123",
 * "connected": true
 * }
 *
 * Example response (not connected):
 *
 * {
 * "user_id": "user456",
 * "connected": false
 * }
 *
 * Note:
 * This endpoint does not validate that the session is properly initialized,
 * only that it exists in the active_sessions dictionary.
 */
export const statusLlmchatStatusUserIdGet = <ThrowOnError extends boolean = false>(options: Options<StatusLlmchatStatusUserIdGetData, ThrowOnError>) => (options.client ?? client).get<StatusLlmchatStatusUserIdGetResponses, StatusLlmchatStatusUserIdGetErrors, ThrowOnError>({ url: '/llmchat/status/{user_id}', ...options });

/**
 * Get Config
 *
 * Retrieve the stored configuration for a user's session.
 *
 * Returns sanitized configuration data with sensitive information (API keys,
 * auth tokens) removed for security. Useful for debugging and configuration
 * verification.
 *
 * Args:
 * user_id: User identifier whose configuration to retrieve.
 *
 * Returns:
 * dict: Sanitized configuration dictionary containing:
 * - mcp_server: Server connection settings (without auth_token)
 * - llm: LLM provider configuration (without api_key)
 * - enable_streaming: Boolean streaming preference
 *
 * Raises:
 * HTTPException: Raised when an HTTP-related error occurs.
 * 404: No configuration found for the specified user_id.
 *
 *
 * Examples:
 * This endpoint is called via HTTP GET and cannot be directly tested with doctest.
 *
 * Example request:
 * GET /llmchat/config/user123
 *
 * Example response:
 *
 * {
 * "mcp_server": {
 * "url": "http://localhost:8000/mcp",
 * "transport": "streamable_http"
 * },
 * "llm": {
 * "provider": "ollama",
 * "config": {
 * "model": "llama3",
 * "temperature": 0.7
 * }
 * },
 * "enable_streaming": false
 * }
 *
 * Security:
 * API keys and authentication tokens are explicitly removed before returning.
 * Never log or expose these values in responses.
 */
export const getConfigLlmchatConfigUserIdGet = <ThrowOnError extends boolean = false>(options: Options<GetConfigLlmchatConfigUserIdGetData, ThrowOnError>) => (options.client ?? client).get<GetConfigLlmchatConfigUserIdGetResponses, GetConfigLlmchatConfigUserIdGetErrors, ThrowOnError>({ url: '/llmchat/config/{user_id}', ...options });

/**
 * Get Global Passthrough Headers
 *
 * Get the global passthrough headers configuration.
 *
 * Args:
 * db: Database session
 * _user: Authenticated user
 *
 * Returns:
 * GlobalConfigRead: The current global passthrough headers configuration
 *
 * Examples:
 * >>> # Test function exists and has correct name
 * >>> from mcpgateway.admin import get_global_passthrough_headers
 * >>> get_global_passthrough_headers.__name__
 * 'get_global_passthrough_headers'
 * >>> # Test it's a coroutine function
 * >>> import inspect
 * >>> inspect.iscoroutinefunction(get_global_passthrough_headers)
 * True
 */
export const getGlobalPassthroughHeadersAdminConfigPassthroughHeadersGet = <ThrowOnError extends boolean = false>(options?: Options<GetGlobalPassthroughHeadersAdminConfigPassthroughHeadersGetData, ThrowOnError>) => (options?.client ?? client).get<GetGlobalPassthroughHeadersAdminConfigPassthroughHeadersGetResponses, GetGlobalPassthroughHeadersAdminConfigPassthroughHeadersGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/config/passthrough-headers',
    ...options
});

/**
 * Update Global Passthrough Headers
 *
 * Update the global passthrough headers configuration.
 *
 * Args:
 * request: HTTP request object
 * config_update: The new configuration
 * db: Database session
 * _user: Authenticated user
 *
 * Raises:
 * HTTPException: If there is a conflict or validation error
 *
 * Returns:
 * GlobalConfigRead: The updated configuration
 *
 * Examples:
 * >>> # Test function exists and has correct name
 * >>> from mcpgateway.admin import update_global_passthrough_headers
 * >>> update_global_passthrough_headers.__name__
 * 'update_global_passthrough_headers'
 * >>> # Test it's a coroutine function
 * >>> import inspect
 * >>> inspect.iscoroutinefunction(update_global_passthrough_headers)
 * True
 */
export const updateGlobalPassthroughHeadersAdminConfigPassthroughHeadersPut = <ThrowOnError extends boolean = false>(options: Options<UpdateGlobalPassthroughHeadersAdminConfigPassthroughHeadersPutData, ThrowOnError>) => (options.client ?? client).put<UpdateGlobalPassthroughHeadersAdminConfigPassthroughHeadersPutResponses, UpdateGlobalPassthroughHeadersAdminConfigPassthroughHeadersPutErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/config/passthrough-headers',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get Configuration Settings
 *
 * Get application configuration settings grouped by category.
 *
 * Returns configuration settings with sensitive values masked.
 *
 * Args:
 * _db: Database session
 * _user: Authenticated user
 *
 * Returns:
 * Dict with configuration groups and their settings
 */
export const getConfigurationSettingsAdminConfigSettingsGet = <ThrowOnError extends boolean = false>(options?: Options<GetConfigurationSettingsAdminConfigSettingsGetData, ThrowOnError>) => (options?.client ?? client).get<GetConfigurationSettingsAdminConfigSettingsGetResponses, GetConfigurationSettingsAdminConfigSettingsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/config/settings',
    ...options
});

/**
 * Admin List Servers
 *
 * List servers for the admin UI with an option to include inactive servers.
 *
 * Args:
 * include_inactive (bool): Whether to include inactive servers.
 * db (Session): The database session dependency.
 * user (str): The authenticated user dependency.
 *
 * Returns:
 * List[ServerRead]: A list of server records.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from mcpgateway.schemas import ServerRead, ServerMetrics
 * >>>
 * >>> # Mock dependencies
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>>
 * >>> # Mock server service
 * >>> from datetime import datetime, timezone
 * >>> mock_metrics = ServerMetrics(
 * ...     total_executions=10,
 * ...     successful_executions=8,
 * ...     failed_executions=2,
 * ...     failure_rate=0.2,
 * ...     min_response_time=0.1,
 * ...     max_response_time=2.0,
 * ...     avg_response_time=0.5,
 * ...     last_execution_time=datetime.now(timezone.utc)
 * ... )
 * >>> mock_server = ServerRead(
 * ...     id="server-1",
 * ...     name="Test Server",
 * ...     description="A test server",
 * ...     icon="test-icon.png",
 * ...     created_at=datetime.now(timezone.utc),
 * ...     updated_at=datetime.now(timezone.utc),
 * ...     is_active=True,
 * ...     associated_tools=["tool1", "tool2"],
 * ...     associated_resources=[1, 2],
 * ...     associated_prompts=[1],
 * ...     metrics=mock_metrics
 * ... )
 * >>>
 * >>> # Mock the server_service.list_servers_for_user method
 * >>> original_list_servers_for_user = server_service.list_servers_for_user
 * >>> server_service.list_servers_for_user = AsyncMock(return_value=[mock_server])
 * >>>
 * >>> # Test the function
 * >>> async def test_admin_list_servers():
 * ...     result = await admin_list_servers(
 * ...         include_inactive=False,
 * ...         db=mock_db,
 * ...         user=mock_user
 * ...     )
 * ...     return len(result) > 0 and isinstance(result[0], dict)
 * >>>
 * >>> # Run the test
 * >>> asyncio.run(test_admin_list_servers())
 * True
 * >>>
 * >>> # Restore original method
 * >>> server_service.list_servers_for_user = original_list_servers_for_user
 * >>>
 * >>> # Additional test for empty server list
 * >>> server_service.list_servers_for_user = AsyncMock(return_value=[])
 * >>> async def test_admin_list_servers_empty():
 * ...     result = await admin_list_servers(
 * ...         include_inactive=True,
 * ...         db=mock_db,
 * ...         user=mock_user
 * ...     )
 * ...     return result == []
 * >>> asyncio.run(test_admin_list_servers_empty())
 * True
 * >>> server_service.list_servers_for_user = original_list_servers_for_user
 * >>>
 * >>> # Additional test for exception handling
 * >>> import pytest
 * >>> from fastapi import HTTPException
 * >>> async def test_admin_list_servers_exception():
 * ...     server_service.list_servers_for_user = AsyncMock(side_effect=Exception("Test error"))
 * ...     try:
 * ...         await admin_list_servers(False, mock_db, mock_user)
 * ...     except Exception as e:
 * ...         return str(e) == "Test error"
 * >>> asyncio.run(test_admin_list_servers_exception())
 * True
 */
export const adminListServersAdminServersGet = <ThrowOnError extends boolean = false>(options?: Options<AdminListServersAdminServersGetData, ThrowOnError>) => (options?.client ?? client).get<AdminListServersAdminServersGetResponses, AdminListServersAdminServersGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/servers',
    ...options
});

/**
 * Admin Add Server
 *
 * Add a new server via the admin UI.
 *
 * This endpoint processes form data to create a new server entry in the database.
 * It handles exceptions gracefully and logs any errors that occur during server
 * registration.
 *
 * Expects form fields:
 * - name (required): The name of the server
 * - description (optional): A description of the server's purpose
 * - icon (optional): URL or path to the server's icon
 * - associatedTools (optional, multiple values): Tools associated with this server
 * - associatedResources (optional, multiple values): Resources associated with this server
 * - associatedPrompts (optional, multiple values): Prompts associated with this server
 *
 * Args:
 * request (Request): FastAPI request containing form data.
 * db (Session): Database session dependency
 * user (str): Authenticated user dependency
 *
 * Returns:
 * JSONResponse: A JSON response indicating success or failure of the server creation operation.
 *
 * Examples:
 * >>> import asyncio
 * >>> import uuid
 * >>> from datetime import datetime
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> # Mock dependencies
 * >>> mock_db = MagicMock()
 * >>> timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
 * >>> short_uuid = str(uuid.uuid4())[:8]
 * >>> unq_ext = f"{timestamp}-{short_uuid}"
 * >>> mock_user = {"email": "test_user_" + unq_ext, "db": mock_db}
 * >>> # Mock form data for successful server creation
 * >>> form_data = FormData([
 * ...     ("name", "Test-Server-"+unq_ext ),
 * ...     ("description", "A test server"),
 * ...     ("icon", "https://raw.githubusercontent.com/github/explore/main/topics/python/python.png"),
 * ...     ("associatedTools", "tool1"),
 * ...     ("associatedTools", "tool2"),
 * ...     ("associatedResources", "resource1"),
 * ...     ("associatedResources", "resource2"),
 * ...     ("associatedPrompts", "prompt1"),
 * ...     ("associatedPrompts", "prompt2"),
 * ...     ("is_inactive_checked", "false")
 * ... ])
 * >>>
 * >>> # Mock request with form data
 * >>> mock_request = MagicMock(spec=Request)
 * >>> mock_request.form = AsyncMock(return_value=form_data)
 * >>> mock_request.scope = {"root_path": "/test"}
 * >>>
 * >>> # Mock server service
 * >>> original_register_server = server_service.register_server
 * >>> server_service.register_server = AsyncMock()
 * >>>
 * >>> # Test successful server addition
 * >>> async def test_admin_add_server_success():
 * ...     result = await admin_add_server(
 * ...         request=mock_request,
 * ...         db=mock_db,
 * ...         user=mock_user
 * ...     )
 * ...     # Accept both Successful (200) and JSONResponse (422/409) for error cases
 * ...     #print(result.status_code)
 * ...     return isinstance(result, JSONResponse) and result.status_code in (200, 409, 422, 500)
 * >>>
 * >>> asyncio.run(test_admin_add_server_success())
 * True
 * >>>
 * >>> # Test with inactive checkbox checked
 * >>> form_data_inactive = FormData([
 * ...     ("name", "Test Server"),
 * ...     ("description", "A test server"),
 * ...     ("is_inactive_checked", "true")
 * ... ])
 * >>> mock_request.form = AsyncMock(return_value=form_data_inactive)
 * >>>
 * >>> async def test_admin_add_server_inactive():
 * ...     result = await admin_add_server(mock_request, mock_db, mock_user)
 * ...     return isinstance(result, JSONResponse) and result.status_code in (200, 409, 422, 500)
 * >>>
 * >>> #asyncio.run(test_admin_add_server_inactive())
 * >>>
 * >>> # Test exception handling - should still return redirect
 * >>> async def test_admin_add_server_exception():
 * ...     server_service.register_server = AsyncMock(side_effect=Exception("Test error"))
 * ...     result = await admin_add_server(mock_request, mock_db, mock_user)
 * ...     return isinstance(result, JSONResponse) and result.status_code == 500
 * >>>
 * >>> asyncio.run(test_admin_add_server_exception())
 * True
 * >>>
 * >>> # Test with minimal form data
 * >>> form_data_minimal = FormData([("name", "Minimal Server")])
 * >>> mock_request.form = AsyncMock(return_value=form_data_minimal)
 * >>> server_service.register_server = AsyncMock()
 * >>>
 * >>> async def test_admin_add_server_minimal():
 * ...     result = await admin_add_server(mock_request, mock_db, mock_user)
 * ...     #print (result)
 * ...     #print (result.status_code)
 * ...     return isinstance(result, JSONResponse) and result.status_code==200
 * >>>
 * >>> asyncio.run(test_admin_add_server_minimal())
 * True
 * >>>
 * >>> # Restore original method
 * >>> server_service.register_server = original_register_server
 */
export const adminAddServerAdminServersPost = <ThrowOnError extends boolean = false>(options?: Options<AdminAddServerAdminServersPostData, ThrowOnError>) => (options?.client ?? client).post<AdminAddServerAdminServersPostResponses, AdminAddServerAdminServersPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/servers',
    ...options
});

/**
 * Admin Get Server
 *
 * Retrieve server details for the admin UI.
 *
 * Args:
 * server_id (str): The ID of the server to retrieve.
 * db (Session): The database session dependency.
 * user (str): The authenticated user dependency.
 *
 * Returns:
 * Dict[str, Any]: The server details.
 *
 * Raises:
 * HTTPException: If the server is not found.
 * Exception: For any other unexpected errors.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from mcpgateway.schemas import ServerRead, ServerMetrics
 * >>> from mcpgateway.services.server_service import ServerNotFoundError
 * >>> from fastapi import HTTPException
 * >>>
 * >>> # Mock dependencies
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> server_id = "test-server-1"
 * >>>
 * >>> # Mock server response
 * >>> from datetime import datetime, timezone
 * >>> mock_metrics = ServerMetrics(
 * ...     total_executions=5,
 * ...     successful_executions=4,
 * ...     failed_executions=1,
 * ...     failure_rate=0.2,
 * ...     min_response_time=0.2,
 * ...     max_response_time=1.5,
 * ...     avg_response_time=0.8,
 * ...     last_execution_time=datetime.now(timezone.utc)
 * ... )
 * >>> mock_server = ServerRead(
 * ...     id=server_id,
 * ...     name="Test Server",
 * ...     description="A test server",
 * ...     icon="test-icon.png",
 * ...     created_at=datetime.now(timezone.utc),
 * ...     updated_at=datetime.now(timezone.utc),
 * ...     is_active=True,
 * ...     associated_tools=["tool1"],
 * ...     associated_resources=[1],
 * ...     associated_prompts=[1],
 * ...     metrics=mock_metrics
 * ... )
 * >>>
 * >>> # Mock the server_service.get_server method
 * >>> original_get_server = server_service.get_server
 * >>> server_service.get_server = AsyncMock(return_value=mock_server)
 * >>>
 * >>> # Test successful retrieval
 * >>> async def test_admin_get_server_success():
 * ...     result = await admin_get_server(
 * ...         server_id=server_id,
 * ...         db=mock_db,
 * ...         user=mock_user
 * ...     )
 * ...     return isinstance(result, dict) and result.get('id') == server_id
 * >>>
 * >>> # Run the test
 * >>> asyncio.run(test_admin_get_server_success())
 * True
 * >>>
 * >>> # Test server not found scenario
 * >>> server_service.get_server = AsyncMock(side_effect=ServerNotFoundError("Server not found"))
 * >>>
 * >>> async def test_admin_get_server_not_found():
 * ...     try:
 * ...         await admin_get_server(
 * ...             server_id="nonexistent",
 * ...             db=mock_db,
 * ...             user=mock_user
 * ...         )
 * ...         return False
 * ...     except HTTPException as e:
 * ...         return e.status_code == 404
 * >>>
 * >>> # Run the not found test
 * >>> asyncio.run(test_admin_get_server_not_found())
 * True
 * >>>
 * >>> # Restore original method
 * >>> server_service.get_server = original_get_server
 */
export const adminGetServerAdminServersServerIdGet = <ThrowOnError extends boolean = false>(options: Options<AdminGetServerAdminServersServerIdGetData, ThrowOnError>) => (options.client ?? client).get<AdminGetServerAdminServersServerIdGetResponses, AdminGetServerAdminServersServerIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/servers/{server_id}',
    ...options
});

/**
 * Admin Edit Server
 *
 * Edit an existing server via the admin UI.
 *
 * This endpoint processes form data to update an existing server's properties.
 * It handles exceptions gracefully and logs any errors that occur during the
 * update operation.
 *
 * Expects form fields:
 * - id (optional): Updated UUID for the server
 * - name (optional): The updated name of the server
 * - description (optional): An updated description of the server's purpose
 * - icon (optional): Updated URL or path to the server's icon
 * - associatedTools (optional, multiple values): Updated list of tools associated with this server
 * - associatedResources (optional, multiple values): Updated list of resources associated with this server
 * - associatedPrompts (optional, multiple values): Updated list of prompts associated with this server
 *
 * Args:
 * server_id (str): The ID of the server to edit
 * request (Request): FastAPI request containing form data
 * db (Session): Database session dependency
 * user (str): Authenticated user dependency
 *
 * Returns:
 * JSONResponse: A JSON response indicating success or failure of the server update operation.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import JSONResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> server_id = "server-to-edit"
 * >>>
 * >>> # Happy path: Edit server with new name
 * >>> form_data_edit = FormData([("name", "Updated Server Name"), ("is_inactive_checked", "false")])
 * >>> mock_request_edit = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_edit.form = AsyncMock(return_value=form_data_edit)
 * >>> original_update_server = server_service.update_server
 * >>> server_service.update_server = AsyncMock()
 * >>>
 * >>> async def test_admin_edit_server_success():
 * ...     result = await admin_edit_server(server_id, mock_request_edit, mock_db, mock_user)
 * ...     return isinstance(result, JSONResponse) and result.status_code == 200 and result.body == b'{"message":"Server updated successfully!","success":true}'
 * >>>
 * >>> asyncio.run(test_admin_edit_server_success())
 * True
 * >>>
 * >>> # Error path: Simulate an exception during update
 * >>> form_data_error = FormData([("name", "Error Server")])
 * >>> mock_request_error = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_error.form = AsyncMock(return_value=form_data_error)
 * >>> server_service.update_server = AsyncMock(side_effect=Exception("Update failed"))
 * >>>
 * >>> # Restore original method
 * >>> server_service.update_server = original_update_server
 * >>> # 409 Conflict: ServerNameConflictError
 * >>> server_service.update_server = AsyncMock(side_effect=ServerNameConflictError("Name conflict"))
 * >>> async def test_admin_edit_server_conflict():
 * ...     result = await admin_edit_server(server_id, mock_request_error, mock_db, mock_user)
 * ...     return isinstance(result, JSONResponse) and result.status_code == 409 and b'Name conflict' in result.body
 * >>> asyncio.run(test_admin_edit_server_conflict())
 * True
 * >>> # 409 Conflict: IntegrityError
 * >>> from sqlalchemy.exc import IntegrityError
 * >>> server_service.update_server = AsyncMock(side_effect=IntegrityError("Integrity error", None, None))
 * >>> async def test_admin_edit_server_integrity():
 * ...     result = await admin_edit_server(server_id, mock_request_error, mock_db, mock_user)
 * ...     return isinstance(result, JSONResponse) and result.status_code == 409
 * >>> asyncio.run(test_admin_edit_server_integrity())
 * True
 * >>> # 422 Unprocessable Entity: ValidationError
 * >>> from pydantic import ValidationError, BaseModel
 * >>> from mcpgateway.schemas import ServerUpdate
 * >>> validation_error = ValidationError.from_exception_data("ServerUpdate validation error", [
 * ...     {"loc": ("name",), "msg": "Field required", "type": "missing"}
 * ... ])
 * >>> server_service.update_server = AsyncMock(side_effect=validation_error)
 * >>> async def test_admin_edit_server_validation():
 * ...     result = await admin_edit_server(server_id, mock_request_error, mock_db, mock_user)
 * ...     return isinstance(result, JSONResponse) and result.status_code == 422
 * >>> asyncio.run(test_admin_edit_server_validation())
 * True
 * >>> # 400 Bad Request: ValueError
 * >>> server_service.update_server = AsyncMock(side_effect=ValueError("Bad value"))
 * >>> async def test_admin_edit_server_valueerror():
 * ...     result = await admin_edit_server(server_id, mock_request_error, mock_db, mock_user)
 * ...     return isinstance(result, JSONResponse) and result.status_code == 400 and b'Bad value' in result.body
 * >>> asyncio.run(test_admin_edit_server_valueerror())
 * True
 * >>> # 500 Internal Server Error: ServerError
 * >>> server_service.update_server = AsyncMock(side_effect=ServerError("Server error"))
 * >>> async def test_admin_edit_server_servererror():
 * ...     result = await admin_edit_server(server_id, mock_request_error, mock_db, mock_user)
 * ...     return isinstance(result, JSONResponse) and result.status_code == 500 and b'Server error' in result.body
 * >>> asyncio.run(test_admin_edit_server_servererror())
 * True
 * >>> # 500 Internal Server Error: RuntimeError
 * >>> server_service.update_server = AsyncMock(side_effect=RuntimeError("Runtime error"))
 * >>> async def test_admin_edit_server_runtimeerror():
 * ...     result = await admin_edit_server(server_id, mock_request_error, mock_db, mock_user)
 * ...     return isinstance(result, JSONResponse) and result.status_code == 500 and b'Runtime error' in result.body
 * >>> asyncio.run(test_admin_edit_server_runtimeerror())
 * True
 * >>> # Restore original method
 * >>> server_service.update_server = original_update_server
 */
export const adminEditServerAdminServersServerIdEditPost = <ThrowOnError extends boolean = false>(options: Options<AdminEditServerAdminServersServerIdEditPostData, ThrowOnError>) => (options.client ?? client).post<AdminEditServerAdminServersServerIdEditPostResponses, AdminEditServerAdminServersServerIdEditPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/servers/{server_id}/edit',
    ...options
});

/**
 * Admin Toggle Server
 *
 * Toggle a server's active status via the admin UI.
 *
 * This endpoint processes a form request to activate or deactivate a server.
 * It expects a form field 'activate' with value "true" to activate the server
 * or "false" to deactivate it. The endpoint handles exceptions gracefully and
 * logs any errors that might occur during the status toggle operation.
 *
 * Args:
 * server_id (str): The ID of the server whose status to toggle.
 * request (Request): FastAPI request containing form data with the 'activate' field.
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * Response: A redirect to the admin dashboard catalog section with a
 * status code of 303 (See Other).
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> server_id = "server-to-toggle"
 * >>>
 * >>> # Happy path: Activate server
 * >>> form_data_activate = FormData([("activate", "true"), ("is_inactive_checked", "false")])
 * >>> mock_request_activate = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_activate.form = AsyncMock(return_value=form_data_activate)
 * >>> original_toggle_server_status = server_service.toggle_server_status
 * >>> server_service.toggle_server_status = AsyncMock()
 * >>>
 * >>> async def test_admin_toggle_server_activate():
 * ...     result = await admin_toggle_server(server_id, mock_request_activate, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "/admin#catalog" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_toggle_server_activate())
 * True
 * >>>
 * >>> # Happy path: Deactivate server
 * >>> form_data_deactivate = FormData([("activate", "false"), ("is_inactive_checked", "false")])
 * >>> mock_request_deactivate = MagicMock(spec=Request, scope={"root_path": "/api"})
 * >>> mock_request_deactivate.form = AsyncMock(return_value=form_data_deactivate)
 * >>>
 * >>> async def test_admin_toggle_server_deactivate():
 * ...     result = await admin_toggle_server(server_id, mock_request_deactivate, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "/api/admin#catalog" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_toggle_server_deactivate())
 * True
 * >>>
 * >>> # Edge case: Toggle with inactive checkbox checked
 * >>> form_data_inactive = FormData([("activate", "true"), ("is_inactive_checked", "true")])
 * >>> mock_request_inactive = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_inactive.form = AsyncMock(return_value=form_data_inactive)
 * >>>
 * >>> async def test_admin_toggle_server_inactive_checked():
 * ...     result = await admin_toggle_server(server_id, mock_request_inactive, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "/admin/?include_inactive=true#catalog" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_toggle_server_inactive_checked())
 * True
 * >>>
 * >>> # Error path: Simulate an exception during toggle
 * >>> form_data_error = FormData([("activate", "true")])
 * >>> mock_request_error = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_error.form = AsyncMock(return_value=form_data_error)
 * >>> server_service.toggle_server_status = AsyncMock(side_effect=Exception("Toggle failed"))
 * >>>
 * >>> async def test_admin_toggle_server_exception():
 * ...     result = await admin_toggle_server(server_id, mock_request_error, mock_db, mock_user)
 * ...     location_header = result.headers["location"]
 * ...     return (
 * ...         isinstance(result, RedirectResponse)
 * ...         and result.status_code == 303
 * ...         and "/admin" in location_header  # Ensure '/admin' is present
 * ...         and "error=" in location_header  # Ensure the error parameter is in the query string
 * ...         and location_header.endswith("#catalog")  # Ensure the fragment is correct
 * ...     )
 * >>>
 * >>> asyncio.run(test_admin_toggle_server_exception())
 * True
 * >>>
 * >>> # Restore original method
 * >>> server_service.toggle_server_status = original_toggle_server_status
 */
export const adminToggleServerAdminServersServerIdTogglePost = <ThrowOnError extends boolean = false>(options: Options<AdminToggleServerAdminServersServerIdTogglePostData, ThrowOnError>) => (options.client ?? client).post<AdminToggleServerAdminServersServerIdTogglePostResponses, AdminToggleServerAdminServersServerIdTogglePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/servers/{server_id}/toggle',
    ...options
});

/**
 * Admin Delete Server
 *
 * Delete a server via the admin UI.
 *
 * This endpoint removes a server from the database by its ID. It handles exceptions
 * gracefully and logs any errors that occur during the deletion process.
 *
 * Args:
 * server_id (str): The ID of the server to delete
 * request (Request): FastAPI request object (not used but required by route signature).
 * db (Session): Database session dependency
 * user (str): Authenticated user dependency
 *
 * Returns:
 * RedirectResponse: A redirect to the admin dashboard catalog section with a
 * status code of 303 (See Other)
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> server_id = "server-to-delete"
 * >>>
 * >>> # Happy path: Delete server
 * >>> form_data_delete = FormData([("is_inactive_checked", "false")])
 * >>> mock_request_delete = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_delete.form = AsyncMock(return_value=form_data_delete)
 * >>> original_delete_server = server_service.delete_server
 * >>> server_service.delete_server = AsyncMock()
 * >>>
 * >>> async def test_admin_delete_server_success():
 * ...     result = await admin_delete_server(server_id, mock_request_delete, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "/admin#catalog" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_delete_server_success())
 * True
 * >>>
 * >>> # Edge case: Delete with inactive checkbox checked
 * >>> form_data_inactive = FormData([("is_inactive_checked", "true")])
 * >>> mock_request_inactive = MagicMock(spec=Request, scope={"root_path": "/api"})
 * >>> mock_request_inactive.form = AsyncMock(return_value=form_data_inactive)
 * >>>
 * >>> async def test_admin_delete_server_inactive_checked():
 * ...     result = await admin_delete_server(server_id, mock_request_inactive, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "/api/admin/?include_inactive=true#catalog" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_delete_server_inactive_checked())
 * True
 * >>>
 * >>> # Error path: Simulate an exception during deletion
 * >>> form_data_error = FormData([])
 * >>> mock_request_error = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_error.form = AsyncMock(return_value=form_data_error)
 * >>> server_service.delete_server = AsyncMock(side_effect=Exception("Deletion failed"))
 * >>>
 * >>> async def test_admin_delete_server_exception():
 * ...     result = await admin_delete_server(server_id, mock_request_error, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "#catalog" in result.headers["location"] and "error=" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_delete_server_exception())
 * True
 * >>>
 * >>> # Restore original method
 * >>> server_service.delete_server = original_delete_server
 */
export const adminDeleteServerAdminServersServerIdDeletePost = <ThrowOnError extends boolean = false>(options: Options<AdminDeleteServerAdminServersServerIdDeletePostData, ThrowOnError>) => (options.client ?? client).post<AdminDeleteServerAdminServersServerIdDeletePostResponses, AdminDeleteServerAdminServersServerIdDeletePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/servers/{server_id}/delete',
    ...options
});

/**
 * Admin List Resources
 *
 * List resources for the admin UI with an option to include inactive resources.
 *
 * This endpoint retrieves a list of resources from the database, optionally including
 * those that are inactive. The inactive filter is useful for administrators who need
 * to view or manage resources that have been deactivated but not deleted.
 *
 * Args:
 * include_inactive (bool): Whether to include inactive resources in the results.
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * List[ResourceRead]: A list of resource records formatted with by_alias=True.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from mcpgateway.schemas import ResourceRead, ResourceMetrics
 * >>> from datetime import datetime, timezone
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>>
 * >>> # Mock resource data
 * >>> mock_resource = ResourceRead(
 * ...     id=1,
 * ...     uri="test://resource/1",
 * ...     name="Test Resource",
 * ...     description="A test resource",
 * ...     mime_type="text/plain",
 * ...     size=100,
 * ...     created_at=datetime.now(timezone.utc),
 * ...     updated_at=datetime.now(timezone.utc),
 * ...     is_active=True,
 * ...     metrics=ResourceMetrics(
 * ...         total_executions=5, successful_executions=5, failed_executions=0,
 * ...         failure_rate=0.0, min_response_time=0.1, max_response_time=0.5,
 * ...         avg_response_time=0.3, last_execution_time=datetime.now(timezone.utc)
 * ...     ),
 * ...     tags=[]
 * ... )
 * >>>
 * >>> # Mock the resource_service.list_resources_for_user method
 * >>> original_list_resources_for_user = resource_service.list_resources_for_user
 * >>> resource_service.list_resources_for_user = AsyncMock(return_value=[mock_resource])
 * >>>
 * >>> # Test listing active resources
 * >>> async def test_admin_list_resources_active():
 * ...     result = await admin_list_resources(include_inactive=False, db=mock_db, user=mock_user)
 * ...     return len(result) > 0 and isinstance(result[0], dict) and result[0]['name'] == "Test Resource"
 * >>>
 * >>> asyncio.run(test_admin_list_resources_active())
 * True
 * >>>
 * >>> # Test listing with inactive resources (if mock includes them)
 * >>> mock_inactive_resource = ResourceRead(
 * ...     id=2, uri="test://resource/2", name="Inactive Resource",
 * ...     description="Another test", mime_type="application/json", size=50,
 * ...     created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc),
 * ...     is_active=False, metrics=ResourceMetrics(
 * ...         total_executions=0, successful_executions=0, failed_executions=0,
 * ...         failure_rate=0.0, min_response_time=0.0, max_response_time=0.0,
 * ...         avg_response_time=0.0, last_execution_time=None),
 * ...     tags=[]
 * ... )
 * >>> resource_service.list_resources_for_user = AsyncMock(return_value=[mock_resource, mock_inactive_resource])
 * >>> async def test_admin_list_resources_all():
 * ...     result = await admin_list_resources(include_inactive=True, db=mock_db, user=mock_user)
 * ...     return len(result) == 2 and not result[1]['isActive']
 * >>>
 * >>> asyncio.run(test_admin_list_resources_all())
 * True
 * >>>
 * >>> # Test empty list
 * >>> resource_service.list_resources_for_user = AsyncMock(return_value=[])
 * >>> async def test_admin_list_resources_empty():
 * ...     result = await admin_list_resources(include_inactive=False, db=mock_db, user=mock_user)
 * ...     return result == []
 * >>>
 * >>> asyncio.run(test_admin_list_resources_empty())
 * True
 * >>>
 * >>> # Test exception handling
 * >>> resource_service.list_resources_for_user = AsyncMock(side_effect=Exception("Resource list error"))
 * >>> async def test_admin_list_resources_exception():
 * ...     try:
 * ...         await admin_list_resources(False, mock_db, mock_user)
 * ...         return False
 * ...     except Exception as e:
 * ...         return str(e) == "Resource list error"
 * >>>
 * >>> asyncio.run(test_admin_list_resources_exception())
 * True
 * >>>
 * >>> # Restore original method
 * >>> resource_service.list_resources_for_user = original_list_resources_for_user
 */
export const adminListResourcesAdminResourcesGet = <ThrowOnError extends boolean = false>(options?: Options<AdminListResourcesAdminResourcesGetData, ThrowOnError>) => (options?.client ?? client).get<AdminListResourcesAdminResourcesGetResponses, AdminListResourcesAdminResourcesGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/resources',
    ...options
});

/**
 * Admin Add Resource
 *
 * Add a resource via the admin UI.
 *
 * Expects form fields:
 * - uri
 * - name
 * - description (optional)
 * - mime_type (optional)
 * - content
 *
 * Args:
 * request: FastAPI request containing form data.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * A redirect response to the admin dashboard.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> form_data = FormData([
 * ...     ("uri", "test://resource1"),
 * ...     ("name", "Test Resource"),
 * ...     ("description", "A test resource"),
 * ...     ("mimeType", "text/plain"),
 * ...     ("template", ""),
 * ...     ("content", "Sample content"),
 * ... ])
 * >>> mock_request = MagicMock(spec=Request)
 * >>> mock_request.form = AsyncMock(return_value=form_data)
 * >>> mock_request.scope = {"root_path": ""}
 * >>>
 * >>> original_register_resource = resource_service.register_resource
 * >>> resource_service.register_resource = AsyncMock()
 * >>>
 * >>> async def test_admin_add_resource():
 * ...     response = await admin_add_resource(mock_request, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 200 and response.body.decode() == '{"message":"Add resource registered successfully!","success":true}'
 * >>>
 * >>> import asyncio; asyncio.run(test_admin_add_resource())
 * True
 * >>> resource_service.register_resource = original_register_resource
 */
export const adminAddResourceAdminResourcesPost = <ThrowOnError extends boolean = false>(options?: Options<AdminAddResourceAdminResourcesPostData, ThrowOnError>) => (options?.client ?? client).post<AdminAddResourceAdminResourcesPostResponses, AdminAddResourceAdminResourcesPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/resources',
    ...options
});

/**
 * Admin List Prompts
 *
 * List prompts for the admin UI with an option to include inactive prompts.
 *
 * This endpoint retrieves a list of prompts from the database, optionally including
 * those that are inactive. The inactive filter helps administrators see and manage
 * prompts that have been deactivated but not deleted from the system.
 *
 * Args:
 * include_inactive (bool): Whether to include inactive prompts in the results.
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * List[PromptRead]: A list of prompt records formatted with by_alias=True.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from mcpgateway.schemas import PromptRead, PromptMetrics
 * >>> from datetime import datetime, timezone
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>>
 * >>> # Mock prompt data
 * >>> mock_prompt = PromptRead(
 * ...     id=1,
 * ...     name="Test Prompt",
 * ...     description="A test prompt",
 * ...     template="Hello {{name}}!",
 * ...     arguments=[{"name": "name", "type": "string"}],
 * ...     created_at=datetime.now(timezone.utc),
 * ...     updated_at=datetime.now(timezone.utc),
 * ...     is_active=True,
 * ...     metrics=PromptMetrics(
 * ...         total_executions=10, successful_executions=10, failed_executions=0,
 * ...         failure_rate=0.0, min_response_time=0.01, max_response_time=0.1,
 * ...         avg_response_time=0.05, last_execution_time=datetime.now(timezone.utc)
 * ...     ),
 * ...     tags=[]
 * ... )
 * >>>
 * >>> # Mock the prompt_service.list_prompts_for_user method
 * >>> original_list_prompts_for_user = prompt_service.list_prompts_for_user
 * >>> prompt_service.list_prompts_for_user = AsyncMock(return_value=[mock_prompt])
 * >>>
 * >>> # Test listing active prompts
 * >>> async def test_admin_list_prompts_active():
 * ...     result = await admin_list_prompts(include_inactive=False, db=mock_db, user=mock_user)
 * ...     return len(result) > 0 and isinstance(result[0], dict) and result[0]['name'] == "Test Prompt"
 * >>>
 * >>> asyncio.run(test_admin_list_prompts_active())
 * True
 * >>>
 * >>> # Test listing with inactive prompts (if mock includes them)
 * >>> mock_inactive_prompt = PromptRead(
 * ...     id=2, name="Inactive Prompt", description="Another test", template="Bye!",
 * ...     arguments=[], created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc),
 * ...     is_active=False, metrics=PromptMetrics(
 * ...         total_executions=0, successful_executions=0, failed_executions=0,
 * ...         failure_rate=0.0, min_response_time=0.0, max_response_time=0.0,
 * ...         avg_response_time=0.0, last_execution_time=None
 * ...     ),
 * ...     tags=[]
 * ... )
 * >>> prompt_service.list_prompts_for_user = AsyncMock(return_value=[mock_prompt, mock_inactive_prompt])
 * >>> async def test_admin_list_prompts_all():
 * ...     result = await admin_list_prompts(include_inactive=True, db=mock_db, user=mock_user)
 * ...     return len(result) == 2 and not result[1]['isActive']
 * >>>
 * >>> asyncio.run(test_admin_list_prompts_all())
 * True
 * >>>
 * >>> # Test empty list
 * >>> prompt_service.list_prompts_for_user = AsyncMock(return_value=[])
 * >>> async def test_admin_list_prompts_empty():
 * ...     result = await admin_list_prompts(include_inactive=False, db=mock_db, user=mock_user)
 * ...     return result == []
 * >>>
 * >>> asyncio.run(test_admin_list_prompts_empty())
 * True
 * >>>
 * >>> # Test exception handling
 * >>> prompt_service.list_prompts_for_user = AsyncMock(side_effect=Exception("Prompt list error"))
 * >>> async def test_admin_list_prompts_exception():
 * ...     try:
 * ...         await admin_list_prompts(False, mock_db, mock_user)
 * ...         return False
 * ...     except Exception as e:
 * ...         return str(e) == "Prompt list error"
 * >>>
 * >>> asyncio.run(test_admin_list_prompts_exception())
 * True
 * >>>
 * >>> # Restore original method
 * >>> prompt_service.list_prompts_for_user = original_list_prompts_for_user
 */
export const adminListPromptsAdminPromptsGet = <ThrowOnError extends boolean = false>(options?: Options<AdminListPromptsAdminPromptsGetData, ThrowOnError>) => (options?.client ?? client).get<AdminListPromptsAdminPromptsGetResponses, AdminListPromptsAdminPromptsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/prompts',
    ...options
});

/**
 * Admin Add Prompt
 *
 * Add a prompt via the admin UI.
 *
 * Expects form fields:
 * - name
 * - description (optional)
 * - template
 * - arguments (as a JSON string representing a list)
 *
 * Args:
 * request: FastAPI request containing form data.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * A redirect response to the admin dashboard.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> form_data = FormData([
 * ...     ("name", "Test Prompt"),
 * ...     ("description", "A test prompt"),
 * ...     ("template", "Hello {{name}}!"),
 * ...     ("arguments", '[{"name": "name", "type": "string"}]'),
 * ... ])
 * >>> mock_request = MagicMock(spec=Request)
 * >>> mock_request.form = AsyncMock(return_value=form_data)
 * >>> mock_request.scope = {"root_path": ""}
 * >>>
 * >>> original_register_prompt = prompt_service.register_prompt
 * >>> prompt_service.register_prompt = AsyncMock()
 * >>>
 * >>> async def test_admin_add_prompt():
 * ...     response = await admin_add_prompt(mock_request, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 200 and response.body == b'{"message":"Prompt registered successfully!","success":true}'
 * >>>
 * >>> asyncio.run(test_admin_add_prompt())
 * True
 *
 * >>> prompt_service.register_prompt = original_register_prompt
 */
export const adminAddPromptAdminPromptsPost = <ThrowOnError extends boolean = false>(options?: Options<AdminAddPromptAdminPromptsPostData, ThrowOnError>) => (options?.client ?? client).post<AdminAddPromptAdminPromptsPostResponses, AdminAddPromptAdminPromptsPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/prompts',
    ...options
});

/**
 * Admin List Gateways
 *
 * List gateways for the admin UI with an option to include inactive gateways.
 *
 * This endpoint retrieves a list of gateways from the database, optionally
 * including those that are inactive. The inactive filter allows administrators
 * to view and manage gateways that have been deactivated but not deleted.
 *
 * Args:
 * include_inactive (bool): Whether to include inactive gateways in the results.
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * List[GatewayRead]: A list of gateway records formatted with by_alias=True.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from mcpgateway.schemas import GatewayRead
 * >>> from datetime import datetime, timezone
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>>
 * >>> # Mock gateway data
 * >>> mock_gateway = GatewayRead(
 * ...     id="gateway-1",
 * ...     name="Test Gateway",
 * ...     url="http://test.com",
 * ...     description="A test gateway",
 * ...     transport="HTTP",
 * ...     created_at=datetime.now(timezone.utc),
 * ...     updated_at=datetime.now(timezone.utc),
 * ...     is_active=True,
 * ...     auth_type=None, auth_username=None, auth_password=None, auth_token=None,
 * ...     auth_header_key=None, auth_header_value=None,
 * ...     slug="test-gateway"
 * ... )
 * >>>
 * >>> # Mock the gateway_service.list_gateways_for_user method
 * >>> original_list_gateways = gateway_service.list_gateways_for_user
 * >>> gateway_service.list_gateways_for_user = AsyncMock(return_value=[mock_gateway])
 * >>>
 * >>> # Test listing active gateways
 * >>> async def test_admin_list_gateways_active():
 * ...     result = await admin_list_gateways(include_inactive=False, db=mock_db, user=mock_user)
 * ...     return len(result) > 0 and isinstance(result[0], dict) and result[0]['name'] == "Test Gateway"
 * >>>
 * >>> asyncio.run(test_admin_list_gateways_active())
 * True
 * >>>
 * >>> # Test listing with inactive gateways (if mock includes them)
 * >>> mock_inactive_gateway = GatewayRead(
 * ...     id="gateway-2", name="Inactive Gateway", url="http://inactive.com",
 * ...     description="Another test", transport="HTTP", created_at=datetime.now(timezone.utc),
 * ...     updated_at=datetime.now(timezone.utc), enabled=False,
 * ...     auth_type=None, auth_username=None, auth_password=None, auth_token=None,
 * ...     auth_header_key=None, auth_header_value=None,
 * ...     slug="test-gateway"
 * ... )
 * >>> gateway_service.list_gateways_for_user = AsyncMock(return_value=[
 * ...     mock_gateway, # Return the GatewayRead objects, not pre-dumped dicts
 * ...     mock_inactive_gateway # Return the GatewayRead objects, not pre-dumped dicts
 * ... ])
 * >>> async def test_admin_list_gateways_all():
 * ...     result = await admin_list_gateways(include_inactive=True, db=mock_db, user=mock_user)
 * ...     return len(result) == 2 and not result[1]['enabled']
 * >>>
 * >>> asyncio.run(test_admin_list_gateways_all())
 * True
 * >>>
 * >>> # Test empty list
 * >>> gateway_service.list_gateways_for_user = AsyncMock(return_value=[])
 * >>> async def test_admin_list_gateways_empty():
 * ...     result = await admin_list_gateways(include_inactive=False, db=mock_db, user=mock_user)
 * ...     return result == []
 * >>>
 * >>> asyncio.run(test_admin_list_gateways_empty())
 * True
 * >>>
 * >>> # Test exception handling
 * >>> gateway_service.list_gateways_for_user = AsyncMock(side_effect=Exception("Gateway list error"))
 * >>> async def test_admin_list_gateways_exception():
 * ...     try:
 * ...         await admin_list_gateways(False, mock_db, mock_user)
 * ...         return False
 * ...     except Exception as e:
 * ...         return str(e) == "Gateway list error"
 * >>>
 * >>> asyncio.run(test_admin_list_gateways_exception())
 * True
 * >>>
 * >>> # Restore original method
 * >>> gateway_service.list_gateways_for_user = original_list_gateways
 */
export const adminListGatewaysAdminGatewaysGet = <ThrowOnError extends boolean = false>(options?: Options<AdminListGatewaysAdminGatewaysGetData, ThrowOnError>) => (options?.client ?? client).get<AdminListGatewaysAdminGatewaysGetResponses, AdminListGatewaysAdminGatewaysGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/gateways',
    ...options
});

/**
 * Admin Add Gateway
 *
 * Add a gateway via the admin UI.
 *
 * Expects form fields:
 * - name
 * - url
 * - description (optional)
 * - tags (optional, comma-separated)
 *
 * Args:
 * request: FastAPI request containing form data.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * A redirect response to the admin dashboard.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import JSONResponse
 * >>> from starlette.datastructures import FormData
 * >>> from mcpgateway.services.gateway_service import GatewayConnectionError
 * >>> from pydantic import ValidationError
 * >>> from sqlalchemy.exc import IntegrityError
 * >>> from mcpgateway.utils.error_formatter import ErrorFormatter
 * >>> import json # Added import for json.loads
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>>
 * >>> # Happy path: Add a new gateway successfully with basic auth details
 * >>> form_data_success = FormData([
 * ...     ("name", "New Gateway"),
 * ...     ("url", "http://new.gateway.com"),
 * ...     ("transport", "HTTP"),
 * ...     ("auth_type", "basic"), # Valid auth_type
 * ...     ("auth_username", "user"), # Required for basic auth
 * ...     ("auth_password", "pass")  # Required for basic auth
 * ... ])
 * >>> mock_request_success = MagicMock(spec=Request)
 * >>> mock_request_success.form = AsyncMock(return_value=form_data_success)
 * >>> original_register_gateway = gateway_service.register_gateway
 * >>> gateway_service.register_gateway = AsyncMock()
 * >>>
 * >>> async def test_admin_add_gateway_success():
 * ...     response = await admin_add_gateway(mock_request_success, mock_db, mock_user)
 * ...     # Corrected: Access body and then parse JSON
 * ...     return isinstance(response, JSONResponse) and response.status_code == 200 and json.loads(response.body)["success"] is True
 * >>>
 * >>> asyncio.run(test_admin_add_gateway_success())
 * True
 * >>>
 * >>> # Error path: Gateway connection error
 * >>> form_data_conn_error = FormData([("name", "Bad Gateway"), ("url", "http://bad.com"), ("auth_type", "bearer"), ("auth_token", "abc")]) # Added auth_type and token
 * >>> mock_request_conn_error = MagicMock(spec=Request)
 * >>> mock_request_conn_error.form = AsyncMock(return_value=form_data_conn_error)
 * >>> gateway_service.register_gateway = AsyncMock(side_effect=GatewayConnectionError("Connection failed"))
 * >>>
 * >>> async def test_admin_add_gateway_connection_error():
 * ...     response = await admin_add_gateway(mock_request_conn_error, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 502 and json.loads(response.body)["success"] is False
 * >>>
 * >>> asyncio.run(test_admin_add_gateway_connection_error())
 * True
 * >>>
 * >>> # Error path: Validation error (e.g., missing name)
 * >>> form_data_validation_error = FormData([("url", "http://no-name.com"), ("auth_type", "headers"), ("auth_header_key", "X-Key"), ("auth_header_value", "val")]) # 'name' is missing, added auth_type
 * >>> mock_request_validation_error = MagicMock(spec=Request)
 * >>> mock_request_validation_error.form = AsyncMock(return_value=form_data_validation_error)
 * >>> # No need to mock register_gateway, ValidationError happens during GatewayCreate()
 * >>>
 * >>> async def test_admin_add_gateway_validation_error():
 * ...     response = await admin_add_gateway(mock_request_validation_error, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 422 and json.loads(response.body.decode())["success"] is False
 * >>>
 * >>> asyncio.run(test_admin_add_gateway_validation_error())
 * True
 * >>>
 * >>> # Error path: Integrity error (e.g., duplicate name)
 * >>> from sqlalchemy.exc import IntegrityError
 * >>> form_data_integrity_error = FormData([("name", "Duplicate Gateway"), ("url", "http://duplicate.com"), ("auth_type", "basic"), ("auth_username", "u"), ("auth_password", "p")]) # Added auth_type and creds
 * >>> mock_request_integrity_error = MagicMock(spec=Request)
 * >>> mock_request_integrity_error.form = AsyncMock(return_value=form_data_integrity_error)
 * >>> gateway_service.register_gateway = AsyncMock(side_effect=IntegrityError("Duplicate entry", {}, {}))
 * >>>
 * >>> async def test_admin_add_gateway_integrity_error():
 * ...     response = await admin_add_gateway(mock_request_integrity_error, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 409 and json.loads(response.body.decode())["success"] is False
 * >>>
 * >>> asyncio.run(test_admin_add_gateway_integrity_error())
 * True
 * >>>
 * >>> # Error path: Generic RuntimeError
 * >>> form_data_runtime_error = FormData([("name", "Runtime Error Gateway"), ("url", "http://runtime.com"), ("auth_type", "basic"), ("auth_username", "u"), ("auth_password", "p")]) # Added auth_type and creds
 * >>> mock_request_runtime_error = MagicMock(spec=Request)
 * >>> mock_request_runtime_error.form = AsyncMock(return_value=form_data_runtime_error)
 * >>> gateway_service.register_gateway = AsyncMock(side_effect=RuntimeError("Unexpected runtime issue"))
 * >>>
 * >>> async def test_admin_add_gateway_runtime_error():
 * ...     response = await admin_add_gateway(mock_request_runtime_error, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 500 and json.loads(response.body.decode())["success"] is False
 * >>>
 * >>> asyncio.run(test_admin_add_gateway_runtime_error())
 * True
 * >>>
 * >>> # Restore original method
 * >>> gateway_service.register_gateway = original_register_gateway
 */
export const adminAddGatewayAdminGatewaysPost = <ThrowOnError extends boolean = false>(options?: Options<AdminAddGatewayAdminGatewaysPostData, ThrowOnError>) => (options?.client ?? client).post<AdminAddGatewayAdminGatewaysPostResponses, AdminAddGatewayAdminGatewaysPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/gateways',
    ...options
});

/**
 * Admin List Gateway Ids
 *
 * Return a JSON object containing a list of all gateway IDs.
 *
 * This endpoint is used by the admin UI to support the "Select All" action
 * for gateways. It returns a simple JSON payload with a single key
 * `gateway_ids` containing an array of gateway identifiers.
 *
 * Args:
 * include_inactive (bool): Whether to include inactive gateways in the results.
 * db (Session): Database session dependency.
 * user: Authenticated user dependency.
 *
 * Returns:
 * Dict[str, Any]: JSON object containing the `gateway_ids` list and metadata.
 */
export const adminListGatewayIdsAdminGatewaysIdsGet = <ThrowOnError extends boolean = false>(options?: Options<AdminListGatewayIdsAdminGatewaysIdsGetData, ThrowOnError>) => (options?.client ?? client).get<AdminListGatewayIdsAdminGatewaysIdsGetResponses, AdminListGatewayIdsAdminGatewaysIdsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/gateways/ids',
    ...options
});

/**
 * Admin Toggle Gateway
 *
 * Toggle the active status of a gateway via the admin UI.
 *
 * This endpoint allows an admin to toggle the active status of a gateway.
 * It expects a form field 'activate' with a value of "true" or "false" to
 * determine the new status of the gateway.
 *
 * Args:
 * gateway_id (str): The ID of the gateway to toggle.
 * request (Request): The FastAPI request object containing form data.
 * db (Session): The database session dependency.
 * user (str): The authenticated user dependency.
 *
 * Returns:
 * RedirectResponse: A redirect response to the admin dashboard with a
 * status code of 303 (See Other).
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> gateway_id = "gateway-to-toggle"
 * >>>
 * >>> # Happy path: Activate gateway
 * >>> form_data_activate = FormData([("activate", "true"), ("is_inactive_checked", "false")])
 * >>> mock_request_activate = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_activate.form = AsyncMock(return_value=form_data_activate)
 * >>> original_toggle_gateway_status = gateway_service.toggle_gateway_status
 * >>> gateway_service.toggle_gateway_status = AsyncMock()
 * >>>
 * >>> async def test_admin_toggle_gateway_activate():
 * ...     result = await admin_toggle_gateway(gateway_id, mock_request_activate, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "/admin#gateways" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_toggle_gateway_activate())
 * True
 * >>>
 * >>> # Happy path: Deactivate gateway
 * >>> form_data_deactivate = FormData([("activate", "false"), ("is_inactive_checked", "false")])
 * >>> mock_request_deactivate = MagicMock(spec=Request, scope={"root_path": "/api"})
 * >>> mock_request_deactivate.form = AsyncMock(return_value=form_data_deactivate)
 * >>>
 * >>> async def test_admin_toggle_gateway_deactivate():
 * ...     result = await admin_toggle_gateway(gateway_id, mock_request_deactivate, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "/api/admin#gateways" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_toggle_gateway_deactivate())
 * True
 * >>>
 * >>> # Error path: Simulate an exception during toggle
 * >>> form_data_error = FormData([("activate", "true")])
 * >>> mock_request_error = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_error.form = AsyncMock(return_value=form_data_error)
 * >>> gateway_service.toggle_gateway_status = AsyncMock(side_effect=Exception("Toggle failed"))
 * >>>
 * >>> async def test_admin_toggle_gateway_exception():
 * ...     result = await admin_toggle_gateway(gateway_id, mock_request_error, mock_db, mock_user)
 * ...     location_header = result.headers["location"]
 * ...     return (
 * ...         isinstance(result, RedirectResponse)
 * ...         and result.status_code == 303
 * ...         and "/admin" in location_header  # Ensure '/admin' is present
 * ...         and "error=" in location_header  # Ensure the error parameter is in the query string
 * ...         and location_header.endswith("#gateways")  # Ensure the fragment is correct
 * ...     )
 * >>>
 * >>> asyncio.run(test_admin_toggle_gateway_exception())
 * True
 * >>> # Restore original method
 * >>> gateway_service.toggle_gateway_status = original_toggle_gateway_status
 */
export const adminToggleGatewayAdminGatewaysGatewayIdTogglePost = <ThrowOnError extends boolean = false>(options: Options<AdminToggleGatewayAdminGatewaysGatewayIdTogglePostData, ThrowOnError>) => (options.client ?? client).post<AdminToggleGatewayAdminGatewaysGatewayIdTogglePostResponses, AdminToggleGatewayAdminGatewaysGatewayIdTogglePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/gateways/{gateway_id}/toggle',
    ...options
});

/**
 * Admin Home
 *
 * Render the admin dashboard HTML page.
 *
 * This endpoint serves as the main entry point to the admin UI. It fetches data for
 * servers, tools, resources, prompts, gateways, and roots from their respective
 * services, then renders the admin dashboard template with this data.
 *
 * Supports optional `team_id` query param to scope the returned data to a team.
 * If `team_id` is provided and email-based team management is enabled, we
 * validate the user is a member of that team. We attempt to pass team_id into
 * service listing functions (preferred). If the service API does not accept a
 * team_id parameter we fall back to post-filtering the returned items.
 *
 * The endpoint also sets a JWT token as a cookie for authentication in subsequent
 * requests. This token is HTTP-only for security reasons.
 *
 * Args:
 * request (Request): FastAPI request object.
 * team_id (Optional[str]): Optional team ID to filter data by team.
 * include_inactive (bool): Whether to include inactive items in all listings.
 * db (Session): Database session dependency.
 * user (dict): Authenticated user context with permissions.
 *
 * Returns:
 * Any: Rendered HTML template for the admin dashboard.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock, patch
 * >>> from fastapi import Request
 * >>> from fastapi.responses import HTMLResponse
 * >>> from mcpgateway.schemas import ServerRead, ToolRead, ResourceRead, PromptRead, GatewayRead, ServerMetrics, ToolMetrics, ResourceMetrics, PromptMetrics
 * >>> from datetime import datetime, timezone
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "admin_user", "db": mock_db}
 * >>>
 * >>> # Mock services to return empty lists for simplicity in doctest
 * >>> original_list_servers_for_user = server_service.list_servers_for_user
 * >>> original_list_tools_for_user = tool_service.list_tools_for_user
 * >>> original_list_resources_for_user = resource_service.list_resources_for_user
 * >>> original_list_prompts_for_user = prompt_service.list_prompts_for_user
 * >>> original_list_gateways = gateway_service.list_gateways
 * >>> original_list_roots = root_service.list_roots
 * >>>
 * >>> server_service.list_servers_for_user = AsyncMock(return_value=[])
 * >>> tool_service.list_tools_for_user = AsyncMock(return_value=[])
 * >>> resource_service.list_resources_for_user = AsyncMock(return_value=[])
 * >>> prompt_service.list_prompts_for_user = AsyncMock(return_value=[])
 * >>> gateway_service.list_gateways = AsyncMock(return_value=[])
 * >>> root_service.list_roots = AsyncMock(return_value=[])
 * >>>
 * >>> # Mock request and template rendering
 * >>> mock_request = MagicMock(spec=Request, scope={"root_path": "/admin_prefix"})
 * >>> mock_request.app.state.templates = MagicMock()
 * >>> mock_template_response = HTMLResponse("<html>Admin UI</html>")
 * >>> mock_request.app.state.templates.TemplateResponse.return_value = mock_template_response
 * >>>
 * >>> # Test basic rendering
 * >>> async def test_admin_ui_basic_render():
 * ...     response = await admin_ui(mock_request, None, False, mock_db, mock_user)
 * ...     return isinstance(response, HTMLResponse) and response.status_code == 200
 * >>>
 * >>> asyncio.run(test_admin_ui_basic_render())
 * True
 * >>>
 * >>> # Test with include_inactive=True
 * >>> async def test_admin_ui_include_inactive():
 * ...     response = await admin_ui(mock_request, None, True, mock_db, mock_user)
 * ...     # Verify list methods were called with include_inactive=True
 * ...     server_service.list_servers_for_user.assert_called_with(mock_db, mock_user["email"], include_inactive=True)
 * ...     return isinstance(response, HTMLResponse)
 * >>>
 * >>> asyncio.run(test_admin_ui_include_inactive())
 * True
 * >>>
 * >>> # Test with populated data (mocking a few items)
 * >>> mock_server = ServerRead(id="s1", name="S1", description="d", created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc), is_active=True, associated_tools=[], associated_resources=[], associated_prompts=[], icon="i", metrics=ServerMetrics(total_executions=0, successful_executions=0, failed_executions=0, failure_rate=0.0, min_response_time=0.0, max_response_time=0.0, avg_response_time=0.0, last_execution_time=None))
 * >>> mock_tool = ToolRead(
 * ...     id="t1", name="T1", original_name="T1", url="http://t1.com", description="d",
 * ...     created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc),
 * ...     enabled=True, reachable=True, gateway_slug="default", custom_name_slug="t1",
 * ...     request_type="GET", integration_type="MCP", headers={}, input_schema={},
 * ...     annotations={}, jsonpath_filter=None, auth=None, execution_count=0,
 * ...     metrics=ToolMetrics(
 * ...         total_executions=0, successful_executions=0, failed_executions=0,
 * ...         failure_rate=0.0, min_response_time=0.0, max_response_time=0.0,
 * ...         avg_response_time=0.0, last_execution_time=None
 * ...     ),
 * ...     gateway_id=None,
 * ...     customName="T1",
 * ...     tags=[]
 * ... )
 * >>> server_service.list_servers_for_user = AsyncMock(return_value=[mock_server])
 * >>> tool_service.list_tools_for_user = AsyncMock(return_value=[mock_tool])
 * >>>
 * >>> async def test_admin_ui_with_data():
 * ...     response = await admin_ui(mock_request, None, False, mock_db, mock_user)
 * ...     # Check if template context was populated (indirectly via mock calls)
 * ...     assert mock_request.app.state.templates.TemplateResponse.call_count >= 1
 * ...     context = mock_request.app.state.templates.TemplateResponse.call_args[0][2]
 * ...     return len(context['servers']) == 1 and len(context['tools']) == 1
 * >>>
 * >>> asyncio.run(test_admin_ui_with_data())
 * True
 * >>>
 * >>> from unittest.mock import AsyncMock, patch
 * >>> import logging
 * >>>
 * >>> server_service.list_servers_for_user = AsyncMock(side_effect=Exception("DB error"))
 * >>>
 * >>> async def test_admin_ui_exception_handled():
 * ...     with patch("mcpgateway.admin.LOGGER.exception") as mock_log:
 * ...         response = await admin_ui(
 * ...             request=mock_request,
 * ...             team_id=None,
 * ...             include_inactive=False,
 * ...             db=mock_db,
 * ...             user=mock_user
 * ...         )
 * ...         # Check that the response rendered correctly
 * ...         ok_response = isinstance(response, HTMLResponse) and response.status_code == 200
 * ...         # Check that the exception was logged
 * ...         log_called = mock_log.called
 * ...         # Optionally, you can even inspect the message if you want
 * ...         return ok_response and log_called
 * >>>
 * >>> asyncio.run(test_admin_ui_exception_handled())
 * True
 * >>>
 * >>> # Restore original methods
 * >>> server_service.list_servers_for_user = original_list_servers_for_user
 * >>> tool_service.list_tools_for_user = original_list_tools_for_user
 * >>> resource_service.list_resources_for_user = original_list_resources_for_user
 * >>> prompt_service.list_prompts_for_user = original_list_prompts_for_user
 * >>> gateway_service.list_gateways = original_list_gateways
 * >>> root_service.list_roots = original_list_roots
 */
export const adminHomeAdminGet = <ThrowOnError extends boolean = false>(options?: Options<AdminHomeAdminGetData, ThrowOnError>) => (options?.client ?? client).get<AdminHomeAdminGetResponses, AdminHomeAdminGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/',
    ...options
});

/**
 * Admin Login Page
 *
 * Render the admin login page.
 *
 * This endpoint serves the login form for email-based authentication.
 * If email auth is disabled, redirects to the main admin page.
 *
 * Args:
 * request (Request): FastAPI request object.
 *
 * Returns:
 * Response: Rendered HTML or redirect response.
 *
 * Examples:
 * >>> from fastapi import Request
 * >>> from fastapi.responses import HTMLResponse
 * >>> from unittest.mock import MagicMock
 * >>>
 * >>> # Mock request
 * >>> mock_request = MagicMock(spec=Request)
 * >>> mock_request.scope = {"root_path": "/test"}
 * >>> mock_request.app.state.templates = MagicMock()
 * >>> mock_response = HTMLResponse("<html>Login</html>")
 * >>> mock_request.app.state.templates.TemplateResponse.return_value = mock_response
 * >>>
 * >>> import asyncio
 * >>> async def test_login_page():
 * ...     response = await admin_login_page(mock_request)
 * ...     return isinstance(response, HTMLResponse)
 * >>>
 * >>> asyncio.run(test_login_page())
 * True
 */
export const adminLoginPageAdminLoginGet = <ThrowOnError extends boolean = false>(options?: Options<AdminLoginPageAdminLoginGetData, ThrowOnError>) => (options?.client ?? client).get<AdminLoginPageAdminLoginGetResponses, unknown, ThrowOnError>({ url: '/admin/login', ...options });

/**
 * Admin Login Handler
 *
 * Handle admin login form submission.
 *
 * This endpoint processes the email/password login form, authenticates the user,
 * sets the JWT cookie, and redirects to the admin panel or back to login with error.
 *
 * Args:
 * request (Request): FastAPI request object.
 * db (Session): Database session dependency.
 *
 * Returns:
 * RedirectResponse: Redirect to admin panel on success or login page on failure.
 *
 * Examples:
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from unittest.mock import MagicMock, AsyncMock
 * >>>
 * >>> # Mock request with form data
 * >>> mock_request = MagicMock(spec=Request)
 * >>> mock_request.scope = {"root_path": "/test"}
 * >>> mock_form = {"email": "admin@example.com", "password": "changeme"}
 * >>> mock_request.form = AsyncMock(return_value=mock_form)
 * >>>
 * >>> mock_db = MagicMock()
 * >>>
 * >>> import asyncio
 * >>> async def test_login_handler():
 * ...     try:
 * ...         response = await admin_login_handler(mock_request, mock_db)
 * ...         return isinstance(response, RedirectResponse)
 * ...     except Exception:
 * ...         return True  # Expected due to mocked dependencies
 * >>>
 * >>> asyncio.run(test_login_handler())
 * True
 */
export const adminLoginHandlerAdminLoginPost = <ThrowOnError extends boolean = false>(options?: Options<AdminLoginHandlerAdminLoginPostData, ThrowOnError>) => (options?.client ?? client).post<AdminLoginHandlerAdminLoginPostResponses, unknown, ThrowOnError>({ url: '/admin/login', ...options });

/**
 * Admin Logout
 *
 * Handle admin logout by clearing authentication cookies.
 *
 * This endpoint clears the JWT authentication cookie and redirects
 * the user to a login page or back to the admin page (which will
 * trigger authentication).
 *
 * Args:
 * request (Request): FastAPI request object.
 *
 * Returns:
 * RedirectResponse: Redirect to admin page with cleared cookies.
 *
 * Examples:
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from unittest.mock import MagicMock
 * >>>
 * >>> # Mock request
 * >>> mock_request = MagicMock(spec=Request)
 * >>> mock_request.scope = {"root_path": "/test"}
 * >>>
 * >>> import asyncio
 * >>> async def test_logout():
 * ...     response = await admin_logout(mock_request)
 * ...     return isinstance(response, RedirectResponse) and response.status_code == 303
 * >>>
 * >>> asyncio.run(test_logout())
 * True
 */
export const adminLogoutAdminLogoutPost = <ThrowOnError extends boolean = false>(options?: Options<AdminLogoutAdminLogoutPostData, ThrowOnError>) => (options?.client ?? client).post<AdminLogoutAdminLogoutPostResponses, unknown, ThrowOnError>({ url: '/admin/logout', ...options });

/**
 * Admin List Teams
 *
 * List teams for admin UI via HTMX.
 *
 * Args:
 * request: FastAPI request object
 * db: Database session
 * user: Authenticated admin user
 * unified: If True, return unified team view with relationship badges
 *
 * Returns:
 * HTML response with teams list
 *
 * Raises:
 * HTTPException: If email auth is disabled or user not found
 */
export const adminListTeamsAdminTeamsGet = <ThrowOnError extends boolean = false>(options?: Options<AdminListTeamsAdminTeamsGetData, ThrowOnError>) => (options?.client ?? client).get<AdminListTeamsAdminTeamsGetResponses, AdminListTeamsAdminTeamsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/teams',
    ...options
});

/**
 * Admin Create Team
 *
 * Create team via admin UI form submission.
 *
 * Args:
 * request: FastAPI request object
 * db: Database session
 * user: Authenticated admin user
 *
 * Returns:
 * HTML response with new team or error message
 *
 * Raises:
 * HTTPException: If email auth is disabled or validation fails
 */
export const adminCreateTeamAdminTeamsPost = <ThrowOnError extends boolean = false>(options?: Options<AdminCreateTeamAdminTeamsPostData, ThrowOnError>) => (options?.client ?? client).post<AdminCreateTeamAdminTeamsPostResponses, AdminCreateTeamAdminTeamsPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/teams',
    ...options
});

/**
 * Admin View Team Members
 *
 * View team members via admin UI.
 *
 * Args:
 * team_id: ID of the team to view members for
 * request: FastAPI request object
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * HTMLResponse: Rendered team members view
 */
export const adminViewTeamMembersAdminTeamsTeamIdMembersGet = <ThrowOnError extends boolean = false>(options: Options<AdminViewTeamMembersAdminTeamsTeamIdMembersGetData, ThrowOnError>) => (options.client ?? client).get<AdminViewTeamMembersAdminTeamsTeamIdMembersGetResponses, AdminViewTeamMembersAdminTeamsTeamIdMembersGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/teams/{team_id}/members',
    ...options
});

/**
 * Admin Get Team Edit
 *
 * Get team edit form via admin UI.
 *
 * Args:
 * team_id: ID of the team to edit
 * db: Database session
 *
 * Returns:
 * HTMLResponse: Rendered team edit form
 */
export const adminGetTeamEditAdminTeamsTeamIdEditGet = <ThrowOnError extends boolean = false>(options: Options<AdminGetTeamEditAdminTeamsTeamIdEditGetData, ThrowOnError>) => (options.client ?? client).get<AdminGetTeamEditAdminTeamsTeamIdEditGetResponses, AdminGetTeamEditAdminTeamsTeamIdEditGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/teams/{team_id}/edit',
    ...options
});

/**
 * Admin Update Team
 *
 * Update team via admin UI.
 *
 * Args:
 * team_id: ID of the team to update
 * request: FastAPI request object
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * Response: Result of team update operation
 */
export const adminUpdateTeamAdminTeamsTeamIdUpdatePost = <ThrowOnError extends boolean = false>(options: Options<AdminUpdateTeamAdminTeamsTeamIdUpdatePostData, ThrowOnError>) => (options.client ?? client).post<AdminUpdateTeamAdminTeamsTeamIdUpdatePostResponses, AdminUpdateTeamAdminTeamsTeamIdUpdatePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/teams/{team_id}/update',
    ...options
});

/**
 * Admin Delete Team
 *
 * Delete team via admin UI.
 *
 * Args:
 * team_id: ID of the team to delete
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * HTMLResponse: Success message or error response
 */
export const adminDeleteTeamAdminTeamsTeamIdDelete = <ThrowOnError extends boolean = false>(options: Options<AdminDeleteTeamAdminTeamsTeamIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<AdminDeleteTeamAdminTeamsTeamIdDeleteResponses, AdminDeleteTeamAdminTeamsTeamIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/teams/{team_id}',
    ...options
});

/**
 * Admin Add Team Member
 *
 * Add member to team via admin UI.
 *
 * Args:
 * team_id: ID of the team to add member to
 * request: FastAPI request object
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * HTMLResponse: Success message or error response
 */
export const adminAddTeamMemberAdminTeamsTeamIdAddMemberPost = <ThrowOnError extends boolean = false>(options: Options<AdminAddTeamMemberAdminTeamsTeamIdAddMemberPostData, ThrowOnError>) => (options.client ?? client).post<AdminAddTeamMemberAdminTeamsTeamIdAddMemberPostResponses, AdminAddTeamMemberAdminTeamsTeamIdAddMemberPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/teams/{team_id}/add-member',
    ...options
});

/**
 * Admin Update Team Member Role
 *
 * Update team member role via admin UI.
 *
 * Args:
 * team_id: ID of the team containing the member
 * request: FastAPI request object
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * HTMLResponse: Success message or error response
 */
export const adminUpdateTeamMemberRoleAdminTeamsTeamIdUpdateMemberRolePost = <ThrowOnError extends boolean = false>(options: Options<AdminUpdateTeamMemberRoleAdminTeamsTeamIdUpdateMemberRolePostData, ThrowOnError>) => (options.client ?? client).post<AdminUpdateTeamMemberRoleAdminTeamsTeamIdUpdateMemberRolePostResponses, AdminUpdateTeamMemberRoleAdminTeamsTeamIdUpdateMemberRolePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/teams/{team_id}/update-member-role',
    ...options
});

/**
 * Admin Remove Team Member
 *
 * Remove member from team via admin UI.
 *
 * Args:
 * team_id: ID of the team to remove member from
 * request: FastAPI request object
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * HTMLResponse: Success message or error response
 */
export const adminRemoveTeamMemberAdminTeamsTeamIdRemoveMemberPost = <ThrowOnError extends boolean = false>(options: Options<AdminRemoveTeamMemberAdminTeamsTeamIdRemoveMemberPostData, ThrowOnError>) => (options.client ?? client).post<AdminRemoveTeamMemberAdminTeamsTeamIdRemoveMemberPostResponses, AdminRemoveTeamMemberAdminTeamsTeamIdRemoveMemberPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/teams/{team_id}/remove-member',
    ...options
});

/**
 * Admin Leave Team
 *
 * Leave a team via admin UI.
 *
 * Args:
 * team_id: ID of the team to leave
 * request: FastAPI request object
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * HTMLResponse: Success message or error response
 */
export const adminLeaveTeamAdminTeamsTeamIdLeavePost = <ThrowOnError extends boolean = false>(options: Options<AdminLeaveTeamAdminTeamsTeamIdLeavePostData, ThrowOnError>) => (options.client ?? client).post<AdminLeaveTeamAdminTeamsTeamIdLeavePostResponses, AdminLeaveTeamAdminTeamsTeamIdLeavePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/teams/{team_id}/leave',
    ...options
});

/**
 * Admin Create Join Request
 *
 * Create a join request for a team via admin UI.
 *
 * Args:
 * team_id: ID of the team to request to join
 * request: FastAPI request object
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * HTML response with success message or error
 */
export const adminCreateJoinRequestAdminTeamsTeamIdJoinRequestPost = <ThrowOnError extends boolean = false>(options: Options<AdminCreateJoinRequestAdminTeamsTeamIdJoinRequestPostData, ThrowOnError>) => (options.client ?? client).post<AdminCreateJoinRequestAdminTeamsTeamIdJoinRequestPostResponses, AdminCreateJoinRequestAdminTeamsTeamIdJoinRequestPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/teams/{team_id}/join-request',
    ...options
});

/**
 * Admin Cancel Join Request
 *
 * Cancel a join request via admin UI.
 *
 * Args:
 * team_id: ID of the team
 * request_id: ID of the join request to cancel
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * HTML response with updated button state
 */
export const adminCancelJoinRequestAdminTeamsTeamIdJoinRequestRequestIdDelete = <ThrowOnError extends boolean = false>(options: Options<AdminCancelJoinRequestAdminTeamsTeamIdJoinRequestRequestIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<AdminCancelJoinRequestAdminTeamsTeamIdJoinRequestRequestIdDeleteResponses, AdminCancelJoinRequestAdminTeamsTeamIdJoinRequestRequestIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/teams/{team_id}/join-request/{request_id}',
    ...options
});

/**
 * Admin List Join Requests
 *
 * List join requests for a team via admin UI.
 *
 * Args:
 * team_id: ID of the team
 * request: FastAPI request object
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * HTML response with join requests list
 */
export const adminListJoinRequestsAdminTeamsTeamIdJoinRequestsGet = <ThrowOnError extends boolean = false>(options: Options<AdminListJoinRequestsAdminTeamsTeamIdJoinRequestsGetData, ThrowOnError>) => (options.client ?? client).get<AdminListJoinRequestsAdminTeamsTeamIdJoinRequestsGetResponses, AdminListJoinRequestsAdminTeamsTeamIdJoinRequestsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/teams/{team_id}/join-requests',
    ...options
});

/**
 * Admin Approve Join Request
 *
 * Approve a join request via admin UI.
 *
 * Args:
 * team_id: ID of the team
 * request_id: ID of the join request to approve
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * HTML response with success message
 */
export const adminApproveJoinRequestAdminTeamsTeamIdJoinRequestsRequestIdApprovePost = <ThrowOnError extends boolean = false>(options: Options<AdminApproveJoinRequestAdminTeamsTeamIdJoinRequestsRequestIdApprovePostData, ThrowOnError>) => (options.client ?? client).post<AdminApproveJoinRequestAdminTeamsTeamIdJoinRequestsRequestIdApprovePostResponses, AdminApproveJoinRequestAdminTeamsTeamIdJoinRequestsRequestIdApprovePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/teams/{team_id}/join-requests/{request_id}/approve',
    ...options
});

/**
 * Admin Reject Join Request
 *
 * Reject a join request via admin UI.
 *
 * Args:
 * team_id: ID of the team
 * request_id: ID of the join request to reject
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * HTML response with success message
 */
export const adminRejectJoinRequestAdminTeamsTeamIdJoinRequestsRequestIdRejectPost = <ThrowOnError extends boolean = false>(options: Options<AdminRejectJoinRequestAdminTeamsTeamIdJoinRequestsRequestIdRejectPostData, ThrowOnError>) => (options.client ?? client).post<AdminRejectJoinRequestAdminTeamsTeamIdJoinRequestsRequestIdRejectPostResponses, AdminRejectJoinRequestAdminTeamsTeamIdJoinRequestsRequestIdRejectPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/teams/{team_id}/join-requests/{request_id}/reject',
    ...options
});

/**
 * Admin List Users
 *
 * List users for admin UI via HTMX.
 *
 * Args:
 * request: FastAPI request object
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * Response: HTML or JSON response with users list
 */
export const adminListUsersAdminUsersGet = <ThrowOnError extends boolean = false>(options?: Options<AdminListUsersAdminUsersGetData, ThrowOnError>) => (options?.client ?? client).get<AdminListUsersAdminUsersGetResponses, AdminListUsersAdminUsersGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/users',
    ...options
});

/**
 * Admin Create User
 *
 * Create a new user via admin UI.
 *
 * Args:
 * request: FastAPI request object
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * HTMLResponse: Success message or error response
 */
export const adminCreateUserAdminUsersPost = <ThrowOnError extends boolean = false>(options?: Options<AdminCreateUserAdminUsersPostData, ThrowOnError>) => (options?.client ?? client).post<AdminCreateUserAdminUsersPostResponses, AdminCreateUserAdminUsersPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/users',
    ...options
});

/**
 * Admin Get User Edit
 *
 * Get user edit form via admin UI.
 *
 * Args:
 * user_email: Email of user to edit
 * db: Database session
 *
 * Returns:
 * HTMLResponse: User edit form HTML
 */
export const adminGetUserEditAdminUsersUserEmailEditGet = <ThrowOnError extends boolean = false>(options: Options<AdminGetUserEditAdminUsersUserEmailEditGetData, ThrowOnError>) => (options.client ?? client).get<AdminGetUserEditAdminUsersUserEmailEditGetResponses, AdminGetUserEditAdminUsersUserEmailEditGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/users/{user_email}/edit',
    ...options
});

/**
 * Admin Update User
 *
 * Update user via admin UI.
 *
 * Args:
 * user_email: Email of user to update
 * request: FastAPI request object
 * db: Database session
 *
 * Returns:
 * HTMLResponse: Success message or error response
 */
export const adminUpdateUserAdminUsersUserEmailUpdatePost = <ThrowOnError extends boolean = false>(options: Options<AdminUpdateUserAdminUsersUserEmailUpdatePostData, ThrowOnError>) => (options.client ?? client).post<AdminUpdateUserAdminUsersUserEmailUpdatePostResponses, AdminUpdateUserAdminUsersUserEmailUpdatePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/users/{user_email}/update',
    ...options
});

/**
 * Admin Activate User
 *
 * Activate user via admin UI.
 *
 * Args:
 * user_email: Email of user to activate
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * HTMLResponse: Success message or error response
 */
export const adminActivateUserAdminUsersUserEmailActivatePost = <ThrowOnError extends boolean = false>(options: Options<AdminActivateUserAdminUsersUserEmailActivatePostData, ThrowOnError>) => (options.client ?? client).post<AdminActivateUserAdminUsersUserEmailActivatePostResponses, AdminActivateUserAdminUsersUserEmailActivatePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/users/{user_email}/activate',
    ...options
});

/**
 * Admin Deactivate User
 *
 * Deactivate user via admin UI.
 *
 * Args:
 * user_email: Email of user to deactivate
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * HTMLResponse: Success message or error response
 */
export const adminDeactivateUserAdminUsersUserEmailDeactivatePost = <ThrowOnError extends boolean = false>(options: Options<AdminDeactivateUserAdminUsersUserEmailDeactivatePostData, ThrowOnError>) => (options.client ?? client).post<AdminDeactivateUserAdminUsersUserEmailDeactivatePostResponses, AdminDeactivateUserAdminUsersUserEmailDeactivatePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/users/{user_email}/deactivate',
    ...options
});

/**
 * Admin Delete User
 *
 * Delete user via admin UI.
 *
 * Args:
 * user_email: Email address of user to delete
 * _request: FastAPI request object (unused)
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * HTMLResponse: Success/error message
 */
export const adminDeleteUserAdminUsersUserEmailDelete = <ThrowOnError extends boolean = false>(options: Options<AdminDeleteUserAdminUsersUserEmailDeleteData, ThrowOnError>) => (options.client ?? client).delete<AdminDeleteUserAdminUsersUserEmailDeleteResponses, AdminDeleteUserAdminUsersUserEmailDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/users/{user_email}',
    ...options
});

/**
 * Admin List Tools
 *
 * List tools for the admin UI with pagination support.
 *
 * This endpoint retrieves a paginated list of tools from the database, optionally
 * including those that are inactive. Supports offset-based pagination with
 * configurable page size.
 *
 * Args:
 * page (int): Page number (1-indexed). Default: 1.
 * per_page (int): Items per page (1-500). Default: 50.
 * include_inactive (bool): Whether to include inactive tools in the results.
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * Dict with 'data', 'pagination', and 'links' keys containing paginated tools.
 */
export const adminListToolsAdminToolsGet = <ThrowOnError extends boolean = false>(options?: Options<AdminListToolsAdminToolsGetData, ThrowOnError>) => (options?.client ?? client).get<AdminListToolsAdminToolsGetResponses, AdminListToolsAdminToolsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/tools',
    ...options
});

/**
 * Admin Add Tool
 *
 * Add a tool via the admin UI with error handling.
 *
 * Expects form fields:
 * - name
 * - url
 * - description (optional)
 * - requestType (mapped to request_type; defaults to "SSE")
 * - integrationType (mapped to integration_type; defaults to "MCP")
 * - headers (JSON string)
 * - input_schema (JSON string)
 * - output_schema (JSON string, optional)
 * - jsonpath_filter (optional)
 * - auth_type (optional)
 * - auth_username (optional)
 * - auth_password (optional)
 * - auth_token (optional)
 * - auth_header_key (optional)
 * - auth_header_value (optional)
 *
 * Logs the raw form data and assembled tool_data for debugging.
 *
 * Args:
 * request (Request): the FastAPI request object containing the form data.
 * db (Session): the SQLAlchemy database session.
 * user (str): identifier of the authenticated user.
 *
 * Returns:
 * JSONResponse: a JSON response with `{"message": ..., "success": ...}` and an appropriate HTTP status code.
 *
 * Examples:
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import JSONResponse
 * >>> from starlette.datastructures import FormData
 * >>> from sqlalchemy.exc import IntegrityError
 * >>> from mcpgateway.utils.error_formatter import ErrorFormatter
 * >>> import json
 *
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 *
 * >>> # Happy path: Add a new tool successfully
 * >>> form_data_success = FormData([
 * ...     ("name", "New_Tool"),
 * ...     ("url", "http://new.tool.com"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST"),
 * ...     ("headers", '{"X-Api-Key": "abc"}')
 * ... ])
 * >>> mock_request_success = MagicMock(spec=Request)
 * >>> mock_request_success.form = AsyncMock(return_value=form_data_success)
 * >>> original_register_tool = tool_service.register_tool
 * >>> tool_service.register_tool = AsyncMock()
 *
 * >>> async def test_admin_add_tool_success():
 * ...     response = await admin_add_tool(mock_request_success, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 200 and json.loads(response.body.decode())["success"] is True
 *
 * >>> asyncio.run(test_admin_add_tool_success())
 * True
 *
 * >>> # Error path: Tool name conflict via IntegrityError
 * >>> form_data_conflict = FormData([
 * ...     ("name", "Existing_Tool"),
 * ...     ("url", "http://existing.com"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST")
 * ... ])
 * >>> mock_request_conflict = MagicMock(spec=Request)
 * >>> mock_request_conflict.form = AsyncMock(return_value=form_data_conflict)
 * >>> fake_integrity_error = IntegrityError("Mock Integrity Error", {}, None)
 * >>> tool_service.register_tool = AsyncMock(side_effect=fake_integrity_error)
 *
 * >>> async def test_admin_add_tool_integrity_error():
 * ...     response = await admin_add_tool(mock_request_conflict, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 409 and json.loads(response.body.decode())["success"] is False
 *
 * >>> asyncio.run(test_admin_add_tool_integrity_error())
 * True
 *
 * >>> # Error path: Missing required field (Pydantic ValidationError)
 * >>> form_data_missing = FormData([
 * ...     ("url", "http://missing.com"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST")
 * ... ])
 * >>> mock_request_missing = MagicMock(spec=Request)
 * >>> mock_request_missing.form = AsyncMock(return_value=form_data_missing)
 *
 * >>> async def test_admin_add_tool_validation_error():
 * ...     response = await admin_add_tool(mock_request_missing, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 422 and json.loads(response.body.decode())["success"] is False
 *
 * >>> asyncio.run(test_admin_add_tool_validation_error())  # doctest: +ELLIPSIS
 * True
 *
 * >>> # Error path: Unexpected exception
 * >>> form_data_generic_error = FormData([
 * ...     ("name", "Generic_Error_Tool"),
 * ...     ("url", "http://generic.com"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST")
 * ... ])
 * >>> mock_request_generic_error = MagicMock(spec=Request)
 * >>> mock_request_generic_error.form = AsyncMock(return_value=form_data_generic_error)
 * >>> tool_service.register_tool = AsyncMock(side_effect=Exception("Unexpected error"))
 *
 * >>> async def test_admin_add_tool_generic_exception():
 * ...     response = await admin_add_tool(mock_request_generic_error, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 500 and json.loads(response.body.decode())["success"] is False
 *
 * >>> asyncio.run(test_admin_add_tool_generic_exception())
 * True
 *
 * >>> # Restore original method
 * >>> tool_service.register_tool = original_register_tool
 */
export const adminAddToolAdminToolsPost = <ThrowOnError extends boolean = false>(options?: Options<AdminAddToolAdminToolsPostData, ThrowOnError>) => (options?.client ?? client).post<AdminAddToolAdminToolsPostResponses, AdminAddToolAdminToolsPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/tools',
    ...options
});

/**
 * Admin Tools Partial Html
 *
 * Return HTML partial for paginated tools list (HTMX endpoint).
 *
 * This endpoint returns only the table body rows and pagination controls
 * for HTMX-based pagination in the admin UI.
 *
 * Args:
 * request (Request): FastAPI request object.
 * page (int): Page number (1-indexed). Default: 1.
 * per_page (int): Items per page (1-500). Default: 50.
 * include_inactive (bool): Whether to include inactive tools in the results.
 * gateway_id (Optional[str]): Filter by gateway ID(s), comma-separated.
 * render (str): Render mode - 'controls' returns only pagination controls.
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * HTMLResponse with tools table rows and pagination controls.
 */
export const adminToolsPartialHtmlAdminToolsPartialGet = <ThrowOnError extends boolean = false>(options?: Options<AdminToolsPartialHtmlAdminToolsPartialGetData, ThrowOnError>) => (options?.client ?? client).get<AdminToolsPartialHtmlAdminToolsPartialGetResponses, AdminToolsPartialHtmlAdminToolsPartialGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/tools/partial',
    ...options
});

/**
 * Admin Get All Tool Ids
 *
 * Return all tool IDs accessible to the current user.
 *
 * This is used by "Select All" to get all tool IDs without loading full data.
 *
 * Args:
 * include_inactive (bool): Whether to include inactive tools in the results
 * gateway_id (Optional[str]): Filter by gateway ID(s), comma-separated. Accepts the literal value 'null' to indicate NULL gateway_id (local tools).
 * db (Session): Database session dependency
 * user: Current user making the request
 *
 * Returns:
 * JSONResponse: List of tool IDs accessible to the user
 */
export const adminGetAllToolIdsAdminToolsIdsGet = <ThrowOnError extends boolean = false>(options?: Options<AdminGetAllToolIdsAdminToolsIdsGetData, ThrowOnError>) => (options?.client ?? client).get<AdminGetAllToolIdsAdminToolsIdsGetResponses, AdminGetAllToolIdsAdminToolsIdsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/tools/ids',
    ...options
});

/**
 * Admin Search Tools
 *
 * Search tools by name, ID, or description.
 *
 * This endpoint searches tools across all accessible tools for the current user,
 * returning both IDs and names for use in search functionality like the Add Server page.
 *
 * Args:
 * q (str): Search query string to match against tool names, IDs, or descriptions
 * include_inactive (bool): Whether to include inactive tools in the search results
 * limit (int): Maximum number of results to return (1-1000)
 * db (Session): Database session dependency
 * user: Current user making the request
 *
 * Returns:
 * JSONResponse: Dictionary containing list of matching tools and count
 */
export const adminSearchToolsAdminToolsSearchGet = <ThrowOnError extends boolean = false>(options?: Options<AdminSearchToolsAdminToolsSearchGetData, ThrowOnError>) => (options?.client ?? client).get<AdminSearchToolsAdminToolsSearchGetResponses, AdminSearchToolsAdminToolsSearchGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/tools/search',
    ...options
});

/**
 * Admin Prompts Partial Html
 *
 * Return paginated prompts HTML partials for the admin UI.
 *
 * This HTMX endpoint returns only the partial HTML used by the admin UI for
 * prompts. It supports three render modes:
 *
 * - default: full table partial (rows + controls)
 * - ``render="controls"``: return only pagination controls
 * - ``render="selector"``: return selector items for infinite scroll
 *
 * Args:
 * request (Request): FastAPI request object used by the template engine.
 * page (int): Page number (1-indexed).
 * per_page (int): Number of items per page (bounded by settings).
 * include_inactive (bool): If True, include inactive prompts in results.
 * render (Optional[str]): Render mode; one of None, "controls", "selector".
 * gateway_id (Optional[str]): Filter by gateway ID(s), comma-separated.
 * db (Session): Database session (dependency-injected).
 * user: Authenticated user object from dependency injection.
 *
 * Returns:
 * Union[HTMLResponse, TemplateResponse]: A rendered template response
 * containing either the table partial, pagination controls, or selector
 * items depending on ``render``. The response contains JSON-serializable
 * encoded prompt data when templates expect it.
 */
export const adminPromptsPartialHtmlAdminPromptsPartialGet = <ThrowOnError extends boolean = false>(options?: Options<AdminPromptsPartialHtmlAdminPromptsPartialGetData, ThrowOnError>) => (options?.client ?? client).get<AdminPromptsPartialHtmlAdminPromptsPartialGetResponses, AdminPromptsPartialHtmlAdminPromptsPartialGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/prompts/partial',
    ...options
});

/**
 * Admin Resources Partial Html
 *
 * Return HTML partial for paginated resources list (HTMX endpoint).
 *
 * This endpoint mirrors the behavior of the tools and prompts partial
 * endpoints. It returns a template fragment suitable for HTMX-based
 * pagination/infinite-scroll within the admin UI.
 *
 * Args:
 * request (Request): FastAPI request object used by the template engine.
 * page (int): Page number (1-indexed).
 * per_page (int): Number of items per page (bounded by settings).
 * include_inactive (bool): If True, include inactive resources in results.
 * render (Optional[str]): Render mode; when set to "controls" returns only
 * pagination controls. Other supported value: "selector" for selector
 * items used by infinite scroll selectors.
 * gateway_id (Optional[str]): Filter by gateway ID(s), comma-separated.
 * db (Session): Database session (dependency-injected).
 * user: Authenticated user object from dependency injection.
 *
 * Returns:
 * Union[HTMLResponse, TemplateResponse]: Rendered template response with the
 * resources partial (rows + controls), pagination controls only, or selector
 * items depending on the ``render`` parameter.
 */
export const adminResourcesPartialHtmlAdminResourcesPartialGet = <ThrowOnError extends boolean = false>(options?: Options<AdminResourcesPartialHtmlAdminResourcesPartialGetData, ThrowOnError>) => (options?.client ?? client).get<AdminResourcesPartialHtmlAdminResourcesPartialGetResponses, AdminResourcesPartialHtmlAdminResourcesPartialGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/resources/partial',
    ...options
});

/**
 * Admin Get All Prompt Ids
 *
 * Return all prompt IDs accessible to the current user (select-all helper).
 *
 * This endpoint is used by UI "Select All" helpers to fetch only the IDs
 * of prompts the requesting user can access (owner, team, or public).
 *
 * Args:
 * include_inactive (bool): When True include prompts that are inactive.
 * gateway_id (Optional[str]): Filter by gateway ID(s), comma-separated. Accepts the literal value 'null' to indicate NULL gateway_id (local prompts).
 * db (Session): Database session (injected dependency).
 * user: Authenticated user object from dependency injection.
 *
 * Returns:
 * dict: A dictionary containing two keys:
 * - "prompt_ids": List[str] of accessible prompt IDs.
 * - "count": int number of IDs returned.
 */
export const adminGetAllPromptIdsAdminPromptsIdsGet = <ThrowOnError extends boolean = false>(options?: Options<AdminGetAllPromptIdsAdminPromptsIdsGetData, ThrowOnError>) => (options?.client ?? client).get<AdminGetAllPromptIdsAdminPromptsIdsGetResponses, AdminGetAllPromptIdsAdminPromptsIdsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/prompts/ids',
    ...options
});

/**
 * Admin Get All Resource Ids
 *
 * Return all resource IDs accessible to the current user (select-all helper).
 *
 * This endpoint is used by UI "Select All" helpers to fetch only the IDs
 * of resources the requesting user can access (owner, team, or public).
 *
 * Args:
 * include_inactive (bool): Whether to include inactive resources in the results.
 * gateway_id (Optional[str]): Filter by gateway ID(s), comma-separated. Accepts the literal value 'null' to indicate NULL gateway_id (local resources).
 * db (Session): Database session dependency.
 * user: Authenticated user object from dependency injection.
 *
 * Returns:
 * dict: A dictionary containing two keys:
 * - "resource_ids": List[str] of accessible resource IDs.
 * - "count": int number of IDs returned.
 */
export const adminGetAllResourceIdsAdminResourcesIdsGet = <ThrowOnError extends boolean = false>(options?: Options<AdminGetAllResourceIdsAdminResourcesIdsGetData, ThrowOnError>) => (options?.client ?? client).get<AdminGetAllResourceIdsAdminResourcesIdsGetResponses, AdminGetAllResourceIdsAdminResourcesIdsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/resources/ids',
    ...options
});

/**
 * Admin Search Prompts
 *
 * Search prompts by name or description for selector search.
 *
 * Performs a case-insensitive search over prompt names and descriptions
 * and returns a limited list of matching prompts suitable for selector
 * UIs (id, name, description).
 *
 * Args:
 * q (str): Search query string.
 * include_inactive (bool): When True include prompts that are inactive.
 * limit (int): Maximum number of results to return (bounded by the query parameter).
 * db (Session): Database session (injected dependency).
 * user: Authenticated user object from dependency injection.
 *
 * Returns:
 * dict: A dictionary containing:
 * - "prompts": List[dict] where each dict has keys "id", "name", "description".
 * - "count": int number of matched prompts returned.
 */
export const adminSearchPromptsAdminPromptsSearchGet = <ThrowOnError extends boolean = false>(options?: Options<AdminSearchPromptsAdminPromptsSearchGetData, ThrowOnError>) => (options?.client ?? client).get<AdminSearchPromptsAdminPromptsSearchGetResponses, AdminSearchPromptsAdminPromptsSearchGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/prompts/search',
    ...options
});

/**
 * Admin Get Tool
 *
 * Retrieve specific tool details for the admin UI.
 *
 * This endpoint fetches the details of a specific tool from the database
 * by its ID. It provides access to all information about the tool for
 * viewing and management purposes.
 *
 * Args:
 * tool_id (str): The ID of the tool to retrieve.
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * ToolRead: The tool details formatted with by_alias=True.
 *
 * Raises:
 * HTTPException: If the tool is not found.
 * Exception: For any other unexpected errors.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from mcpgateway.schemas import ToolRead, ToolMetrics
 * >>> from datetime import datetime, timezone
 * >>> from mcpgateway.services.tool_service import ToolNotFoundError # Added import
 * >>> from fastapi import HTTPException
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> tool_id = "test-tool-id"
 * >>>
 * >>> # Mock tool data
 * >>> mock_tool = ToolRead(
 * ...     id=tool_id, name="Get Tool", original_name="GetTool", url="http://get.com",
 * ...     description="Tool for getting", request_type="GET", integration_type="REST",
 * ...     headers={}, input_schema={}, annotations={}, jsonpath_filter=None, auth=None,
 * ...     created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc),
 * ...     enabled=True, reachable=True, gateway_id=None, execution_count=0,
 * ...     metrics=ToolMetrics(
 * ...         total_executions=0, successful_executions=0, failed_executions=0,
 * ...         failure_rate=0.0, min_response_time=0.0, max_response_time=0.0, avg_response_time=0.0,
 * ...         last_execution_time=None
 * ...     ),
 * ...     gateway_slug="default", custom_name_slug="get-tool",
 * ...     customName="Get Tool",
 * ...     tags=[]
 * ... )
 * >>>
 * >>> # Mock the tool_service.get_tool method
 * >>> original_get_tool = tool_service.get_tool
 * >>> tool_service.get_tool = AsyncMock(return_value=mock_tool)
 * >>>
 * >>> # Test successful retrieval
 * >>> async def test_admin_get_tool_success():
 * ...     result = await admin_get_tool(tool_id, mock_db, mock_user)
 * ...     return isinstance(result, dict) and result['id'] == tool_id
 * >>>
 * >>> asyncio.run(test_admin_get_tool_success())
 * True
 * >>>
 * >>> # Test tool not found
 * >>> tool_service.get_tool = AsyncMock(side_effect=ToolNotFoundError("Tool not found"))
 * >>> async def test_admin_get_tool_not_found():
 * ...     try:
 * ...         await admin_get_tool("nonexistent", mock_db, mock_user)
 * ...         return False
 * ...     except HTTPException as e:
 * ...         return e.status_code == 404 and "Tool not found" in e.detail
 * >>>
 * >>> asyncio.run(test_admin_get_tool_not_found())
 * True
 * >>>
 * >>> # Test generic exception
 * >>> tool_service.get_tool = AsyncMock(side_effect=Exception("Generic error"))
 * >>> async def test_admin_get_tool_exception():
 * ...     try:
 * ...         await admin_get_tool(tool_id, mock_db, mock_user)
 * ...         return False
 * ...     except Exception as e:
 * ...         return str(e) == "Generic error"
 * >>>
 * >>> asyncio.run(test_admin_get_tool_exception())
 * True
 * >>>
 * >>> # Restore original method
 * >>> tool_service.get_tool = original_get_tool
 */
export const adminGetToolAdminToolsToolIdGet = <ThrowOnError extends boolean = false>(options: Options<AdminGetToolAdminToolsToolIdGetData, ThrowOnError>) => (options.client ?? client).get<AdminGetToolAdminToolsToolIdGetResponses, AdminGetToolAdminToolsToolIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/tools/{tool_id}',
    ...options
});

/**
 * Admin Add Tool
 *
 * Add a tool via the admin UI with error handling.
 *
 * Expects form fields:
 * - name
 * - url
 * - description (optional)
 * - requestType (mapped to request_type; defaults to "SSE")
 * - integrationType (mapped to integration_type; defaults to "MCP")
 * - headers (JSON string)
 * - input_schema (JSON string)
 * - output_schema (JSON string, optional)
 * - jsonpath_filter (optional)
 * - auth_type (optional)
 * - auth_username (optional)
 * - auth_password (optional)
 * - auth_token (optional)
 * - auth_header_key (optional)
 * - auth_header_value (optional)
 *
 * Logs the raw form data and assembled tool_data for debugging.
 *
 * Args:
 * request (Request): the FastAPI request object containing the form data.
 * db (Session): the SQLAlchemy database session.
 * user (str): identifier of the authenticated user.
 *
 * Returns:
 * JSONResponse: a JSON response with `{"message": ..., "success": ...}` and an appropriate HTTP status code.
 *
 * Examples:
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import JSONResponse
 * >>> from starlette.datastructures import FormData
 * >>> from sqlalchemy.exc import IntegrityError
 * >>> from mcpgateway.utils.error_formatter import ErrorFormatter
 * >>> import json
 *
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 *
 * >>> # Happy path: Add a new tool successfully
 * >>> form_data_success = FormData([
 * ...     ("name", "New_Tool"),
 * ...     ("url", "http://new.tool.com"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST"),
 * ...     ("headers", '{"X-Api-Key": "abc"}')
 * ... ])
 * >>> mock_request_success = MagicMock(spec=Request)
 * >>> mock_request_success.form = AsyncMock(return_value=form_data_success)
 * >>> original_register_tool = tool_service.register_tool
 * >>> tool_service.register_tool = AsyncMock()
 *
 * >>> async def test_admin_add_tool_success():
 * ...     response = await admin_add_tool(mock_request_success, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 200 and json.loads(response.body.decode())["success"] is True
 *
 * >>> asyncio.run(test_admin_add_tool_success())
 * True
 *
 * >>> # Error path: Tool name conflict via IntegrityError
 * >>> form_data_conflict = FormData([
 * ...     ("name", "Existing_Tool"),
 * ...     ("url", "http://existing.com"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST")
 * ... ])
 * >>> mock_request_conflict = MagicMock(spec=Request)
 * >>> mock_request_conflict.form = AsyncMock(return_value=form_data_conflict)
 * >>> fake_integrity_error = IntegrityError("Mock Integrity Error", {}, None)
 * >>> tool_service.register_tool = AsyncMock(side_effect=fake_integrity_error)
 *
 * >>> async def test_admin_add_tool_integrity_error():
 * ...     response = await admin_add_tool(mock_request_conflict, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 409 and json.loads(response.body.decode())["success"] is False
 *
 * >>> asyncio.run(test_admin_add_tool_integrity_error())
 * True
 *
 * >>> # Error path: Missing required field (Pydantic ValidationError)
 * >>> form_data_missing = FormData([
 * ...     ("url", "http://missing.com"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST")
 * ... ])
 * >>> mock_request_missing = MagicMock(spec=Request)
 * >>> mock_request_missing.form = AsyncMock(return_value=form_data_missing)
 *
 * >>> async def test_admin_add_tool_validation_error():
 * ...     response = await admin_add_tool(mock_request_missing, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 422 and json.loads(response.body.decode())["success"] is False
 *
 * >>> asyncio.run(test_admin_add_tool_validation_error())  # doctest: +ELLIPSIS
 * True
 *
 * >>> # Error path: Unexpected exception
 * >>> form_data_generic_error = FormData([
 * ...     ("name", "Generic_Error_Tool"),
 * ...     ("url", "http://generic.com"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST")
 * ... ])
 * >>> mock_request_generic_error = MagicMock(spec=Request)
 * >>> mock_request_generic_error.form = AsyncMock(return_value=form_data_generic_error)
 * >>> tool_service.register_tool = AsyncMock(side_effect=Exception("Unexpected error"))
 *
 * >>> async def test_admin_add_tool_generic_exception():
 * ...     response = await admin_add_tool(mock_request_generic_error, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 500 and json.loads(response.body.decode())["success"] is False
 *
 * >>> asyncio.run(test_admin_add_tool_generic_exception())
 * True
 *
 * >>> # Restore original method
 * >>> tool_service.register_tool = original_register_tool
 */
export const adminAddToolAdminToolsPost2 = <ThrowOnError extends boolean = false>(options?: Options<AdminAddToolAdminToolsPost2Data, ThrowOnError>) => (options?.client ?? client).post<AdminAddToolAdminToolsPost2Responses, AdminAddToolAdminToolsPost2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/tools/',
    ...options
});

/**
 * Admin Edit Tool
 *
 * Edit a tool via the admin UI.
 *
 * Expects form fields:
 * - name
 * - displayName (optional)
 * - url
 * - description (optional)
 * - requestType (to be mapped to request_type)
 * - integrationType (to be mapped to integration_type)
 * - headers (as a JSON string)
 * - input_schema (as a JSON string)
 * - output_schema (as a JSON string, optional)
 * - jsonpathFilter (optional)
 * - auth_type (optional, string: "basic", "bearer", or empty)
 * - auth_username (optional, for basic auth)
 * - auth_password (optional, for basic auth)
 * - auth_token (optional, for bearer auth)
 * - auth_header_key (optional, for headers auth)
 * - auth_header_value (optional, for headers auth)
 *
 * Assembles the tool_data dictionary by remapping form keys into the
 * snake-case keys expected by the schemas.
 *
 * Args:
 * tool_id (str): The ID of the tool to edit.
 * request (Request): FastAPI request containing form data.
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * Response: A redirect response to the tools section of the admin
 * dashboard with a status code of 303 (See Other), or a JSON response with
 * an error message if the update fails.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse, JSONResponse
 * >>> from starlette.datastructures import FormData
 * >>> from sqlalchemy.exc import IntegrityError
 * >>> from mcpgateway.services.tool_service import ToolError
 * >>> from pydantic import ValidationError
 * >>> from mcpgateway.utils.error_formatter import ErrorFormatter
 * >>> import json
 *
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> tool_id = "tool-to-edit"
 *
 * >>> # Happy path: Edit tool successfully
 * >>> form_data_success = FormData([
 * ...     ("name", "Updated_Tool"),
 * ...     ("customName", "ValidToolName"),
 * ...     ("url", "http://updated.com"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST"),
 * ...     ("headers", '{"X-Api-Key": "abc"}'),
 * ...     ("input_schema", '{}'),  #  Required field
 * ...     ("description", "Sample tool")
 * ... ])
 * >>> mock_request_success = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_success.form = AsyncMock(return_value=form_data_success)
 * >>> original_update_tool = tool_service.update_tool
 * >>> tool_service.update_tool = AsyncMock()
 *
 * >>> async def test_admin_edit_tool_success():
 * ...     response = await admin_edit_tool(tool_id, mock_request_success, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 200 and json.loads(response.body.decode())["success"] is True
 *
 * >>> asyncio.run(test_admin_edit_tool_success())
 * True
 *
 * >>> # Edge case: Edit tool with inactive checkbox checked
 * >>> form_data_inactive = FormData([
 * ...     ("name", "Inactive_Edit"),
 * ...     ("customName", "ValidToolName"),
 * ...     ("url", "http://inactive.com"),
 * ...     ("is_inactive_checked", "true"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST")
 * ... ])
 * >>> mock_request_inactive = MagicMock(spec=Request, scope={"root_path": "/api"})
 * >>> mock_request_inactive.form = AsyncMock(return_value=form_data_inactive)
 *
 * >>> async def test_admin_edit_tool_inactive_checked():
 * ...     response = await admin_edit_tool(tool_id, mock_request_inactive, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 200 and json.loads(response.body.decode())["success"] is True
 *
 * >>> asyncio.run(test_admin_edit_tool_inactive_checked())
 * True
 *
 * >>> # Error path: Tool name conflict (simulated with IntegrityError)
 * >>> form_data_conflict = FormData([
 * ...     ("name", "Conflicting_Name"),
 * ...     ("customName", "Conflicting_Name"),
 * ...     ("url", "http://conflict.com"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST")
 * ... ])
 * >>> mock_request_conflict = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_conflict.form = AsyncMock(return_value=form_data_conflict)
 * >>> tool_service.update_tool = AsyncMock(side_effect=IntegrityError("Conflict", {}, None))
 *
 * >>> async def test_admin_edit_tool_integrity_error():
 * ...     response = await admin_edit_tool(tool_id, mock_request_conflict, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 409 and json.loads(response.body.decode())["success"] is False
 *
 * >>> asyncio.run(test_admin_edit_tool_integrity_error())
 * True
 *
 * >>> # Error path: ToolError raised
 * >>> form_data_tool_error = FormData([
 * ...     ("name", "Tool_Error"),
 * ...     ("customName", "Tool_Error"),
 * ...     ("url", "http://toolerror.com"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST")
 * ... ])
 * >>> mock_request_tool_error = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_tool_error.form = AsyncMock(return_value=form_data_tool_error)
 * >>> tool_service.update_tool = AsyncMock(side_effect=ToolError("Tool specific error"))
 *
 * >>> async def test_admin_edit_tool_tool_error():
 * ...     response = await admin_edit_tool(tool_id, mock_request_tool_error, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 500 and json.loads(response.body.decode())["success"] is False
 *
 * >>> asyncio.run(test_admin_edit_tool_tool_error())
 * True
 *
 * >>> # Error path: Pydantic Validation Error
 * >>> form_data_validation_error = FormData([
 * ...     ("name", "Bad_URL"),
 * ...     ("customName","Bad_Custom_Name"),
 * ...     ("url", "not-a-valid-url"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST")
 * ... ])
 * >>> mock_request_validation_error = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_validation_error.form = AsyncMock(return_value=form_data_validation_error)
 *
 * >>> async def test_admin_edit_tool_validation_error():
 * ...     response = await admin_edit_tool(tool_id, mock_request_validation_error, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 422 and json.loads(response.body.decode())["success"] is False
 *
 * >>> asyncio.run(test_admin_edit_tool_validation_error())
 * True
 *
 * >>> # Error path: Unexpected exception
 * >>> form_data_unexpected = FormData([
 * ...     ("name", "Crash_Tool"),
 * ...     ("customName", "Crash_Tool"),
 * ...     ("url", "http://crash.com"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST")
 * ... ])
 * >>> mock_request_unexpected = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_unexpected.form = AsyncMock(return_value=form_data_unexpected)
 * >>> tool_service.update_tool = AsyncMock(side_effect=Exception("Unexpected server crash"))
 *
 * >>> async def test_admin_edit_tool_unexpected_error():
 * ...     response = await admin_edit_tool(tool_id, mock_request_unexpected, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 500 and json.loads(response.body.decode())["success"] is False
 *
 * >>> asyncio.run(test_admin_edit_tool_unexpected_error())
 * True
 *
 * >>> # Restore original method
 * >>> tool_service.update_tool = original_update_tool
 */
export const adminEditToolAdminToolsToolIdEditPost = <ThrowOnError extends boolean = false>(options: Options<AdminEditToolAdminToolsToolIdEditPostData, ThrowOnError>) => (options.client ?? client).post<AdminEditToolAdminToolsToolIdEditPostResponses, AdminEditToolAdminToolsToolIdEditPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/tools/{tool_id}/edit',
    ...options
});

/**
 * Admin Edit Tool
 *
 * Edit a tool via the admin UI.
 *
 * Expects form fields:
 * - name
 * - displayName (optional)
 * - url
 * - description (optional)
 * - requestType (to be mapped to request_type)
 * - integrationType (to be mapped to integration_type)
 * - headers (as a JSON string)
 * - input_schema (as a JSON string)
 * - output_schema (as a JSON string, optional)
 * - jsonpathFilter (optional)
 * - auth_type (optional, string: "basic", "bearer", or empty)
 * - auth_username (optional, for basic auth)
 * - auth_password (optional, for basic auth)
 * - auth_token (optional, for bearer auth)
 * - auth_header_key (optional, for headers auth)
 * - auth_header_value (optional, for headers auth)
 *
 * Assembles the tool_data dictionary by remapping form keys into the
 * snake-case keys expected by the schemas.
 *
 * Args:
 * tool_id (str): The ID of the tool to edit.
 * request (Request): FastAPI request containing form data.
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * Response: A redirect response to the tools section of the admin
 * dashboard with a status code of 303 (See Other), or a JSON response with
 * an error message if the update fails.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse, JSONResponse
 * >>> from starlette.datastructures import FormData
 * >>> from sqlalchemy.exc import IntegrityError
 * >>> from mcpgateway.services.tool_service import ToolError
 * >>> from pydantic import ValidationError
 * >>> from mcpgateway.utils.error_formatter import ErrorFormatter
 * >>> import json
 *
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> tool_id = "tool-to-edit"
 *
 * >>> # Happy path: Edit tool successfully
 * >>> form_data_success = FormData([
 * ...     ("name", "Updated_Tool"),
 * ...     ("customName", "ValidToolName"),
 * ...     ("url", "http://updated.com"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST"),
 * ...     ("headers", '{"X-Api-Key": "abc"}'),
 * ...     ("input_schema", '{}'),  #  Required field
 * ...     ("description", "Sample tool")
 * ... ])
 * >>> mock_request_success = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_success.form = AsyncMock(return_value=form_data_success)
 * >>> original_update_tool = tool_service.update_tool
 * >>> tool_service.update_tool = AsyncMock()
 *
 * >>> async def test_admin_edit_tool_success():
 * ...     response = await admin_edit_tool(tool_id, mock_request_success, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 200 and json.loads(response.body.decode())["success"] is True
 *
 * >>> asyncio.run(test_admin_edit_tool_success())
 * True
 *
 * >>> # Edge case: Edit tool with inactive checkbox checked
 * >>> form_data_inactive = FormData([
 * ...     ("name", "Inactive_Edit"),
 * ...     ("customName", "ValidToolName"),
 * ...     ("url", "http://inactive.com"),
 * ...     ("is_inactive_checked", "true"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST")
 * ... ])
 * >>> mock_request_inactive = MagicMock(spec=Request, scope={"root_path": "/api"})
 * >>> mock_request_inactive.form = AsyncMock(return_value=form_data_inactive)
 *
 * >>> async def test_admin_edit_tool_inactive_checked():
 * ...     response = await admin_edit_tool(tool_id, mock_request_inactive, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 200 and json.loads(response.body.decode())["success"] is True
 *
 * >>> asyncio.run(test_admin_edit_tool_inactive_checked())
 * True
 *
 * >>> # Error path: Tool name conflict (simulated with IntegrityError)
 * >>> form_data_conflict = FormData([
 * ...     ("name", "Conflicting_Name"),
 * ...     ("customName", "Conflicting_Name"),
 * ...     ("url", "http://conflict.com"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST")
 * ... ])
 * >>> mock_request_conflict = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_conflict.form = AsyncMock(return_value=form_data_conflict)
 * >>> tool_service.update_tool = AsyncMock(side_effect=IntegrityError("Conflict", {}, None))
 *
 * >>> async def test_admin_edit_tool_integrity_error():
 * ...     response = await admin_edit_tool(tool_id, mock_request_conflict, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 409 and json.loads(response.body.decode())["success"] is False
 *
 * >>> asyncio.run(test_admin_edit_tool_integrity_error())
 * True
 *
 * >>> # Error path: ToolError raised
 * >>> form_data_tool_error = FormData([
 * ...     ("name", "Tool_Error"),
 * ...     ("customName", "Tool_Error"),
 * ...     ("url", "http://toolerror.com"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST")
 * ... ])
 * >>> mock_request_tool_error = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_tool_error.form = AsyncMock(return_value=form_data_tool_error)
 * >>> tool_service.update_tool = AsyncMock(side_effect=ToolError("Tool specific error"))
 *
 * >>> async def test_admin_edit_tool_tool_error():
 * ...     response = await admin_edit_tool(tool_id, mock_request_tool_error, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 500 and json.loads(response.body.decode())["success"] is False
 *
 * >>> asyncio.run(test_admin_edit_tool_tool_error())
 * True
 *
 * >>> # Error path: Pydantic Validation Error
 * >>> form_data_validation_error = FormData([
 * ...     ("name", "Bad_URL"),
 * ...     ("customName","Bad_Custom_Name"),
 * ...     ("url", "not-a-valid-url"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST")
 * ... ])
 * >>> mock_request_validation_error = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_validation_error.form = AsyncMock(return_value=form_data_validation_error)
 *
 * >>> async def test_admin_edit_tool_validation_error():
 * ...     response = await admin_edit_tool(tool_id, mock_request_validation_error, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 422 and json.loads(response.body.decode())["success"] is False
 *
 * >>> asyncio.run(test_admin_edit_tool_validation_error())
 * True
 *
 * >>> # Error path: Unexpected exception
 * >>> form_data_unexpected = FormData([
 * ...     ("name", "Crash_Tool"),
 * ...     ("customName", "Crash_Tool"),
 * ...     ("url", "http://crash.com"),
 * ...     ("requestType", "GET"),
 * ...     ("integrationType", "REST")
 * ... ])
 * >>> mock_request_unexpected = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_unexpected.form = AsyncMock(return_value=form_data_unexpected)
 * >>> tool_service.update_tool = AsyncMock(side_effect=Exception("Unexpected server crash"))
 *
 * >>> async def test_admin_edit_tool_unexpected_error():
 * ...     response = await admin_edit_tool(tool_id, mock_request_unexpected, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 500 and json.loads(response.body.decode())["success"] is False
 *
 * >>> asyncio.run(test_admin_edit_tool_unexpected_error())
 * True
 *
 * >>> # Restore original method
 * >>> tool_service.update_tool = original_update_tool
 */
export const adminEditToolAdminToolsToolIdEditPost2 = <ThrowOnError extends boolean = false>(options: Options<AdminEditToolAdminToolsToolIdEditPost2Data, ThrowOnError>) => (options.client ?? client).post<AdminEditToolAdminToolsToolIdEditPost2Responses, AdminEditToolAdminToolsToolIdEditPost2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/tools/{tool_id}/edit/',
    ...options
});

/**
 * Admin Delete Tool
 *
 * Delete a tool via the admin UI.
 *
 * This endpoint permanently removes a tool from the database using its ID.
 * It is irreversible and should be used with caution. The operation is logged,
 * and the user must be authenticated to access this route.
 *
 * Args:
 * tool_id (str): The ID of the tool to delete.
 * request (Request): FastAPI request object (not used directly, but required by route signature).
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * RedirectResponse: A redirect response to the tools section of the admin
 * dashboard with a status code of 303 (See Other).
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> tool_id = "tool-to-delete"
 * >>>
 * >>> # Happy path: Delete tool
 * >>> form_data_delete = FormData([("is_inactive_checked", "false")])
 * >>> mock_request_delete = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_delete.form = AsyncMock(return_value=form_data_delete)
 * >>> original_delete_tool = tool_service.delete_tool
 * >>> tool_service.delete_tool = AsyncMock()
 * >>>
 * >>> async def test_admin_delete_tool_success():
 * ...     result = await admin_delete_tool(tool_id, mock_request_delete, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "/admin#tools" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_delete_tool_success())
 * True
 * >>>
 * >>> # Edge case: Delete with inactive checkbox checked
 * >>> form_data_inactive = FormData([("is_inactive_checked", "true")])
 * >>> mock_request_inactive = MagicMock(spec=Request, scope={"root_path": "/api"})
 * >>> mock_request_inactive.form = AsyncMock(return_value=form_data_inactive)
 * >>>
 * >>> async def test_admin_delete_tool_inactive_checked():
 * ...     result = await admin_delete_tool(tool_id, mock_request_inactive, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "/api/admin/?include_inactive=true#tools" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_delete_tool_inactive_checked())
 * True
 * >>>
 * >>> # Error path: Simulate an exception during deletion
 * >>> form_data_error = FormData([])
 * >>> mock_request_error = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_error.form = AsyncMock(return_value=form_data_error)
 * >>> tool_service.delete_tool = AsyncMock(side_effect=Exception("Deletion failed"))
 * >>>
 * >>> async def test_admin_delete_tool_exception():
 * ...     result = await admin_delete_tool(tool_id, mock_request_error, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "#tools" in result.headers["location"] and "error=" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_delete_tool_exception())
 * True
 * >>>
 * >>> # Restore original method
 * >>> tool_service.delete_tool = original_delete_tool
 */
export const adminDeleteToolAdminToolsToolIdDeletePost = <ThrowOnError extends boolean = false>(options: Options<AdminDeleteToolAdminToolsToolIdDeletePostData, ThrowOnError>) => (options.client ?? client).post<AdminDeleteToolAdminToolsToolIdDeletePostResponses, AdminDeleteToolAdminToolsToolIdDeletePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/tools/{tool_id}/delete',
    ...options
});

/**
 * Admin Toggle Tool
 *
 * Toggle a tool's active status via the admin UI.
 *
 * This endpoint processes a form request to activate or deactivate a tool.
 * It expects a form field 'activate' with value "true" to activate the tool
 * or "false" to deactivate it. The endpoint handles exceptions gracefully and
 * logs any errors that might occur during the status toggle operation.
 *
 * Args:
 * tool_id (str): The ID of the tool whose status to toggle.
 * request (Request): FastAPI request containing form data with the 'activate' field.
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * RedirectResponse: A redirect to the admin dashboard tools section with a
 * status code of 303 (See Other).
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> tool_id = "tool-to-toggle"
 * >>>
 * >>> # Happy path: Activate tool
 * >>> form_data_activate = FormData([("activate", "true"), ("is_inactive_checked", "false")])
 * >>> mock_request_activate = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_activate.form = AsyncMock(return_value=form_data_activate)
 * >>> original_toggle_tool_status = tool_service.toggle_tool_status
 * >>> tool_service.toggle_tool_status = AsyncMock()
 * >>>
 * >>> async def test_admin_toggle_tool_activate():
 * ...     result = await admin_toggle_tool(tool_id, mock_request_activate, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "/admin#tools" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_toggle_tool_activate())
 * True
 * >>>
 * >>> # Happy path: Deactivate tool
 * >>> form_data_deactivate = FormData([("activate", "false"), ("is_inactive_checked", "false")])
 * >>> mock_request_deactivate = MagicMock(spec=Request, scope={"root_path": "/api"})
 * >>> mock_request_deactivate.form = AsyncMock(return_value=form_data_deactivate)
 * >>>
 * >>> async def test_admin_toggle_tool_deactivate():
 * ...     result = await admin_toggle_tool(tool_id, mock_request_deactivate, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "/api/admin#tools" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_toggle_tool_deactivate())
 * True
 * >>>
 * >>> # Edge case: Toggle with inactive checkbox checked
 * >>> form_data_inactive = FormData([("activate", "true"), ("is_inactive_checked", "true")])
 * >>> mock_request_inactive = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_inactive.form = AsyncMock(return_value=form_data_inactive)
 * >>>
 * >>> async def test_admin_toggle_tool_inactive_checked():
 * ...     result = await admin_toggle_tool(tool_id, mock_request_inactive, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "/admin/?include_inactive=true#tools" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_toggle_tool_inactive_checked())
 * True
 * >>>
 * >>> # Error path: Simulate an exception during toggle
 * >>> form_data_error = FormData([("activate", "true")])
 * >>> mock_request_error = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_error.form = AsyncMock(return_value=form_data_error)
 * >>> tool_service.toggle_tool_status = AsyncMock(side_effect=Exception("Toggle failed"))
 * >>>
 * >>> async def test_admin_toggle_tool_exception():
 * ...     result = await admin_toggle_tool(tool_id, mock_request_error, mock_db, mock_user)
 * ...     location_header = result.headers["location"]
 * ...     return (
 * ...         isinstance(result, RedirectResponse)
 * ...         and result.status_code == 303
 * ...         and "/admin" in location_header  # Ensure '/admin' is in the URL
 * ...         and "error=" in location_header  # Ensure error query param is present
 * ...         and location_header.endswith("#tools")  # Ensure fragment is correct
 * ...     )
 * >>>
 * >>> asyncio.run(test_admin_toggle_tool_exception())
 * True
 * >>>
 * >>> # Restore original method
 * >>> tool_service.toggle_tool_status = original_toggle_tool_status
 */
export const adminToggleToolAdminToolsToolIdTogglePost = <ThrowOnError extends boolean = false>(options: Options<AdminToggleToolAdminToolsToolIdTogglePostData, ThrowOnError>) => (options.client ?? client).post<AdminToggleToolAdminToolsToolIdTogglePostResponses, AdminToggleToolAdminToolsToolIdTogglePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/tools/{tool_id}/toggle',
    ...options
});

/**
 * Admin Get Gateway
 *
 * Get gateway details for the admin UI.
 *
 * Args:
 * gateway_id: Gateway ID.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * Gateway details.
 *
 * Raises:
 * HTTPException: If the gateway is not found.
 * Exception: For any other unexpected errors.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from mcpgateway.schemas import GatewayRead
 * >>> from datetime import datetime, timezone
 * >>> from mcpgateway.services.gateway_service import GatewayNotFoundError # Added import
 * >>> from fastapi import HTTPException
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> gateway_id = "test-gateway-id"
 * >>>
 * >>> # Mock gateway data
 * >>> mock_gateway = GatewayRead(
 * ...     id=gateway_id, name="Get Gateway", url="http://get.com",
 * ...     description="Gateway for getting", transport="HTTP",
 * ...     created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc),
 * ...     enabled=True, auth_type=None, auth_username=None, auth_password=None,
 * ...     auth_token=None, auth_header_key=None, auth_header_value=None,
 * ...     slug="test-gateway"
 * ... )
 * >>>
 * >>> # Mock the gateway_service.get_gateway method
 * >>> original_get_gateway = gateway_service.get_gateway
 * >>> gateway_service.get_gateway = AsyncMock(return_value=mock_gateway)
 * >>>
 * >>> # Test successful retrieval
 * >>> async def test_admin_get_gateway_success():
 * ...     result = await admin_get_gateway(gateway_id, mock_db, mock_user)
 * ...     return isinstance(result, dict) and result['id'] == gateway_id
 * >>>
 * >>> asyncio.run(test_admin_get_gateway_success())
 * True
 * >>>
 * >>> # Test gateway not found
 * >>> gateway_service.get_gateway = AsyncMock(side_effect=GatewayNotFoundError("Gateway not found"))
 * >>> async def test_admin_get_gateway_not_found():
 * ...     try:
 * ...         await admin_get_gateway("nonexistent", mock_db, mock_user)
 * ...         return False
 * ...     except HTTPException as e:
 * ...         return e.status_code == 404 and "Gateway not found" in e.detail
 * >>>
 * >>> asyncio.run(test_admin_get_gateway_not_found())
 * True
 * >>>
 * >>> # Test generic exception
 * >>> gateway_service.get_gateway = AsyncMock(side_effect=Exception("Generic error"))
 * >>> async def test_admin_get_gateway_exception():
 * ...     try:
 * ...         await admin_get_gateway(gateway_id, mock_db, mock_user)
 * ...         return False
 * ...     except Exception as e:
 * ...         return str(e) == "Generic error"
 * >>>
 * >>> asyncio.run(test_admin_get_gateway_exception())
 * True
 * >>>
 * >>> # Restore original method
 * >>> gateway_service.get_gateway = original_get_gateway
 */
export const adminGetGatewayAdminGatewaysGatewayIdGet = <ThrowOnError extends boolean = false>(options: Options<AdminGetGatewayAdminGatewaysGatewayIdGetData, ThrowOnError>) => (options.client ?? client).get<AdminGetGatewayAdminGatewaysGatewayIdGetResponses, AdminGetGatewayAdminGatewaysGatewayIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/gateways/{gateway_id}',
    ...options
});

/**
 * Admin Edit Gateway
 *
 * Edit a gateway via the admin UI.
 *
 * Expects form fields:
 * - name
 * - url
 * - description (optional)
 * - tags (optional, comma-separated)
 *
 * Args:
 * gateway_id: Gateway ID.
 * request: FastAPI request containing form data.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * A redirect response to the admin dashboard.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>> from pydantic import ValidationError
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> gateway_id = "gateway-to-edit"
 * >>>
 * >>> # Happy path: Edit gateway successfully
 * >>> form_data_success = FormData([
 * ...  ("name", "Updated Gateway"),
 * ...  ("url", "http://updated.com"),
 * ...  ("is_inactive_checked", "false"),
 * ...  ("auth_type", "basic"),
 * ...  ("auth_username", "user"),
 * ...  ("auth_password", "pass")
 * ... ])
 * >>> mock_request_success = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_success.form = AsyncMock(return_value=form_data_success)
 * >>> original_update_gateway = gateway_service.update_gateway
 * >>> gateway_service.update_gateway = AsyncMock()
 * >>>
 * >>> async def test_admin_edit_gateway_success():
 * ...     response = await admin_edit_gateway(gateway_id, mock_request_success, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 200 and json.loads(response.body)["success"] is True
 * >>>
 * >>> asyncio.run(test_admin_edit_gateway_success())
 * True
 * >>>
 * # >>> # Edge case: Edit gateway with inactive checkbox checked
 * # >>> form_data_inactive = FormData([("name", "Inactive Edit"), ("url", "http://inactive.com"), ("is_inactive_checked", "true"), ("auth_type", "basic"), ("auth_username", "user"),
 * # ...     ("auth_password", "pass")]) # Added auth_type
 * # >>> mock_request_inactive = MagicMock(spec=Request, scope={"root_path": "/api"})
 * # >>> mock_request_inactive.form = AsyncMock(return_value=form_data_inactive)
 * # >>>
 * # >>> async def test_admin_edit_gateway_inactive_checked():
 * # ...     response = await admin_edit_gateway(gateway_id, mock_request_inactive, mock_db, mock_user)
 * # ...     return isinstance(response, RedirectResponse) and response.status_code == 303 and "/api/admin/?include_inactive=true#gateways" in response.headers["location"]
 * # >>>
 * # >>> asyncio.run(test_admin_edit_gateway_inactive_checked())
 * # True
 * # >>>
 * >>> # Error path: Simulate an exception during update
 * >>> form_data_error = FormData([("name", "Error Gateway"), ("url", "http://error.com"), ("auth_type", "basic"),("auth_username", "user"),
 * ...     ("auth_password", "pass")]) # Added auth_type
 * >>> mock_request_error = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_error.form = AsyncMock(return_value=form_data_error)
 * >>> gateway_service.update_gateway = AsyncMock(side_effect=Exception("Update failed"))
 * >>>
 * >>> async def test_admin_edit_gateway_exception():
 * ...     response = await admin_edit_gateway(gateway_id, mock_request_error, mock_db, mock_user)
 * ...     return (
 * ...         isinstance(response, JSONResponse)
 * ...         and response.status_code == 500
 * ...         and json.loads(response.body)["success"] is False
 * ...         and "Update failed" in json.loads(response.body)["message"]
 * ...     )
 * >>>
 * >>> asyncio.run(test_admin_edit_gateway_exception())
 * True
 * >>>
 * >>> # Error path: Pydantic Validation Error (e.g., invalid URL format)
 * >>> form_data_validation_error = FormData([("name", "Bad URL Gateway"), ("url", "invalid-url"), ("auth_type", "basic"),("auth_username", "user"),
 * ...     ("auth_password", "pass")]) # Added auth_type
 * >>> mock_request_validation_error = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_validation_error.form = AsyncMock(return_value=form_data_validation_error)
 * >>>
 * >>> async def test_admin_edit_gateway_validation_error():
 * ...     response = await admin_edit_gateway(gateway_id, mock_request_validation_error, mock_db, mock_user)
 * ...     body = json.loads(response.body.decode())
 * ...     return isinstance(response, JSONResponse) and response.status_code in (422,400) and body["success"] is False
 * >>>
 * >>> asyncio.run(test_admin_edit_gateway_validation_error())
 * True
 * >>>
 * >>> # Restore original method
 * >>> gateway_service.update_gateway = original_update_gateway
 */
export const adminEditGatewayAdminGatewaysGatewayIdEditPost = <ThrowOnError extends boolean = false>(options: Options<AdminEditGatewayAdminGatewaysGatewayIdEditPostData, ThrowOnError>) => (options.client ?? client).post<AdminEditGatewayAdminGatewaysGatewayIdEditPostResponses, AdminEditGatewayAdminGatewaysGatewayIdEditPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/gateways/{gateway_id}/edit',
    ...options
});

/**
 * Admin Delete Gateway
 *
 * Delete a gateway via the admin UI.
 *
 * This endpoint removes a gateway from the database by its ID. The deletion is
 * permanent and cannot be undone. It requires authentication and logs the
 * operation for auditing purposes.
 *
 * Args:
 * gateway_id (str): The ID of the gateway to delete.
 * request (Request): FastAPI request object (not used directly but required by the route signature).
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * RedirectResponse: A redirect response to the gateways section of the admin
 * dashboard with a status code of 303 (See Other).
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> gateway_id = "gateway-to-delete"
 * >>>
 * >>> # Happy path: Delete gateway
 * >>> form_data_delete = FormData([("is_inactive_checked", "false")])
 * >>> mock_request_delete = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_delete.form = AsyncMock(return_value=form_data_delete)
 * >>> original_delete_gateway = gateway_service.delete_gateway
 * >>> gateway_service.delete_gateway = AsyncMock()
 * >>>
 * >>> async def test_admin_delete_gateway_success():
 * ...     result = await admin_delete_gateway(gateway_id, mock_request_delete, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "/admin#gateways" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_delete_gateway_success())
 * True
 * >>>
 * >>> # Edge case: Delete with inactive checkbox checked
 * >>> form_data_inactive = FormData([("is_inactive_checked", "true")])
 * >>> mock_request_inactive = MagicMock(spec=Request, scope={"root_path": "/api"})
 * >>> mock_request_inactive.form = AsyncMock(return_value=form_data_inactive)
 * >>>
 * >>> async def test_admin_delete_gateway_inactive_checked():
 * ...     result = await admin_delete_gateway(gateway_id, mock_request_inactive, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "/api/admin/?include_inactive=true#gateways" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_delete_gateway_inactive_checked())
 * True
 * >>>
 * >>> # Error path: Simulate an exception during deletion
 * >>> form_data_error = FormData([])
 * >>> mock_request_error = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_error.form = AsyncMock(return_value=form_data_error)
 * >>> gateway_service.delete_gateway = AsyncMock(side_effect=Exception("Deletion failed"))
 * >>>
 * >>> async def test_admin_delete_gateway_exception():
 * ...     result = await admin_delete_gateway(gateway_id, mock_request_error, mock_db, mock_user)
 * ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and "#gateways" in result.headers["location"] and "error=" in result.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_delete_gateway_exception())
 * True
 * >>>
 * >>> # Restore original method
 * >>> gateway_service.delete_gateway = original_delete_gateway
 */
export const adminDeleteGatewayAdminGatewaysGatewayIdDeletePost = <ThrowOnError extends boolean = false>(options: Options<AdminDeleteGatewayAdminGatewaysGatewayIdDeletePostData, ThrowOnError>) => (options.client ?? client).post<AdminDeleteGatewayAdminGatewaysGatewayIdDeletePostResponses, AdminDeleteGatewayAdminGatewaysGatewayIdDeletePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/gateways/{gateway_id}/delete',
    ...options
});

/**
 * Admin Get Resource
 *
 * Get resource details for the admin UI.
 *
 * Args:
 * resource_id: Resource ID.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * A dictionary containing resource details and its content.
 *
 * Raises:
 * HTTPException: If the resource is not found.
 * Exception: For any other unexpected errors.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from mcpgateway.schemas import ResourceRead, ResourceMetrics, ResourceContent
 * >>> from datetime import datetime, timezone
 * >>> from mcpgateway.services.resource_service import ResourceNotFoundError # Added import
 * >>> from fastapi import HTTPException
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> resource_uri = "test://resource/get"
 * >>> resource_id = 1
 * >>>
 * >>> # Mock resource data
 * >>> mock_resource = ResourceRead(
 * ...     id=resource_id, uri=resource_uri, name="Get Resource", description="Test",
 * ...     mime_type="text/plain", size=10, created_at=datetime.now(timezone.utc),
 * ...     updated_at=datetime.now(timezone.utc), is_active=True, metrics=ResourceMetrics(
 * ...         total_executions=0, successful_executions=0, failed_executions=0,
 * ...         failure_rate=0.0, min_response_time=0.0, max_response_time=0.0, avg_response_time=0.0,
 * ...         last_execution_time=None
 * ...     ),
 * ...     tags=[]
 * ... )
 * >>> mock_content = ResourceContent(id=str(resource_id), type="resource", uri=resource_uri, mime_type="text/plain", text="Hello content")
 * >>>
 * >>> # Mock service methods
 * >>> original_get_resource_by_id = resource_service.get_resource_by_id
 * >>> original_read_resource = resource_service.read_resource
 * >>> resource_service.get_resource_by_id = AsyncMock(return_value=mock_resource)
 * >>> resource_service.read_resource = AsyncMock(return_value=mock_content)
 * >>>
 * >>> # Test successful retrieval
 * >>> async def test_admin_get_resource_success():
 * ...     result = await admin_get_resource(resource_id, mock_db, mock_user)
 * ...     return isinstance(result, dict) and result['resource']['id'] == resource_id and result['content'].text == "Hello content" # Corrected to .text
 * >>>
 * >>> asyncio.run(test_admin_get_resource_success())
 * True
 * >>>
 * >>> # Test resource not found
 * >>> resource_service.get_resource_by_id = AsyncMock(side_effect=ResourceNotFoundError("Resource not found"))
 * >>> async def test_admin_get_resource_not_found():
 * ...     try:
 * ...         await admin_get_resource(999, mock_db, mock_user)
 * ...         return False
 * ...     except HTTPException as e:
 * ...         return e.status_code == 404 and "Resource not found" in e.detail
 * >>>
 * >>> asyncio.run(test_admin_get_resource_not_found())
 * True
 * >>>
 * >>> # Test exception during content read (resource found but content fails)
 * >>> resource_service.get_resource_by_id = AsyncMock(return_value=mock_resource) # Resource found
 * >>> resource_service.read_resource = AsyncMock(side_effect=Exception("Content read error"))
 * >>> async def test_admin_get_resource_content_error():
 * ...     try:
 * ...         await admin_get_resource(resource_id, mock_db, mock_user)
 * ...         return False
 * ...     except Exception as e:
 * ...         return str(e) == "Content read error"
 * >>>
 * >>> asyncio.run(test_admin_get_resource_content_error())
 * True
 * >>>
 * >>> # Restore original methods
 * >>> resource_service.get_resource_by_id = original_get_resource_by_id
 * >>> resource_service.read_resource = original_read_resource
 */
export const adminGetResourceAdminResourcesResourceIdGet = <ThrowOnError extends boolean = false>(options: Options<AdminGetResourceAdminResourcesResourceIdGetData, ThrowOnError>) => (options.client ?? client).get<AdminGetResourceAdminResourcesResourceIdGetResponses, AdminGetResourceAdminResourcesResourceIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/resources/{resource_id}',
    ...options
});

/**
 * Admin Edit Resource
 *
 * Edit a resource via the admin UI.
 *
 * Expects form fields:
 * - name
 * - description (optional)
 * - mime_type (optional)
 * - content
 *
 * Args:
 * resource_id: Resource ID.
 * request: FastAPI request containing form data.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * JSONResponse: A JSON response indicating success or failure of the resource update operation.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> form_data = FormData([
 * ...     ("name", "Updated Resource"),
 * ...     ("description", "Updated description"),
 * ...     ("mimeType", "text/plain"),
 * ...     ("content", "Updated content"),
 * ... ])
 * >>> mock_request = MagicMock(spec=Request)
 * >>> mock_request.form = AsyncMock(return_value=form_data)
 * >>> mock_request.scope = {"root_path": ""}
 * >>>
 * >>> original_update_resource = resource_service.update_resource
 * >>> resource_service.update_resource = AsyncMock()
 * >>>
 * >>> # Test successful update
 * >>> async def test_admin_edit_resource():
 * ...     response = await admin_edit_resource("test://resource1", mock_request, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 200 and response.body == b'{"message":"Resource updated successfully!","success":true}'
 * >>>
 * >>> asyncio.run(test_admin_edit_resource())
 * True
 * >>>
 * >>> # Test validation error
 * >>> from pydantic import ValidationError
 * >>> validation_error = ValidationError.from_exception_data("Resource validation error", [
 * ...     {"loc": ("name",), "msg": "Field required", "type": "missing"}
 * ... ])
 * >>> resource_service.update_resource = AsyncMock(side_effect=validation_error)
 * >>> async def test_admin_edit_resource_validation():
 * ...     response = await admin_edit_resource("test://resource1", mock_request, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 422
 * >>>
 * >>> asyncio.run(test_admin_edit_resource_validation())
 * True
 * >>>
 * >>> # Test integrity error (e.g., duplicate resource)
 * >>> from sqlalchemy.exc import IntegrityError
 * >>> integrity_error = IntegrityError("Duplicate entry", None, None)
 * >>> resource_service.update_resource = AsyncMock(side_effect=integrity_error)
 * >>> async def test_admin_edit_resource_integrity():
 * ...     response = await admin_edit_resource("test://resource1", mock_request, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 409
 * >>>
 * >>> asyncio.run(test_admin_edit_resource_integrity())
 * True
 * >>>
 * >>> # Test unknown error
 * >>> resource_service.update_resource = AsyncMock(side_effect=Exception("Unknown error"))
 * >>> async def test_admin_edit_resource_unknown():
 * ...     response = await admin_edit_resource("test://resource1", mock_request, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 500 and b'Unknown error' in response.body
 * >>>
 * >>> asyncio.run(test_admin_edit_resource_unknown())
 * True
 * >>>
 * >>> # Reset mock
 * >>> resource_service.update_resource = original_update_resource
 */
export const adminEditResourceAdminResourcesResourceIdEditPost = <ThrowOnError extends boolean = false>(options: Options<AdminEditResourceAdminResourcesResourceIdEditPostData, ThrowOnError>) => (options.client ?? client).post<AdminEditResourceAdminResourcesResourceIdEditPostResponses, AdminEditResourceAdminResourcesResourceIdEditPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/resources/{resource_id}/edit',
    ...options
});

/**
 * Admin Delete Resource
 *
 * Delete a resource via the admin UI.
 *
 * This endpoint permanently removes a resource from the database using its resource ID.
 * The operation is irreversible and should be used with caution. It requires
 * user authentication and logs the deletion attempt.
 *
 * Args:
 * resource_id (str): The ID of the resource to delete.
 * request (Request): FastAPI request object (not used directly but required by the route signature).
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * RedirectResponse: A redirect response to the resources section of the admin
 * dashboard with a status code of 303 (See Other).
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> mock_request = MagicMock(spec=Request)
 * >>> form_data = FormData([("is_inactive_checked", "false")])
 * >>> mock_request.form = AsyncMock(return_value=form_data)
 * >>> mock_request.scope = {"root_path": ""}
 * >>>
 * >>> original_delete_resource = resource_service.delete_resource
 * >>> resource_service.delete_resource = AsyncMock()
 * >>>
 * >>> async def test_admin_delete_resource():
 * ...     response = await admin_delete_resource("test://resource1", mock_request, mock_db, mock_user)
 * ...     return isinstance(response, RedirectResponse) and response.status_code == 303
 * >>>
 * >>> import asyncio; asyncio.run(test_admin_delete_resource())
 * True
 * >>>
 * >>> # Test with inactive checkbox checked
 * >>> form_data_inactive = FormData([("is_inactive_checked", "true")])
 * >>> mock_request.form = AsyncMock(return_value=form_data_inactive)
 * >>>
 * >>> async def test_admin_delete_resource_inactive():
 * ...     response = await admin_delete_resource("test://resource1", mock_request, mock_db, mock_user)
 * ...     return isinstance(response, RedirectResponse) and "include_inactive=true" in response.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_delete_resource_inactive())
 * True
 * >>> resource_service.delete_resource = original_delete_resource
 */
export const adminDeleteResourceAdminResourcesResourceIdDeletePost = <ThrowOnError extends boolean = false>(options: Options<AdminDeleteResourceAdminResourcesResourceIdDeletePostData, ThrowOnError>) => (options.client ?? client).post<AdminDeleteResourceAdminResourcesResourceIdDeletePostResponses, AdminDeleteResourceAdminResourcesResourceIdDeletePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/resources/{resource_id}/delete',
    ...options
});

/**
 * Admin Toggle Resource
 *
 * Toggle a resource's active status via the admin UI.
 *
 * This endpoint processes a form request to activate or deactivate a resource.
 * It expects a form field 'activate' with value "true" to activate the resource
 * or "false" to deactivate it. The endpoint handles exceptions gracefully and
 * logs any errors that might occur during the status toggle operation.
 *
 * Args:
 * resource_id (int): The ID of the resource whose status to toggle.
 * request (Request): FastAPI request containing form data with the 'activate' field.
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * RedirectResponse: A redirect to the admin dashboard resources section with a
 * status code of 303 (See Other).
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> mock_request = MagicMock(spec=Request)
 * >>> form_data = FormData([
 * ...     ("activate", "true"),
 * ...     ("is_inactive_checked", "false")
 * ... ])
 * >>> mock_request.form = AsyncMock(return_value=form_data)
 * >>> mock_request.scope = {"root_path": ""}
 * >>>
 * >>> original_toggle_resource_status = resource_service.toggle_resource_status
 * >>> resource_service.toggle_resource_status = AsyncMock()
 * >>>
 * >>> async def test_admin_toggle_resource():
 * ...     response = await admin_toggle_resource(1, mock_request, mock_db, mock_user)
 * ...     return isinstance(response, RedirectResponse) and response.status_code == 303
 * >>>
 * >>> asyncio.run(test_admin_toggle_resource())
 * True
 * >>>
 * >>> # Test with activate=false
 * >>> form_data_deactivate = FormData([
 * ...     ("activate", "false"),
 * ...     ("is_inactive_checked", "false")
 * ... ])
 * >>> mock_request.form = AsyncMock(return_value=form_data_deactivate)
 * >>>
 * >>> async def test_admin_toggle_resource_deactivate():
 * ...     response = await admin_toggle_resource(1, mock_request, mock_db, mock_user)
 * ...     return isinstance(response, RedirectResponse) and response.status_code == 303
 * >>>
 * >>> asyncio.run(test_admin_toggle_resource_deactivate())
 * True
 * >>>
 * >>> # Test with inactive checkbox checked
 * >>> form_data_inactive = FormData([
 * ...     ("activate", "true"),
 * ...     ("is_inactive_checked", "true")
 * ... ])
 * >>> mock_request.form = AsyncMock(return_value=form_data_inactive)
 * >>>
 * >>> async def test_admin_toggle_resource_inactive():
 * ...     response = await admin_toggle_resource(1, mock_request, mock_db, mock_user)
 * ...     return isinstance(response, RedirectResponse) and "include_inactive=true" in response.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_toggle_resource_inactive())
 * True
 * >>>
 * >>> # Test exception handling
 * >>> resource_service.toggle_resource_status = AsyncMock(side_effect=Exception("Test error"))
 * >>> form_data_error = FormData([
 * ...     ("activate", "true"),
 * ...     ("is_inactive_checked", "false")
 * ... ])
 * >>> mock_request.form = AsyncMock(return_value=form_data_error)
 * >>>
 * >>> async def test_admin_toggle_resource_exception():
 * ...     response = await admin_toggle_resource(1, mock_request, mock_db, mock_user)
 * ...     return isinstance(response, RedirectResponse) and response.status_code == 303
 * >>>
 * >>> asyncio.run(test_admin_toggle_resource_exception())
 * True
 * >>> resource_service.toggle_resource_status = original_toggle_resource_status
 */
export const adminToggleResourceAdminResourcesResourceIdTogglePost = <ThrowOnError extends boolean = false>(options: Options<AdminToggleResourceAdminResourcesResourceIdTogglePostData, ThrowOnError>) => (options.client ?? client).post<AdminToggleResourceAdminResourcesResourceIdTogglePostResponses, AdminToggleResourceAdminResourcesResourceIdTogglePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/resources/{resource_id}/toggle',
    ...options
});

/**
 * Admin Get Prompt
 *
 * Get prompt details for the admin UI.
 *
 * Args:
 * prompt_id: Prompt ID.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * A dictionary with prompt details.
 *
 * Raises:
 * HTTPException: If the prompt is not found.
 * Exception: For any other unexpected errors.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from mcpgateway.schemas import PromptRead, PromptMetrics
 * >>> from datetime import datetime, timezone
 * >>> from mcpgateway.services.prompt_service import PromptNotFoundError # Added import
 * >>> from fastapi import HTTPException
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> prompt_name = "test-prompt"
 * >>>
 * >>> # Mock prompt details
 * >>> mock_metrics = PromptMetrics(
 * ...     total_executions=3,
 * ...     successful_executions=3,
 * ...     failed_executions=0,
 * ...     failure_rate=0.0,
 * ...     min_response_time=0.1,
 * ...     max_response_time=0.5,
 * ...     avg_response_time=0.3,
 * ...     last_execution_time=datetime.now(timezone.utc)
 * ... )
 * >>> mock_prompt_details = {
 * ...     "id": 1,
 * ...     "name": prompt_name,
 * ...     "description": "A test prompt",
 * ...     "template": "Hello {{name}}!",
 * ...     "arguments": [{"name": "name", "type": "string"}],
 * ...     "created_at": datetime.now(timezone.utc),
 * ...     "updated_at": datetime.now(timezone.utc),
 * ...     "is_active": True,
 * ...     "metrics": mock_metrics,
 * ...     "tags": []
 * ... }
 * >>>
 * >>> original_get_prompt_details = prompt_service.get_prompt_details
 * >>> prompt_service.get_prompt_details = AsyncMock(return_value=mock_prompt_details)
 * >>>
 * >>> async def test_admin_get_prompt():
 * ...     result = await admin_get_prompt(prompt_name, mock_db, mock_user)
 * ...     return isinstance(result, dict) and result.get("name") == prompt_name
 * >>>
 * >>> asyncio.run(test_admin_get_prompt())
 * True
 * >>>
 * >>> # Test prompt not found
 * >>> prompt_service.get_prompt_details = AsyncMock(side_effect=PromptNotFoundError("Prompt not found"))
 * >>> async def test_admin_get_prompt_not_found():
 * ...     try:
 * ...         await admin_get_prompt("nonexistent", mock_db, mock_user)
 * ...         return False
 * ...     except HTTPException as e:
 * ...         return e.status_code == 404 and "Prompt not found" in e.detail
 * >>>
 * >>> asyncio.run(test_admin_get_prompt_not_found())
 * True
 * >>>
 * >>> # Test generic exception
 * >>> prompt_service.get_prompt_details = AsyncMock(side_effect=Exception("Generic error"))
 * >>> async def test_admin_get_prompt_exception():
 * ...     try:
 * ...         await admin_get_prompt(prompt_name, mock_db, mock_user)
 * ...         return False
 * ...     except Exception as e:
 * ...         return str(e) == "Generic error"
 * >>>
 * >>> asyncio.run(test_admin_get_prompt_exception())
 * True
 * >>>
 * >>> prompt_service.get_prompt_details = original_get_prompt_details
 */
export const adminGetPromptAdminPromptsPromptIdGet = <ThrowOnError extends boolean = false>(options: Options<AdminGetPromptAdminPromptsPromptIdGetData, ThrowOnError>) => (options.client ?? client).get<AdminGetPromptAdminPromptsPromptIdGetResponses, AdminGetPromptAdminPromptsPromptIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/prompts/{prompt_id}',
    ...options
});

/**
 * Admin Edit Prompt
 *
 * Edit a prompt via the admin UI.
 *
 * Expects form fields:
 * - name
 * - description (optional)
 * - template
 * - arguments (as a JSON string representing a list)
 *
 * Args:
 * prompt_id: Prompt ID.
 * request: FastAPI request containing form data.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * JSONResponse: A JSON response indicating success or failure of the server update operation.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from starlette.datastructures import FormData
 * >>> from fastapi.responses import JSONResponse
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> prompt_name = "test-prompt"
 * >>> form_data = FormData([
 * ...     ("name", "Updated Prompt"),
 * ...     ("description", "Updated description"),
 * ...     ("template", "Hello {{name}}, welcome!"),
 * ...     ("arguments", '[{"name": "name", "type": "string"}]'),
 * ...     ("is_inactive_checked", "false")
 * ... ])
 * >>> mock_request = MagicMock(spec=Request)
 * >>> mock_request.form = AsyncMock(return_value=form_data)
 * >>> mock_request.scope = {"root_path": ""}
 * >>>
 * >>> original_update_prompt = prompt_service.update_prompt
 * >>> prompt_service.update_prompt = AsyncMock()
 * >>>
 * >>> async def test_admin_edit_prompt():
 * ...     response = await admin_edit_prompt(prompt_name, mock_request, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 200 and response.body == b'{"message":"Prompt updated successfully!","success":true}'
 * >>>
 * >>> asyncio.run(test_admin_edit_prompt())
 * True
 * >>>
 * >>> # Test with inactive checkbox checked
 * >>> form_data_inactive = FormData([
 * ...     ("name", "Updated Prompt"),
 * ...     ("template", "Hello {{name}}!"),
 * ...     ("arguments", "[]"),
 * ...     ("is_inactive_checked", "true")
 * ... ])
 * >>> mock_request.form = AsyncMock(return_value=form_data_inactive)
 * >>>
 * >>> async def test_admin_edit_prompt_inactive():
 * ...     response = await admin_edit_prompt(prompt_name, mock_request, mock_db, mock_user)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 200 and b"Prompt updated successfully!" in response.body
 * >>>
 * >>> asyncio.run(test_admin_edit_prompt_inactive())
 * True
 * >>> prompt_service.update_prompt = original_update_prompt
 */
export const adminEditPromptAdminPromptsPromptIdEditPost = <ThrowOnError extends boolean = false>(options: Options<AdminEditPromptAdminPromptsPromptIdEditPostData, ThrowOnError>) => (options.client ?? client).post<AdminEditPromptAdminPromptsPromptIdEditPostResponses, AdminEditPromptAdminPromptsPromptIdEditPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/prompts/{prompt_id}/edit',
    ...options
});

/**
 * Admin Delete Prompt
 *
 * Delete a prompt via the admin UI.
 *
 * This endpoint permanently deletes a prompt from the database using its ID.
 * Deletion is irreversible and requires authentication. All actions are logged
 * for administrative auditing.
 *
 * Args:
 * prompt_id (str): The ID of the prompt to delete.
 * request (Request): FastAPI request object (not used directly but required by the route signature).
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * RedirectResponse: A redirect response to the prompts section of the admin
 * dashboard with a status code of 303 (See Other).
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> mock_request = MagicMock(spec=Request)
 * >>> form_data = FormData([("is_inactive_checked", "false")])
 * >>> mock_request.form = AsyncMock(return_value=form_data)
 * >>> mock_request.scope = {"root_path": ""}
 * >>>
 * >>> original_delete_prompt = prompt_service.delete_prompt
 * >>> prompt_service.delete_prompt = AsyncMock()
 * >>>
 * >>> async def test_admin_delete_prompt():
 * ...     response = await admin_delete_prompt("test-prompt", mock_request, mock_db, mock_user)
 * ...     return isinstance(response, RedirectResponse) and response.status_code == 303
 * >>>
 * >>> asyncio.run(test_admin_delete_prompt())
 * True
 * >>>
 * >>> # Test with inactive checkbox checked
 * >>> form_data_inactive = FormData([("is_inactive_checked", "true")])
 * >>> mock_request.form = AsyncMock(return_value=form_data_inactive)
 * >>>
 * >>> async def test_admin_delete_prompt_inactive():
 * ...     response = await admin_delete_prompt("test-prompt", mock_request, mock_db, mock_user)
 * ...     return isinstance(response, RedirectResponse) and "include_inactive=true" in response.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_delete_prompt_inactive())
 * True
 * >>> prompt_service.delete_prompt = original_delete_prompt
 */
export const adminDeletePromptAdminPromptsPromptIdDeletePost = <ThrowOnError extends boolean = false>(options: Options<AdminDeletePromptAdminPromptsPromptIdDeletePostData, ThrowOnError>) => (options.client ?? client).post<AdminDeletePromptAdminPromptsPromptIdDeletePostResponses, AdminDeletePromptAdminPromptsPromptIdDeletePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/prompts/{prompt_id}/delete',
    ...options
});

/**
 * Admin Toggle Prompt
 *
 * Toggle a prompt's active status via the admin UI.
 *
 * This endpoint processes a form request to activate or deactivate a prompt.
 * It expects a form field 'activate' with value "true" to activate the prompt
 * or "false" to deactivate it. The endpoint handles exceptions gracefully and
 * logs any errors that might occur during the status toggle operation.
 *
 * Args:
 * prompt_id (int): The ID of the prompt whose status to toggle.
 * request (Request): FastAPI request containing form data with the 'activate' field.
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * RedirectResponse: A redirect to the admin dashboard prompts section with a
 * status code of 303 (See Other).
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> mock_request = MagicMock(spec=Request)
 * >>> form_data = FormData([
 * ...     ("activate", "true"),
 * ...     ("is_inactive_checked", "false")
 * ... ])
 * >>> mock_request.form = AsyncMock(return_value=form_data)
 * >>> mock_request.scope = {"root_path": ""}
 * >>>
 * >>> original_toggle_prompt_status = prompt_service.toggle_prompt_status
 * >>> prompt_service.toggle_prompt_status = AsyncMock()
 * >>>
 * >>> async def test_admin_toggle_prompt():
 * ...     response = await admin_toggle_prompt(1, mock_request, mock_db, mock_user)
 * ...     return isinstance(response, RedirectResponse) and response.status_code == 303
 * >>>
 * >>> asyncio.run(test_admin_toggle_prompt())
 * True
 * >>>
 * >>> # Test with activate=false
 * >>> form_data_deactivate = FormData([
 * ...     ("activate", "false"),
 * ...     ("is_inactive_checked", "false")
 * ... ])
 * >>> mock_request.form = AsyncMock(return_value=form_data_deactivate)
 * >>>
 * >>> async def test_admin_toggle_prompt_deactivate():
 * ...     response = await admin_toggle_prompt(1, mock_request, mock_db, mock_user)
 * ...     return isinstance(response, RedirectResponse) and response.status_code == 303
 * >>>
 * >>> asyncio.run(test_admin_toggle_prompt_deactivate())
 * True
 * >>>
 * >>> # Test with inactive checkbox checked
 * >>> form_data_inactive = FormData([
 * ...     ("activate", "true"),
 * ...     ("is_inactive_checked", "true")
 * ... ])
 * >>> mock_request.form = AsyncMock(return_value=form_data_inactive)
 * >>>
 * >>> async def test_admin_toggle_prompt_inactive():
 * ...     response = await admin_toggle_prompt(1, mock_request, mock_db, mock_user)
 * ...     return isinstance(response, RedirectResponse) and "include_inactive=true" in response.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_toggle_prompt_inactive())
 * True
 * >>>
 * >>> # Test exception handling
 * >>> prompt_service.toggle_prompt_status = AsyncMock(side_effect=Exception("Test error"))
 * >>> form_data_error = FormData([
 * ...     ("activate", "true"),
 * ...     ("is_inactive_checked", "false")
 * ... ])
 * >>> mock_request.form = AsyncMock(return_value=form_data_error)
 * >>>
 * >>> async def test_admin_toggle_prompt_exception():
 * ...     response = await admin_toggle_prompt(1, mock_request, mock_db, mock_user)
 * ...     return isinstance(response, RedirectResponse) and response.status_code == 303
 * >>>
 * >>> asyncio.run(test_admin_toggle_prompt_exception())
 * True
 * >>> prompt_service.toggle_prompt_status = original_toggle_prompt_status
 */
export const adminTogglePromptAdminPromptsPromptIdTogglePost = <ThrowOnError extends boolean = false>(options: Options<AdminTogglePromptAdminPromptsPromptIdTogglePostData, ThrowOnError>) => (options.client ?? client).post<AdminTogglePromptAdminPromptsPromptIdTogglePostResponses, AdminTogglePromptAdminPromptsPromptIdTogglePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/prompts/{prompt_id}/toggle',
    ...options
});

/**
 * Admin Add Root
 *
 * Add a new root via the admin UI.
 *
 * Expects form fields:
 * - path
 * - name (optional)
 *
 * Args:
 * request: FastAPI request containing form data.
 * user: Authenticated user.
 *
 * Returns:
 * RedirectResponse: A redirect response to the admin dashboard.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> mock_request = MagicMock(spec=Request)
 * >>> form_data = FormData([
 * ...     ("uri", "test://root1"),
 * ...     ("name", "Test Root"),
 * ... ])
 * >>> mock_request.form = AsyncMock(return_value=form_data)
 * >>> mock_request.scope = {"root_path": ""}
 * >>>
 * >>> original_add_root = root_service.add_root
 * >>> root_service.add_root = AsyncMock()
 * >>>
 * >>> async def test_admin_add_root():
 * ...     response = await admin_add_root(mock_request, mock_user)
 * ...     return isinstance(response, RedirectResponse) and response.status_code == 303
 * >>>
 * >>> asyncio.run(test_admin_add_root())
 * True
 * >>> root_service.add_root = original_add_root
 */
export const adminAddRootAdminRootsPost = <ThrowOnError extends boolean = false>(options?: Options<AdminAddRootAdminRootsPostData, ThrowOnError>) => (options?.client ?? client).post<AdminAddRootAdminRootsPostResponses, AdminAddRootAdminRootsPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/roots',
    ...options
});

/**
 * Admin Delete Root
 *
 * Delete a root via the admin UI.
 *
 * This endpoint removes a registered root URI from the system. The deletion is
 * permanent and cannot be undone. It requires authentication and logs the
 * operation for audit purposes.
 *
 * Args:
 * uri (str): The URI of the root to delete.
 * request (Request): FastAPI request object (not used directly but required by the route signature).
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * RedirectResponse: A redirect response to the roots section of the admin
 * dashboard with a status code of 303 (See Other).
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from fastapi import Request
 * >>> from fastapi.responses import RedirectResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> mock_request = MagicMock(spec=Request)
 * >>> form_data = FormData([("is_inactive_checked", "false")])
 * >>> mock_request.form = AsyncMock(return_value=form_data)
 * >>> mock_request.scope = {"root_path": ""}
 * >>>
 * >>> original_remove_root = root_service.remove_root
 * >>> root_service.remove_root = AsyncMock()
 * >>>
 * >>> async def test_admin_delete_root():
 * ...     response = await admin_delete_root("test://root1", mock_request, mock_user)
 * ...     return isinstance(response, RedirectResponse) and response.status_code == 303
 * >>>
 * >>> asyncio.run(test_admin_delete_root())
 * True
 * >>>
 * >>> # Test with inactive checkbox checked
 * >>> form_data_inactive = FormData([("is_inactive_checked", "true")])
 * >>> mock_request.form = AsyncMock(return_value=form_data_inactive)
 * >>>
 * >>> async def test_admin_delete_root_inactive():
 * ...     response = await admin_delete_root("test://root1", mock_request, mock_user)
 * ...     return isinstance(response, RedirectResponse) and "include_inactive=true" in response.headers["location"]
 * >>>
 * >>> asyncio.run(test_admin_delete_root_inactive())
 * True
 * >>> root_service.remove_root = original_remove_root
 */
export const adminDeleteRootAdminRootsUriDeletePost = <ThrowOnError extends boolean = false>(options: Options<AdminDeleteRootAdminRootsUriDeletePostData, ThrowOnError>) => (options.client ?? client).post<AdminDeleteRootAdminRootsUriDeletePostResponses, AdminDeleteRootAdminRootsUriDeletePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/roots/{uri}/delete',
    ...options
});

/**
 * Get Aggregated Metrics
 *
 * Retrieve aggregated metrics and top performers for all entity types.
 *
 * This endpoint collects usage metrics and top-performing entities for tools,
 * resources, prompts, and servers by calling the respective service methods.
 * The results are compiled into a dictionary for administrative monitoring.
 *
 * Args:
 * db (Session): Database session dependency for querying metrics.
 *
 * Returns:
 * Dict[str, Any]: A dictionary containing aggregated metrics and top performers
 * for tools, resources, prompts, and servers. The structure includes:
 * - 'tools': Metrics for tools.
 * - 'resources': Metrics for resources.
 * - 'prompts': Metrics for prompts.
 * - 'servers': Metrics for servers.
 * - 'topPerformers': A nested dictionary with all tools, resources, prompts,
 * and servers with their metrics.
 */
export const getAggregatedMetricsAdminMetricsGet = <ThrowOnError extends boolean = false>(options?: Options<GetAggregatedMetricsAdminMetricsGetData, ThrowOnError>) => (options?.client ?? client).get<GetAggregatedMetricsAdminMetricsGetResponses, GetAggregatedMetricsAdminMetricsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/metrics',
    ...options
});

/**
 * Admin Reset Metrics
 *
 * Reset all metrics for tools, resources, servers, and prompts.
 * Each service must implement its own reset_metrics method.
 *
 * Args:
 * db (Session): Database session dependency.
 * user (str): Authenticated user dependency.
 *
 * Returns:
 * Dict[str, object]: A dictionary containing a success message and status.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>>
 * >>> original_reset_metrics_tool = tool_service.reset_metrics
 * >>> original_reset_metrics_resource = resource_service.reset_metrics
 * >>> original_reset_metrics_server = server_service.reset_metrics
 * >>> original_reset_metrics_prompt = prompt_service.reset_metrics
 * >>>
 * >>> tool_service.reset_metrics = AsyncMock()
 * >>> resource_service.reset_metrics = AsyncMock()
 * >>> server_service.reset_metrics = AsyncMock()
 * >>> prompt_service.reset_metrics = AsyncMock()
 * >>>
 * >>> async def test_admin_reset_metrics():
 * ...     result = await admin_reset_metrics(mock_db, mock_user)
 * ...     return result == {"message": "All metrics reset successfully", "success": True}
 * >>>
 * >>> import asyncio; asyncio.run(test_admin_reset_metrics())
 * True
 * >>>
 * >>> tool_service.reset_metrics = original_reset_metrics_tool
 * >>> resource_service.reset_metrics = original_reset_metrics_resource
 * >>> server_service.reset_metrics = original_reset_metrics_server
 * >>> prompt_service.reset_metrics = original_reset_metrics_prompt
 */
export const adminResetMetricsAdminMetricsResetPost = <ThrowOnError extends boolean = false>(options?: Options<AdminResetMetricsAdminMetricsResetPostData, ThrowOnError>) => (options?.client ?? client).post<AdminResetMetricsAdminMetricsResetPostResponses, AdminResetMetricsAdminMetricsResetPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/metrics/reset',
    ...options
});

/**
 * Admin Test Gateway
 *
 * Test a gateway by sending a request to its URL.
 * This endpoint allows administrators to test the connectivity and response
 *
 * Args:
 * request (GatewayTestRequest): The request object containing the gateway URL and request details.
 * team_id (Optional[str]): Optional team ID for team-specific gateways.
 * user (str): Authenticated user dependency.
 * db (Session): Database session dependency.
 *
 * Returns:
 * GatewayTestResponse: The response from the gateway, including status code, latency, and body
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from mcpgateway.schemas import GatewayTestRequest, GatewayTestResponse
 * >>> from fastapi import Request
 * >>> import httpx
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> mock_request = GatewayTestRequest(
 * ...     base_url="https://api.example.com",
 * ...     path="/test",
 * ...     method="GET",
 * ...     headers={},
 * ...     body=None
 * ... )
 * >>>
 * >>> # Mock ResilientHttpClient to simulate a successful response
 * >>> class MockResponse:
 * ...     def __init__(self):
 * ...         self.status_code = 200
 * ...         self._json = {"message": "success"}
 * ...     def json(self):
 * ...         return self._json
 * ...     @property
 * ...     def text(self):
 * ...         return str(self._json)
 * >>>
 * >>> class MockClient:
 * ...     async def __aenter__(self):
 * ...         return self
 * ...     async def __aexit__(self, exc_type, exc, tb):
 * ...         pass
 * ...     async def request(self, method, url, headers=None, json=None):
 * ...         return MockResponse()
 * >>>
 * >>> from unittest.mock import patch
 * >>>
 * >>> async def test_admin_test_gateway():
 * ...     with patch('mcpgateway.admin.ResilientHttpClient') as mock_client_class:
 * ...         mock_client_class.return_value = MockClient()
 * ...         response = await admin_test_gateway(mock_request, mock_user)
 * ...         return isinstance(response, GatewayTestResponse) and response.status_code == 200
 * >>>
 * >>> result = asyncio.run(test_admin_test_gateway())
 * >>> result
 * True
 * >>>
 * >>> # Test with JSON decode error
 * >>> class MockResponseTextOnly:
 * ...     def __init__(self):
 * ...         self.status_code = 200
 * ...         self.text = "plain text response"
 * ...     def json(self):
 * ...         raise json.JSONDecodeError("Invalid JSON", "doc", 0)
 * >>>
 * >>> class MockClientTextOnly:
 * ...     async def __aenter__(self):
 * ...         return self
 * ...     async def __aexit__(self, exc_type, exc, tb):
 * ...         pass
 * ...     async def request(self, method, url, headers=None, json=None):
 * ...         return MockResponseTextOnly()
 * >>>
 * >>> async def test_admin_test_gateway_text_response():
 * ...     with patch('mcpgateway.admin.ResilientHttpClient') as mock_client_class:
 * ...         mock_client_class.return_value = MockClientTextOnly()
 * ...         response = await admin_test_gateway(mock_request, mock_user)
 * ...         return isinstance(response, GatewayTestResponse) and response.body.get("details") == "plain text response"
 * >>>
 * >>> asyncio.run(test_admin_test_gateway_text_response())
 * True
 * >>>
 * >>> # Test with network error
 * >>> class MockClientError:
 * ...     async def __aenter__(self):
 * ...         return self
 * ...     async def __aexit__(self, exc_type, exc, tb):
 * ...         pass
 * ...     async def request(self, method, url, headers=None, json=None):
 * ...         raise httpx.RequestError("Network error")
 * >>>
 * >>> async def test_admin_test_gateway_network_error():
 * ...     with patch('mcpgateway.admin.ResilientHttpClient') as mock_client_class:
 * ...         mock_client_class.return_value = MockClientError()
 * ...         response = await admin_test_gateway(mock_request, mock_user)
 * ...         return response.status_code == 502 and "Network error" in str(response.body)
 * >>>
 * >>> asyncio.run(test_admin_test_gateway_network_error())
 * True
 * >>>
 * >>> # Test with POST method and body
 * >>> mock_request_post = GatewayTestRequest(
 * ...     base_url="https://api.example.com",
 * ...     path="/test",
 * ...     method="POST",
 * ...     headers={"Content-Type": "application/json"},
 * ...     body={"test": "data"}
 * ... )
 * >>>
 * >>> async def test_admin_test_gateway_post():
 * ...     with patch('mcpgateway.admin.ResilientHttpClient') as mock_client_class:
 * ...         mock_client_class.return_value = MockClient()
 * ...         response = await admin_test_gateway(mock_request_post, mock_user)
 * ...         return isinstance(response, GatewayTestResponse) and response.status_code == 200
 * >>>
 * >>> asyncio.run(test_admin_test_gateway_post())
 * True
 * >>>
 * >>> # Test URL path handling with trailing slashes
 * >>> mock_request_trailing = GatewayTestRequest(
 * ...     base_url="https://api.example.com/",
 * ...     path="/test/",
 * ...     method="GET",
 * ...     headers={},
 * ...     body=None
 * ... )
 * >>>
 * >>> async def test_admin_test_gateway_trailing_slash():
 * ...     with patch('mcpgateway.admin.ResilientHttpClient') as mock_client_class:
 * ...         mock_client_class.return_value = MockClient()
 * ...         response = await admin_test_gateway(mock_request_trailing, mock_user)
 * ...         return isinstance(response, GatewayTestResponse) and response.status_code == 200
 * >>>
 * >>> asyncio.run(test_admin_test_gateway_trailing_slash())
 * True
 */
export const adminTestGatewayAdminGatewaysTestPost = <ThrowOnError extends boolean = false>(options: Options<AdminTestGatewayAdminGatewaysTestPostData, ThrowOnError>) => (options.client ?? client).post<AdminTestGatewayAdminGatewaysTestPostResponses, AdminTestGatewayAdminGatewaysTestPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/gateways/test',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Admin List Tags
 *
 * List all unique tags with statistics for the admin UI.
 *
 * Args:
 * entity_types: Comma-separated list of entity types to filter by
 * (e.g., "tools,resources,prompts,servers,gateways").
 * If not provided, returns tags from all entity types.
 * include_entities: Whether to include the list of entities that have each tag
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * List of tag information with statistics
 *
 * Raises:
 * HTTPException: If tag retrieval fails
 *
 * Examples:
 * >>> # Test function exists and has correct name
 * >>> from mcpgateway.admin import admin_list_tags
 * >>> admin_list_tags.__name__
 * 'admin_list_tags'
 * >>> # Test it's a coroutine function
 * >>> import inspect
 * >>> inspect.iscoroutinefunction(admin_list_tags)
 * True
 */
export const adminListTagsAdminTagsGet = <ThrowOnError extends boolean = false>(options?: Options<AdminListTagsAdminTagsGetData, ThrowOnError>) => (options?.client ?? client).get<AdminListTagsAdminTagsGetResponses, AdminListTagsAdminTagsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/tags',
    ...options
});

/**
 * Admin Import Tools
 *
 * Bulk import multiple tools in a single request.
 *
 * Accepts a JSON array of tool definitions and registers them individually.
 * Provides per-item validation and error reporting without failing the entire batch.
 *
 * Args:
 * request: FastAPI Request containing the tools data
 * db: Database session
 * user: Authenticated username
 *
 * Returns:
 * JSONResponse with success status, counts, and details of created/failed tools
 *
 * Raises:
 * HTTPException: For authentication or rate limiting failures
 */
export const adminImportToolsAdminToolsImportPost = <ThrowOnError extends boolean = false>(options?: Options<AdminImportToolsAdminToolsImportPostData, ThrowOnError>) => (options?.client ?? client).post<AdminImportToolsAdminToolsImportPostResponses, AdminImportToolsAdminToolsImportPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/tools/import',
    ...options
});

/**
 * Admin Import Tools
 *
 * Bulk import multiple tools in a single request.
 *
 * Accepts a JSON array of tool definitions and registers them individually.
 * Provides per-item validation and error reporting without failing the entire batch.
 *
 * Args:
 * request: FastAPI Request containing the tools data
 * db: Database session
 * user: Authenticated username
 *
 * Returns:
 * JSONResponse with success status, counts, and details of created/failed tools
 *
 * Raises:
 * HTTPException: For authentication or rate limiting failures
 */
export const adminImportToolsAdminToolsImportPost2 = <ThrowOnError extends boolean = false>(options?: Options<AdminImportToolsAdminToolsImportPost2Data, ThrowOnError>) => (options?.client ?? client).post<AdminImportToolsAdminToolsImportPost2Responses, AdminImportToolsAdminToolsImportPost2Errors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/tools/import/',
    ...options
});

/**
 * Admin Get Logs
 *
 * Get filtered log entries from the in-memory buffer.
 *
 * Args:
 * entity_type: Filter by entity type (tool, resource, server, gateway)
 * entity_id: Filter by entity ID
 * level: Minimum log level (debug, info, warning, error, critical)
 * start_time: ISO format start time
 * end_time: ISO format end time
 * request_id: Filter by request ID
 * search: Search in message text
 * limit: Maximum number of results (default 100, max 1000)
 * offset: Number of results to skip
 * order: Sort order (asc or desc)
 * user: Authenticated user
 *
 * Returns:
 * Dictionary with logs and metadata
 *
 * Raises:
 * HTTPException: If validation fails or service unavailable
 */
export const adminGetLogsAdminLogsGet = <ThrowOnError extends boolean = false>(options?: Options<AdminGetLogsAdminLogsGetData, ThrowOnError>) => (options?.client ?? client).get<AdminGetLogsAdminLogsGetResponses, AdminGetLogsAdminLogsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/logs',
    ...options
});

/**
 * Admin Stream Logs
 *
 * Stream real-time log updates via Server-Sent Events.
 *
 * Args:
 * request: FastAPI request object
 * entity_type: Filter by entity type
 * entity_id: Filter by entity ID
 * level: Minimum log level
 * user: Authenticated user
 *
 * Returns:
 * SSE response with real-time log updates
 *
 * Raises:
 * HTTPException: If log level is invalid or service unavailable
 */
export const adminStreamLogsAdminLogsStreamGet = <ThrowOnError extends boolean = false>(options?: Options<AdminStreamLogsAdminLogsStreamGetData, ThrowOnError>) => (options?.client ?? client).get<AdminStreamLogsAdminLogsStreamGetResponses, AdminStreamLogsAdminLogsStreamGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/logs/stream',
    ...options
});

/**
 * Admin Get Log File
 *
 * Download log file.
 *
 * Args:
 * filename: Specific log file to download (optional)
 * user: Authenticated user
 *
 * Returns:
 * File download response or list of available files
 *
 * Raises:
 * HTTPException: If file doesn't exist or access denied
 */
export const adminGetLogFileAdminLogsFileGet = <ThrowOnError extends boolean = false>(options?: Options<AdminGetLogFileAdminLogsFileGetData, ThrowOnError>) => (options?.client ?? client).get<AdminGetLogFileAdminLogsFileGetResponses, AdminGetLogFileAdminLogsFileGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/logs/file',
    ...options
});

/**
 * Admin Export Logs
 *
 * Export filtered logs in JSON or CSV format.
 *
 * Args:
 * export_format: Export format (json or csv)
 * entity_type: Filter by entity type
 * entity_id: Filter by entity ID
 * level: Minimum log level
 * start_time: ISO format start time
 * end_time: ISO format end time
 * request_id: Filter by request ID
 * search: Search in message text
 * user: Authenticated user
 *
 * Returns:
 * File download response with exported logs
 *
 * Raises:
 * HTTPException: If validation fails or export format invalid
 */
export const adminExportLogsAdminLogsExportGet = <ThrowOnError extends boolean = false>(options?: Options<AdminExportLogsAdminLogsExportGetData, ThrowOnError>) => (options?.client ?? client).get<AdminExportLogsAdminLogsExportGetResponses, AdminExportLogsAdminLogsExportGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/logs/export',
    ...options
});

/**
 * Admin Export Configuration
 *
 * Export gateway configuration via Admin UI.
 *
 * Args:
 * request: FastAPI request object for extracting root path
 * types: Comma-separated entity types to include
 * exclude_types: Comma-separated entity types to exclude
 * tags: Comma-separated tags to filter by
 * include_inactive: Include inactive entities
 * include_dependencies: Include dependent entities
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * JSON file download with configuration export
 *
 * Raises:
 * HTTPException: If export fails
 */
export const adminExportConfigurationAdminExportConfigurationGet = <ThrowOnError extends boolean = false>(options?: Options<AdminExportConfigurationAdminExportConfigurationGetData, ThrowOnError>) => (options?.client ?? client).get<AdminExportConfigurationAdminExportConfigurationGetResponses, AdminExportConfigurationAdminExportConfigurationGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/export/configuration',
    ...options
});

/**
 * Admin Export Selective
 *
 * Export selected entities via Admin UI with entity selection.
 *
 * Args:
 * request: FastAPI request object
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * JSON file download with selective export data
 *
 * Raises:
 * HTTPException: If export fails
 *
 * Expects JSON body with entity selections:
 * {
 * "entity_selections": {
 * "tools": ["tool1", "tool2"],
 * "servers": ["server1"]
 * },
 * "include_dependencies": true
 * }
 */
export const adminExportSelectiveAdminExportSelectivePost = <ThrowOnError extends boolean = false>(options?: Options<AdminExportSelectiveAdminExportSelectivePostData, ThrowOnError>) => (options?.client ?? client).post<AdminExportSelectiveAdminExportSelectivePostResponses, AdminExportSelectiveAdminExportSelectivePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/export/selective',
    ...options
});

/**
 * Admin Import Preview
 *
 * Preview import file to show available items for selective import.
 *
 * Args:
 * request: FastAPI request object with import file data
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * JSON response with categorized import preview data
 *
 * Raises:
 * HTTPException: 400 for invalid JSON or missing data field, validation errors;
 * 500 for unexpected preview failures
 *
 * Expects JSON body:
 * {
 * "data": { ... }  // The import file content
 * }
 */
export const adminImportPreviewAdminImportPreviewPost = <ThrowOnError extends boolean = false>(options?: Options<AdminImportPreviewAdminImportPreviewPostData, ThrowOnError>) => (options?.client ?? client).post<AdminImportPreviewAdminImportPreviewPostResponses, AdminImportPreviewAdminImportPreviewPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/import/preview',
    ...options
});

/**
 * Admin Import Configuration
 *
 * Import configuration via Admin UI.
 *
 * Args:
 * request: FastAPI request object
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * JSON response with import status
 *
 * Raises:
 * HTTPException: If import fails
 *
 * Expects JSON body with import data and options:
 * {
 * "import_data": { ... },
 * "conflict_strategy": "update",
 * "dry_run": false,
 * "rekey_secret": "optional-new-secret",
 * "selected_entities": { ... }
 * }
 */
export const adminImportConfigurationAdminImportConfigurationPost = <ThrowOnError extends boolean = false>(options?: Options<AdminImportConfigurationAdminImportConfigurationPostData, ThrowOnError>) => (options?.client ?? client).post<AdminImportConfigurationAdminImportConfigurationPostResponses, AdminImportConfigurationAdminImportConfigurationPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/import/configuration',
    ...options
});

/**
 * Admin Get Import Status
 *
 * Get import status via Admin UI.
 *
 * Args:
 * import_id: Import operation ID
 * user: Authenticated user
 *
 * Returns:
 * JSON response with import status
 *
 * Raises:
 * HTTPException: If import not found
 */
export const adminGetImportStatusAdminImportStatusImportIdGet = <ThrowOnError extends boolean = false>(options: Options<AdminGetImportStatusAdminImportStatusImportIdGetData, ThrowOnError>) => (options.client ?? client).get<AdminGetImportStatusAdminImportStatusImportIdGetResponses, AdminGetImportStatusAdminImportStatusImportIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/import/status/{import_id}',
    ...options
});

/**
 * Admin List Import Statuses
 *
 * List all import statuses via Admin UI.
 *
 * Args:
 * user: Authenticated user
 *
 * Returns:
 * JSON response with list of import statuses
 */
export const adminListImportStatusesAdminImportStatusGet = <ThrowOnError extends boolean = false>(options?: Options<AdminListImportStatusesAdminImportStatusGetData, ThrowOnError>) => (options?.client ?? client).get<AdminListImportStatusesAdminImportStatusGetResponses, AdminListImportStatusesAdminImportStatusGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/import/status',
    ...options
});

/**
 * Admin Get Agent
 *
 * Get A2A agent details for the admin UI.
 *
 * Args:
 * agent_id: Agent ID.
 * db: Database session.
 * user: Authenticated user.
 *
 * Returns:
 * Agent details.
 *
 * Raises:
 * HTTPException: If the agent is not found.
 * Exception: For any other unexpected errors.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock
 * >>> from mcpgateway.schemas import A2AAgentRead
 * >>> from datetime import datetime, timezone
 * >>> from mcpgateway.services.a2a_service import A2AAgentError, A2AAgentNameConflictError, A2AAgentNotFoundError, A2AAgentService
 * >>> from mcpgateway.services.a2a_service import A2AAgentNotFoundError
 * >>> from fastapi import HTTPException
 * >>>
 * >>> a2a_service: Optional[A2AAgentService] = A2AAgentService() if settings.mcpgateway_a2a_enabled else None
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>> agent_id = "test-agent-id"
 * >>>
 * >>> mock_agent = A2AAgentRead(
 * ...     id=agent_id, name="Agent1", slug="agent1",
 * ...     description="Test A2A agent", endpoint_url="http://agent.local",
 * ...     agent_type="connector", protocol_version="1.0",
 * ...     capabilities={"ping": True}, config={"x": "y"},
 * ...     auth_type=None, enabled=True, reachable=True,
 * ...     created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc),
 * ...     last_interaction=None, metrics = {
 * ...                                           "requests": 0,
 * ...                                           "totalExecutions": 0,
 * ...                                           "successfulExecutions": 0,
 * ...                                           "failedExecutions": 0,
 * ...                                           "failureRate": 0.0,
 * ...                                             }
 * ... )
 * >>>
 * >>> from mcpgateway import admin
 * >>> original_get_agent = admin.a2a_service.get_agent
 * >>> a2a_service.get_agent = AsyncMock(return_value=mock_agent)
 * >>> admin.a2a_service.get_agent = AsyncMock(return_value=mock_agent)
 * >>> async def test_admin_get_agent_success():
 * ...     result = await admin.admin_get_agent(agent_id, mock_db, mock_user)
 * ...     return isinstance(result, dict) and result['id'] == agent_id
 * >>>
 * >>> asyncio.run(test_admin_get_agent_success())
 * True
 * >>>
 * >>> # Test not found
 * >>> admin.a2a_service.get_agent = AsyncMock(side_effect=A2AAgentNotFoundError("Agent not found"))
 * >>> async def test_admin_get_agent_not_found():
 * ...     try:
 * ...         await admin.admin_get_agent("bad-id", mock_db, mock_user)
 * ...         return False
 * ...     except HTTPException as e:
 * ...         return e.status_code == 404 and "Agent not found" in e.detail
 * >>>
 * >>> asyncio.run(test_admin_get_agent_not_found())
 * True
 * >>>
 * >>> # Test generic exception
 * >>> admin.a2a_service.get_agent = AsyncMock(side_effect=Exception("Generic error"))
 * >>> async def test_admin_get_agent_exception():
 * ...     try:
 * ...         await admin.admin_get_agent(agent_id, mock_db, mock_user)
 * ...         return False
 * ...     except Exception as e:
 * ...         return str(e) == "Generic error"
 * >>>
 * >>> asyncio.run(test_admin_get_agent_exception())
 * True
 * >>>
 * >>> admin.a2a_service.get_agent = original_get_agent
 */
export const adminGetAgentAdminA2aAgentIdGet = <ThrowOnError extends boolean = false>(options: Options<AdminGetAgentAdminA2aAgentIdGetData, ThrowOnError>) => (options.client ?? client).get<AdminGetAgentAdminA2aAgentIdGetResponses, AdminGetAgentAdminA2aAgentIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/a2a/{agent_id}',
    ...options
});

/**
 * Admin List A2A Agents
 *
 * List A2A Agents for the admin UI with an option to include inactive agents.
 *
 * This endpoint retrieves a list of A2A (Agent-to-Agent) agents associated with
 * the current user. Administrators can optionally include inactive agents for
 * management or auditing purposes.
 *
 * Args:
 * include_inactive (bool): Whether to include inactive agents in the results.
 * db (Session): Database session dependency.
 * user (dict): Authenticated user dependency.
 *
 * Returns:
 * List[A2AAgentRead]: A list of A2A agent records formatted with by_alias=True.
 *
 * Raises:
 * HTTPException (500): If an error occurs while retrieving the agent list.
 *
 * Examples:
 * >>> import asyncio
 * >>> from unittest.mock import AsyncMock, MagicMock, patch
 * >>> from mcpgateway.schemas import A2AAgentRead, A2AAgentMetrics
 * >>> from datetime import datetime, timezone
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_user", "db": mock_db}
 * >>>
 * >>> mock_agent = A2AAgentRead(
 * ...     id="1",
 * ...     name="Agent1",
 * ...     slug="agent1",
 * ...     description="A2A Test Agent",
 * ...     endpoint_url="http://localhost/agent1",
 * ...     agent_type="test",
 * ...     protocol_version="1.0",
 * ...     capabilities={},
 * ...     config={},
 * ...     auth_type=None,
 * ...     enabled=True,
 * ...     reachable=True,
 * ...     created_at=datetime.now(timezone.utc),
 * ...     updated_at=datetime.now(timezone.utc),
 * ...     last_interaction=None,
 * ...     tags=[],
 * ...     metrics=A2AAgentMetrics(
 * ...         total_executions=1,
 * ...         successful_executions=1,
 * ...         failed_executions=0,
 * ...         failure_rate=0.0,
 * ...         min_response_time=0.1,
 * ...         max_response_time=0.2,
 * ...         avg_response_time=0.15,
 * ...         last_execution_time=datetime.now(timezone.utc)
 * ...     )
 * ... )
 * >>>
 * >>> async def test_admin_list_a2a_agents_active():
 * ...     fake_service = MagicMock()
 * ...     fake_service.list_agents_for_user = AsyncMock(return_value=[mock_agent])
 * ...     with patch("mcpgateway.admin.a2a_service", new=fake_service):
 * ...         result = await admin_list_a2a_agents(include_inactive=False, db=mock_db, user=mock_user)
 * ...         return len(result) > 0 and isinstance(result[0], dict) and result[0]['name'] == "Agent1"
 * >>>
 * >>> asyncio.run(test_admin_list_a2a_agents_active())
 * True
 * >>>
 * >>> async def test_admin_list_a2a_agents_exception():
 * ...     fake_service = MagicMock()
 * ...     fake_service.list_agents_for_user = AsyncMock(side_effect=Exception("A2A error"))
 * ...     with patch("mcpgateway.admin.a2a_service", new=fake_service):
 * ...         try:
 * ...             await admin_list_a2a_agents(False, db=mock_db, user=mock_user)
 * ...             return False
 * ...         except Exception as e:
 * ...             return "A2A error" in str(e)
 * >>>
 * >>> asyncio.run(test_admin_list_a2a_agents_exception())
 * True
 */
export const adminListA2aAgentsAdminA2aGet = <ThrowOnError extends boolean = false>(options?: Options<AdminListA2aAgentsAdminA2aGetData, ThrowOnError>) => (options?.client ?? client).get<AdminListA2aAgentsAdminA2aGetResponses, AdminListA2aAgentsAdminA2aGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/a2a',
    ...options
});

/**
 * Admin Add A2A Agent
 *
 * Add a new A2A agent via admin UI.
 *
 * Args:
 * request: FastAPI request object
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * JSONResponse with success/error status
 *
 * Raises:
 * HTTPException: If A2A features are disabled
 */
export const adminAddA2aAgentAdminA2aPost = <ThrowOnError extends boolean = false>(options?: Options<AdminAddA2aAgentAdminA2aPostData, ThrowOnError>) => (options?.client ?? client).post<AdminAddA2aAgentAdminA2aPostResponses, AdminAddA2aAgentAdminA2aPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/a2a',
    ...options
});

/**
 * Admin Edit A2A Agent
 *
 * Edit an existing A2A agent via the admin UI.
 *
 * Expects form fields:
 * - name
 * - description (optional)
 * - endpoint_url
 * - agent_type
 * - tags (optional, comma-separated)
 * - auth_type (optional)
 * - auth_username (optional)
 * - auth_password (optional)
 * - auth_token (optional)
 * - auth_header_key / auth_header_value (optional)
 * - auth_headers (JSON array, optional)
 * - oauth_config (JSON string or individual OAuth fields)
 * - visibility (optional)
 * - team_id (optional)
 * - capabilities (JSON, optional)
 * - config (JSON, optional)
 * - passthrough_headers: Optional[List[str]]
 *
 * Args:
 * agent_id (str): The ID of the agent being edited.
 * request (Request): The incoming FastAPI request containing form data.
 * db (Session): Active database session.
 * user: The authenticated admin user performing the edit.
 *
 * Returns:
 * JSONResponse: A JSON response indicating success or failure.
 *
 * Examples:
 * >>> import asyncio, json
 * >>> from unittest.mock import AsyncMock, MagicMock, patch
 * >>> from fastapi import Request
 * >>> from fastapi.responses import JSONResponse
 * >>> from starlette.datastructures import FormData
 * >>>
 * >>> mock_db = MagicMock()
 * >>> mock_user = {"email": "test_admin_user", "db": mock_db}
 * >>> agent_id = "agent-123"
 * >>>
 * >>> # Happy path: edit A2A agent successfully
 * >>> form_data_success = FormData([
 * ...     ("name", "Updated Agent"),
 * ...     ("endpoint_url", "http://updated-agent.com"),
 * ...     ("agent_type", "generic"),
 * ...     ("auth_type", "basic"),
 * ...     ("auth_username", "user"),
 * ...     ("auth_password", "pass"),
 * ... ])
 * >>> mock_request_success = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_success.form = AsyncMock(return_value=form_data_success)
 * >>> original_update_agent = a2a_service.update_agent
 * >>> a2a_service.update_agent = AsyncMock()
 * >>>
 * >>> async def test_admin_edit_a2a_agent_success():
 * ...     response = await admin_edit_a2a_agent(agent_id, mock_request_success, mock_db, mock_user)
 * ...     body = json.loads(response.body)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 200 and body["success"] is True
 * >>>
 * >>> asyncio.run(test_admin_edit_a2a_agent_success())
 * True
 * >>>
 * >>> # Error path: simulate exception during update
 * >>> form_data_error = FormData([
 * ...     ("name", "Error Agent"),
 * ...     ("endpoint_url", "http://error-agent.com"),
 * ...     ("auth_type", "basic"),
 * ...     ("auth_username", "user"),
 * ...     ("auth_password", "pass"),
 * ... ])
 * >>> mock_request_error = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_error.form = AsyncMock(return_value=form_data_error)
 * >>> a2a_service.update_agent = AsyncMock(side_effect=Exception("Update failed"))
 * >>>
 * >>> async def test_admin_edit_a2a_agent_exception():
 * ...     response = await admin_edit_a2a_agent(agent_id, mock_request_error, mock_db, mock_user)
 * ...     body = json.loads(response.body)
 * ...     return isinstance(response, JSONResponse) and response.status_code == 500 and body["success"] is False and "Update failed" in body["message"]
 * >>>
 * >>> asyncio.run(test_admin_edit_a2a_agent_exception())
 * True
 * >>>
 * >>> # Validation error path: e.g., invalid URL
 * >>> form_data_validation = FormData([
 * ...     ("name", "Bad URL Agent"),
 * ...     ("endpoint_url", "invalid-url"),
 * ...     ("auth_type", "basic"),
 * ...     ("auth_username", "user"),
 * ...     ("auth_password", "pass"),
 * ... ])
 * >>> mock_request_validation = MagicMock(spec=Request, scope={"root_path": ""})
 * >>> mock_request_validation.form = AsyncMock(return_value=form_data_validation)
 * >>>
 * >>> async def test_admin_edit_a2a_agent_validation():
 * ...     response = await admin_edit_a2a_agent(agent_id, mock_request_validation, mock_db, mock_user)
 * ...     body = json.loads(response.body)
 * ...     return isinstance(response, JSONResponse) and response.status_code in (422, 400) and body["success"] is False
 * >>>
 * >>> asyncio.run(test_admin_edit_a2a_agent_validation())
 * True
 * >>>
 * >>> # Restore original method
 * >>> a2a_service.update_agent = original_update_agent
 */
export const adminEditA2aAgentAdminA2aAgentIdEditPost = <ThrowOnError extends boolean = false>(options: Options<AdminEditA2aAgentAdminA2aAgentIdEditPostData, ThrowOnError>) => (options.client ?? client).post<AdminEditA2aAgentAdminA2aAgentIdEditPostResponses, AdminEditA2aAgentAdminA2aAgentIdEditPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/a2a/{agent_id}/edit',
    ...options
});

/**
 * Admin Toggle A2A Agent
 *
 * Toggle A2A agent status via admin UI.
 *
 * Args:
 * agent_id: Agent ID
 * request: FastAPI request object
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * Redirect response to admin page with A2A tab
 *
 * Raises:
 * HTTPException: If A2A features are disabled
 */
export const adminToggleA2aAgentAdminA2aAgentIdTogglePost = <ThrowOnError extends boolean = false>(options: Options<AdminToggleA2aAgentAdminA2aAgentIdTogglePostData, ThrowOnError>) => (options.client ?? client).post<AdminToggleA2aAgentAdminA2aAgentIdTogglePostResponses, AdminToggleA2aAgentAdminA2aAgentIdTogglePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/a2a/{agent_id}/toggle',
    ...options
});

/**
 * Admin Delete A2A Agent
 *
 * Delete A2A agent via admin UI.
 *
 * Args:
 * agent_id: Agent ID
 * request: FastAPI request object
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * Redirect response to admin page with A2A tab
 *
 * Raises:
 * HTTPException: If A2A features are disabled
 */
export const adminDeleteA2aAgentAdminA2aAgentIdDeletePost = <ThrowOnError extends boolean = false>(options: Options<AdminDeleteA2aAgentAdminA2aAgentIdDeletePostData, ThrowOnError>) => (options.client ?? client).post<AdminDeleteA2aAgentAdminA2aAgentIdDeletePostResponses, AdminDeleteA2aAgentAdminA2aAgentIdDeletePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/a2a/{agent_id}/delete',
    ...options
});

/**
 * Admin Test A2A Agent
 *
 * Test A2A agent via admin UI.
 *
 * Args:
 * agent_id: Agent ID
 * request: FastAPI request object
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * JSON response with test results
 *
 * Raises:
 * HTTPException: If A2A features are disabled
 */
export const adminTestA2aAgentAdminA2aAgentIdTestPost = <ThrowOnError extends boolean = false>(options: Options<AdminTestA2aAgentAdminA2aAgentIdTestPostData, ThrowOnError>) => (options.client ?? client).post<AdminTestA2aAgentAdminA2aAgentIdTestPostResponses, AdminTestA2aAgentAdminA2aAgentIdTestPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/a2a/{agent_id}/test',
    ...options
});

/**
 * Admin List Grpc Services
 *
 * List all gRPC services.
 *
 * Args:
 * include_inactive: Include disabled services
 * team_id: Filter by team ID
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * List of gRPC services
 *
 * Raises:
 * HTTPException: If gRPC support is disabled or not available
 */
export const adminListGrpcServicesAdminGrpcGet = <ThrowOnError extends boolean = false>(options?: Options<AdminListGrpcServicesAdminGrpcGetData, ThrowOnError>) => (options?.client ?? client).get<AdminListGrpcServicesAdminGrpcGetResponses, AdminListGrpcServicesAdminGrpcGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/grpc',
    ...options
});

/**
 * Admin Create Grpc Service
 *
 * Create a new gRPC service.
 *
 * Args:
 * service: gRPC service creation data
 * request: FastAPI request object
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * Created gRPC service
 *
 * Raises:
 * HTTPException: If gRPC support is disabled or creation fails
 */
export const adminCreateGrpcServiceAdminGrpcPost = <ThrowOnError extends boolean = false>(options: Options<AdminCreateGrpcServiceAdminGrpcPostData, ThrowOnError>) => (options.client ?? client).post<AdminCreateGrpcServiceAdminGrpcPostResponses, AdminCreateGrpcServiceAdminGrpcPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/grpc',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Admin Get Grpc Service
 *
 * Get a specific gRPC service.
 *
 * Args:
 * service_id: Service ID
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * The gRPC service
 *
 * Raises:
 * HTTPException: If gRPC support is disabled or service not found
 */
export const adminGetGrpcServiceAdminGrpcServiceIdGet = <ThrowOnError extends boolean = false>(options: Options<AdminGetGrpcServiceAdminGrpcServiceIdGetData, ThrowOnError>) => (options.client ?? client).get<AdminGetGrpcServiceAdminGrpcServiceIdGetResponses, AdminGetGrpcServiceAdminGrpcServiceIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/grpc/{service_id}',
    ...options
});

/**
 * Admin Update Grpc Service
 *
 * Update a gRPC service.
 *
 * Args:
 * service_id: Service ID
 * service: Update data
 * request: FastAPI request object
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * Updated gRPC service
 *
 * Raises:
 * HTTPException: If gRPC support is disabled or update fails
 */
export const adminUpdateGrpcServiceAdminGrpcServiceIdPut = <ThrowOnError extends boolean = false>(options: Options<AdminUpdateGrpcServiceAdminGrpcServiceIdPutData, ThrowOnError>) => (options.client ?? client).put<AdminUpdateGrpcServiceAdminGrpcServiceIdPutResponses, AdminUpdateGrpcServiceAdminGrpcServiceIdPutErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/grpc/{service_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Admin Toggle Grpc Service
 *
 * Toggle a gRPC service's enabled status.
 *
 * Args:
 * service_id: Service ID
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * Updated gRPC service
 *
 * Raises:
 * HTTPException: If gRPC support is disabled or toggle fails
 */
export const adminToggleGrpcServiceAdminGrpcServiceIdTogglePost = <ThrowOnError extends boolean = false>(options: Options<AdminToggleGrpcServiceAdminGrpcServiceIdTogglePostData, ThrowOnError>) => (options.client ?? client).post<AdminToggleGrpcServiceAdminGrpcServiceIdTogglePostResponses, AdminToggleGrpcServiceAdminGrpcServiceIdTogglePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/grpc/{service_id}/toggle',
    ...options
});

/**
 * Admin Delete Grpc Service
 *
 * Delete a gRPC service.
 *
 * Args:
 * service_id: Service ID
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * No content response
 *
 * Raises:
 * HTTPException: If gRPC support is disabled or deletion fails
 */
export const adminDeleteGrpcServiceAdminGrpcServiceIdDeletePost = <ThrowOnError extends boolean = false>(options: Options<AdminDeleteGrpcServiceAdminGrpcServiceIdDeletePostData, ThrowOnError>) => (options.client ?? client).post<AdminDeleteGrpcServiceAdminGrpcServiceIdDeletePostResponses, AdminDeleteGrpcServiceAdminGrpcServiceIdDeletePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/grpc/{service_id}/delete',
    ...options
});

/**
 * Admin Reflect Grpc Service
 *
 * Trigger re-reflection on a gRPC service.
 *
 * Args:
 * service_id: Service ID
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * Updated gRPC service with reflection results
 *
 * Raises:
 * HTTPException: If gRPC support is disabled or reflection fails
 */
export const adminReflectGrpcServiceAdminGrpcServiceIdReflectPost = <ThrowOnError extends boolean = false>(options: Options<AdminReflectGrpcServiceAdminGrpcServiceIdReflectPostData, ThrowOnError>) => (options.client ?? client).post<AdminReflectGrpcServiceAdminGrpcServiceIdReflectPostResponses, AdminReflectGrpcServiceAdminGrpcServiceIdReflectPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/grpc/{service_id}/reflect',
    ...options
});

/**
 * Admin Get Grpc Methods
 *
 * Get methods for a gRPC service.
 *
 * Args:
 * service_id: Service ID
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * List of gRPC methods
 *
 * Raises:
 * HTTPException: If gRPC support is disabled or service not found
 */
export const adminGetGrpcMethodsAdminGrpcServiceIdMethodsGet = <ThrowOnError extends boolean = false>(options: Options<AdminGetGrpcMethodsAdminGrpcServiceIdMethodsGetData, ThrowOnError>) => (options.client ?? client).get<AdminGetGrpcMethodsAdminGrpcServiceIdMethodsGetResponses, AdminGetGrpcMethodsAdminGrpcServiceIdMethodsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/grpc/{service_id}/methods',
    ...options
});

/**
 * Get Tools Section
 *
 * Get tools data filtered by team.
 *
 * Args:
 * team_id: Optional team ID to filter by
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * JSONResponse: Tools data with team filtering applied
 */
export const getToolsSectionAdminSectionsToolsGet = <ThrowOnError extends boolean = false>(options?: Options<GetToolsSectionAdminSectionsToolsGetData, ThrowOnError>) => (options?.client ?? client).get<GetToolsSectionAdminSectionsToolsGetResponses, GetToolsSectionAdminSectionsToolsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/sections/tools',
    ...options
});

/**
 * Get Resources Section
 *
 * Get resources data filtered by team.
 *
 * Args:
 * team_id: Optional team ID to filter by
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * JSONResponse: Resources data with team filtering applied
 */
export const getResourcesSectionAdminSectionsResourcesGet = <ThrowOnError extends boolean = false>(options?: Options<GetResourcesSectionAdminSectionsResourcesGetData, ThrowOnError>) => (options?.client ?? client).get<GetResourcesSectionAdminSectionsResourcesGetResponses, GetResourcesSectionAdminSectionsResourcesGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/sections/resources',
    ...options
});

/**
 * Get Prompts Section
 *
 * Get prompts data filtered by team.
 *
 * Args:
 * team_id: Optional team ID to filter by
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * JSONResponse: Prompts data with team filtering applied
 */
export const getPromptsSectionAdminSectionsPromptsGet = <ThrowOnError extends boolean = false>(options?: Options<GetPromptsSectionAdminSectionsPromptsGetData, ThrowOnError>) => (options?.client ?? client).get<GetPromptsSectionAdminSectionsPromptsGetResponses, GetPromptsSectionAdminSectionsPromptsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/sections/prompts',
    ...options
});

/**
 * Get Servers Section
 *
 * Get servers data filtered by team.
 *
 * Args:
 * team_id: Optional team ID to filter by
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * JSONResponse: Servers data with team filtering applied
 */
export const getServersSectionAdminSectionsServersGet = <ThrowOnError extends boolean = false>(options?: Options<GetServersSectionAdminSectionsServersGetData, ThrowOnError>) => (options?.client ?? client).get<GetServersSectionAdminSectionsServersGetResponses, GetServersSectionAdminSectionsServersGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/sections/servers',
    ...options
});

/**
 * Get Gateways Section
 *
 * Get gateways data filtered by team.
 *
 * Args:
 * team_id: Optional team ID to filter by
 * db: Database session
 * user: Current authenticated user context
 *
 * Returns:
 * JSONResponse: Gateways data with team filtering applied
 */
export const getGatewaysSectionAdminSectionsGatewaysGet = <ThrowOnError extends boolean = false>(options?: Options<GetGatewaysSectionAdminSectionsGatewaysGetData, ThrowOnError>) => (options?.client ?? client).get<GetGatewaysSectionAdminSectionsGatewaysGetResponses, GetGatewaysSectionAdminSectionsGatewaysGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/sections/gateways',
    ...options
});

/**
 * Get Plugins Partial
 *
 * Render the plugins partial HTML template.
 *
 * This endpoint returns a rendered HTML partial containing plugin information,
 * similar to the version_info_partial pattern. It's designed to be loaded via HTMX
 * into the admin interface.
 *
 * Args:
 * request: FastAPI request object
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * HTMLResponse with rendered plugins partial template
 */
export const getPluginsPartialAdminPluginsPartialGet = <ThrowOnError extends boolean = false>(options?: Options<GetPluginsPartialAdminPluginsPartialGetData, ThrowOnError>) => (options?.client ?? client).get<GetPluginsPartialAdminPluginsPartialGetResponses, GetPluginsPartialAdminPluginsPartialGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/plugins/partial',
    ...options
});

/**
 * List Plugins
 *
 * Get list of all plugins with optional filtering.
 *
 * Args:
 * request: FastAPI request object
 * search: Optional text search in name/description/author
 * mode: Optional filter by mode (enforce/permissive/disabled)
 * hook: Optional filter by hook type
 * tag: Optional filter by tag
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * PluginListResponse with list of plugins and statistics
 *
 * Raises:
 * HTTPException: If there's an error retrieving plugins
 */
export const listPluginsAdminPluginsGet = <ThrowOnError extends boolean = false>(options?: Options<ListPluginsAdminPluginsGetData, ThrowOnError>) => (options?.client ?? client).get<ListPluginsAdminPluginsGetResponses, ListPluginsAdminPluginsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/plugins',
    ...options
});

/**
 * Get Plugin Stats
 *
 * Get plugin statistics.
 *
 * Args:
 * request: FastAPI request object
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * PluginStatsResponse with aggregated plugin statistics
 *
 * Raises:
 * HTTPException: If there's an error getting plugin statistics
 */
export const getPluginStatsAdminPluginsStatsGet = <ThrowOnError extends boolean = false>(options?: Options<GetPluginStatsAdminPluginsStatsGetData, ThrowOnError>) => (options?.client ?? client).get<GetPluginStatsAdminPluginsStatsGetResponses, GetPluginStatsAdminPluginsStatsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/plugins/stats',
    ...options
});

/**
 * Get Plugin Details
 *
 * Get detailed information about a specific plugin.
 *
 * Args:
 * name: Plugin name
 * request: FastAPI request object
 * db: Database session
 * user: Authenticated user
 *
 * Returns:
 * PluginDetail with full plugin information
 *
 * Raises:
 * HTTPException: If plugin not found
 */
export const getPluginDetailsAdminPluginsNameGet = <ThrowOnError extends boolean = false>(options: Options<GetPluginDetailsAdminPluginsNameGetData, ThrowOnError>) => (options.client ?? client).get<GetPluginDetailsAdminPluginsNameGetResponses, GetPluginDetailsAdminPluginsNameGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/plugins/{name}',
    ...options
});

/**
 * List Catalog Servers
 *
 * Get list of catalog servers with filtering.
 *
 * Args:
 * _request: FastAPI request object
 * category: Filter by category
 * auth_type: Filter by authentication type
 * provider: Filter by provider
 * search: Search in name/description
 * tags: Filter by tags
 * show_registered_only: Show only already registered servers
 * show_available_only: Show only available servers
 * limit: Maximum results
 * offset: Pagination offset
 * db: Database session
 * _user: Authenticated user
 *
 * Returns:
 * List of catalog servers matching filters
 *
 * Raises:
 * HTTPException: If the catalog feature is disabled.
 */
export const listCatalogServersAdminMcpRegistryServersGet = <ThrowOnError extends boolean = false>(options?: Options<ListCatalogServersAdminMcpRegistryServersGetData, ThrowOnError>) => (options?.client ?? client).get<ListCatalogServersAdminMcpRegistryServersGetResponses, ListCatalogServersAdminMcpRegistryServersGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/mcp-registry/servers',
    ...options
});

/**
 * Register Catalog Server
 *
 * Register a catalog server.
 *
 * Args:
 * server_id: Catalog server ID to register
 * request: Optional registration parameters
 * db: Database session
 * _user: Authenticated user
 *
 * Returns:
 * Registration response with success status
 *
 * Raises:
 * HTTPException: If the catalog feature is disabled.
 */
export const registerCatalogServerAdminMcpRegistryServerIdRegisterPost = <ThrowOnError extends boolean = false>(options: Options<RegisterCatalogServerAdminMcpRegistryServerIdRegisterPostData, ThrowOnError>) => (options.client ?? client).post<RegisterCatalogServerAdminMcpRegistryServerIdRegisterPostResponses, RegisterCatalogServerAdminMcpRegistryServerIdRegisterPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/mcp-registry/{server_id}/register',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Check Catalog Server Status
 *
 * Check catalog server availability.
 *
 * Args:
 * server_id: Catalog server ID to check
 * _db: Database session
 * _user: Authenticated user
 *
 * Returns:
 * Server status including availability and response time
 *
 * Raises:
 * HTTPException: If the catalog feature is disabled.
 */
export const checkCatalogServerStatusAdminMcpRegistryServerIdStatusGet = <ThrowOnError extends boolean = false>(options: Options<CheckCatalogServerStatusAdminMcpRegistryServerIdStatusGetData, ThrowOnError>) => (options.client ?? client).get<CheckCatalogServerStatusAdminMcpRegistryServerIdStatusGetResponses, CheckCatalogServerStatusAdminMcpRegistryServerIdStatusGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/mcp-registry/{server_id}/status',
    ...options
});

/**
 * Bulk Register Catalog Servers
 *
 * Register multiple catalog servers at once.
 *
 * Args:
 * request: Bulk registration request with server IDs
 * db: Database session
 * _user: Authenticated user
 *
 * Returns:
 * Bulk registration response with success/failure details
 *
 * Raises:
 * HTTPException: If the catalog feature is disabled.
 */
export const bulkRegisterCatalogServersAdminMcpRegistryBulkRegisterPost = <ThrowOnError extends boolean = false>(options: Options<BulkRegisterCatalogServersAdminMcpRegistryBulkRegisterPostData, ThrowOnError>) => (options.client ?? client).post<BulkRegisterCatalogServersAdminMcpRegistryBulkRegisterPostResponses, BulkRegisterCatalogServersAdminMcpRegistryBulkRegisterPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/mcp-registry/bulk-register',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Catalog Partial
 *
 * Get HTML partial for catalog servers (used by HTMX).
 *
 * Args:
 * request: FastAPI request object
 * category: Filter by category
 * auth_type: Filter by authentication type
 * search: Search term
 * page: Page number (1-indexed)
 * db: Database session
 * _user: Authenticated user
 *
 * Returns:
 * HTML partial with filtered catalog servers
 *
 * Raises:
 * HTTPException: If the catalog feature is disabled.
 */
export const catalogPartialAdminMcpRegistryPartialGet = <ThrowOnError extends boolean = false>(options?: Options<CatalogPartialAdminMcpRegistryPartialGetData, ThrowOnError>) => (options?.client ?? client).get<CatalogPartialAdminMcpRegistryPartialGetResponses, CatalogPartialAdminMcpRegistryPartialGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/mcp-registry/partial',
    ...options
});

/**
 * Get System Stats
 *
 * Get comprehensive system metrics for administrators.
 *
 * Returns detailed counts across all entity types including users, teams,
 * MCP resources (servers, tools, resources, prompts, A2A agents, gateways),
 * API tokens, sessions, metrics, security events, and workflow state.
 *
 * Designed for capacity planning, performance optimization, and demonstrating
 * system capabilities to administrators.
 *
 * Args:
 * request: FastAPI request object
 * db: Database session dependency
 * user: Authenticated user from dependency (must have admin access)
 *
 * Returns:
 * HTMLResponse or JSONResponse: Comprehensive system metrics
 * Returns HTML partial when requested via HTMX, JSON otherwise
 *
 * Raises:
 * HTTPException: If metrics collection fails
 *
 * Examples:
 * >>> # Request system metrics via API
 * >>> # GET /admin/system/stats
 * >>> # Returns JSON with users, teams, mcp_resources, tokens, sessions, metrics, security, workflow
 */
export const getSystemStatsAdminSystemStatsGet = <ThrowOnError extends boolean = false>(options?: Options<GetSystemStatsAdminSystemStatsGetData, ThrowOnError>) => (options?.client ?? client).get<GetSystemStatsAdminSystemStatsGetResponses, GetSystemStatsAdminSystemStatsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/system/stats',
    ...options
});

/**
 * Admin Generate Support Bundle
 *
 * Generate and download a support bundle with sanitized diagnostics.
 *
 * Creates a ZIP file containing version info, system diagnostics, configuration,
 * and logs with automatic sanitization of sensitive data (passwords, tokens, secrets).
 *
 * Args:
 * log_lines: Number of log lines to include (default: 1000, 0 = all)
 * include_logs: Include log files in bundle (default: True)
 * include_env: Include environment configuration (default: True)
 * include_system: Include system diagnostics (default: True)
 * user: Authenticated user from dependency
 *
 * Returns:
 * Response: ZIP file download with support bundle
 *
 * Raises:
 * HTTPException: If bundle generation fails
 *
 * Examples:
 * >>> # Request support bundle via API
 * >>> # GET /admin/support-bundle/generate?log_lines=500
 * >>> # Returns: mcpgateway-support-YYYY-MM-DD-HHMMSS.zip
 */
export const adminGenerateSupportBundleAdminSupportBundleGenerateGet = <ThrowOnError extends boolean = false>(options?: Options<AdminGenerateSupportBundleAdminSupportBundleGenerateGetData, ThrowOnError>) => (options?.client ?? client).get<AdminGenerateSupportBundleAdminSupportBundleGenerateGetResponses, AdminGenerateSupportBundleAdminSupportBundleGenerateGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/support-bundle/generate',
    ...options
});

/**
 * Get Observability Partial
 *
 * Render the observability dashboard partial.
 *
 * Args:
 * request: FastAPI request object
 * _user: Authenticated user with admin permissions (required by dependency)
 *
 * Returns:
 * HTMLResponse: Rendered observability dashboard template
 */
export const getObservabilityPartialAdminObservabilityPartialGet = <ThrowOnError extends boolean = false>(options?: Options<GetObservabilityPartialAdminObservabilityPartialGetData, ThrowOnError>) => (options?.client ?? client).get<GetObservabilityPartialAdminObservabilityPartialGetResponses, GetObservabilityPartialAdminObservabilityPartialGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/partial',
    ...options
});

/**
 * Get Observability Metrics Partial
 *
 * Render the advanced metrics dashboard partial.
 *
 * Args:
 * request: FastAPI request object
 * _user: Authenticated user with admin permissions (required by dependency)
 *
 * Returns:
 * HTMLResponse: Rendered metrics dashboard template
 */
export const getObservabilityMetricsPartialAdminObservabilityMetricsPartialGet = <ThrowOnError extends boolean = false>(options?: Options<GetObservabilityMetricsPartialAdminObservabilityMetricsPartialGetData, ThrowOnError>) => (options?.client ?? client).get<GetObservabilityMetricsPartialAdminObservabilityMetricsPartialGetResponses, GetObservabilityMetricsPartialAdminObservabilityMetricsPartialGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/metrics/partial',
    ...options
});

/**
 * Get Observability Stats
 *
 * Get observability statistics for the dashboard.
 *
 * Args:
 * request: FastAPI request object
 * hours: Number of hours to look back for statistics (1-168)
 * _user: Authenticated user with admin permissions (required by dependency)
 *
 * Returns:
 * HTMLResponse: Rendered statistics template with trace counts and averages
 */
export const getObservabilityStatsAdminObservabilityStatsGet = <ThrowOnError extends boolean = false>(options?: Options<GetObservabilityStatsAdminObservabilityStatsGetData, ThrowOnError>) => (options?.client ?? client).get<GetObservabilityStatsAdminObservabilityStatsGetResponses, GetObservabilityStatsAdminObservabilityStatsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/stats',
    ...options
});

/**
 * Get Observability Traces
 *
 * Get list of traces for the dashboard.
 *
 * Args:
 * request: FastAPI request object
 * time_range: Time range filter (1h, 6h, 24h, 7d)
 * status_filter: Status filter (all, ok, error)
 * limit: Maximum number of traces to return
 * min_duration: Minimum duration in ms
 * max_duration: Maximum duration in ms
 * http_method: HTTP method filter
 * user_email: User email filter
 * name_search: Trace name search
 * attribute_search: Full-text attribute search
 * tool_name: Filter by tool name (shows traces that invoked this tool)
 * _user: Authenticated user with admin permissions (required by dependency)
 *
 * Returns:
 * HTMLResponse: Rendered traces list template
 */
export const getObservabilityTracesAdminObservabilityTracesGet = <ThrowOnError extends boolean = false>(options?: Options<GetObservabilityTracesAdminObservabilityTracesGetData, ThrowOnError>) => (options?.client ?? client).get<GetObservabilityTracesAdminObservabilityTracesGetResponses, GetObservabilityTracesAdminObservabilityTracesGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/traces',
    ...options
});

/**
 * Get Observability Trace Detail
 *
 * Get detailed trace information with spans.
 *
 * Args:
 * request: FastAPI request object
 * trace_id: UUID of the trace to retrieve
 * _user: Authenticated user with admin permissions (required by dependency)
 *
 * Returns:
 * HTMLResponse: Rendered trace detail template with waterfall view
 *
 * Raises:
 * HTTPException: 404 if trace not found
 */
export const getObservabilityTraceDetailAdminObservabilityTraceTraceIdGet = <ThrowOnError extends boolean = false>(options: Options<GetObservabilityTraceDetailAdminObservabilityTraceTraceIdGetData, ThrowOnError>) => (options.client ?? client).get<GetObservabilityTraceDetailAdminObservabilityTraceTraceIdGetResponses, GetObservabilityTraceDetailAdminObservabilityTraceTraceIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/trace/{trace_id}',
    ...options
});

/**
 * List Observability Queries
 *
 * List saved observability queries for the current user.
 *
 * Returns user's own queries plus any shared queries.
 *
 * Args:
 * request: FastAPI request object
 * user: Authenticated user (required by dependency)
 *
 * Returns:
 * list: List of saved query dictionaries
 */
export const listObservabilityQueriesAdminObservabilityQueriesGet = <ThrowOnError extends boolean = false>(options?: Options<ListObservabilityQueriesAdminObservabilityQueriesGetData, ThrowOnError>) => (options?.client ?? client).get<ListObservabilityQueriesAdminObservabilityQueriesGetResponses, ListObservabilityQueriesAdminObservabilityQueriesGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/queries',
    ...options
});

/**
 * Save Observability Query
 *
 * Save a new observability query filter configuration.
 *
 * Args:
 * request: FastAPI request object
 * name: User-given name for the query
 * description: Optional description
 * filter_config: Dictionary containing all filter values
 * is_shared: Whether this query is visible to other users
 * user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Created query details with id
 *
 * Raises:
 * HTTPException: 400 if validation fails
 */
export const saveObservabilityQueryAdminObservabilityQueriesPost = <ThrowOnError extends boolean = false>(options: Options<SaveObservabilityQueryAdminObservabilityQueriesPostData, ThrowOnError>) => (options.client ?? client).post<SaveObservabilityQueryAdminObservabilityQueriesPostResponses, SaveObservabilityQueryAdminObservabilityQueriesPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/queries',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete Observability Query
 *
 * Delete a saved query.
 *
 * Args:
 * request: FastAPI request object
 * query_id: ID of the query to delete
 * user: Authenticated user (required by dependency)
 *
 * Raises:
 * HTTPException: 404 if query not found, 403 if unauthorized
 */
export const deleteObservabilityQueryAdminObservabilityQueriesQueryIdDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteObservabilityQueryAdminObservabilityQueriesQueryIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<DeleteObservabilityQueryAdminObservabilityQueriesQueryIdDeleteResponses, DeleteObservabilityQueryAdminObservabilityQueriesQueryIdDeleteErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/queries/{query_id}',
    ...options
});

/**
 * Get Observability Query
 *
 * Get a specific saved query by ID.
 *
 * Args:
 * request: FastAPI request object
 * query_id: ID of the saved query
 * user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Query details
 *
 * Raises:
 * HTTPException: 404 if query not found or unauthorized
 */
export const getObservabilityQueryAdminObservabilityQueriesQueryIdGet = <ThrowOnError extends boolean = false>(options: Options<GetObservabilityQueryAdminObservabilityQueriesQueryIdGetData, ThrowOnError>) => (options.client ?? client).get<GetObservabilityQueryAdminObservabilityQueriesQueryIdGetResponses, GetObservabilityQueryAdminObservabilityQueriesQueryIdGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/queries/{query_id}',
    ...options
});

/**
 * Update Observability Query
 *
 * Update an existing saved query.
 *
 * Args:
 * request: FastAPI request object
 * query_id: ID of the query to update
 * name: New name (optional)
 * description: New description (optional)
 * filter_config: New filter configuration (optional)
 * is_shared: New sharing status (optional)
 * user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Updated query details
 *
 * Raises:
 * HTTPException: 404 if query not found, 403 if unauthorized
 */
export const updateObservabilityQueryAdminObservabilityQueriesQueryIdPut = <ThrowOnError extends boolean = false>(options: Options<UpdateObservabilityQueryAdminObservabilityQueriesQueryIdPutData, ThrowOnError>) => (options.client ?? client).put<UpdateObservabilityQueryAdminObservabilityQueriesQueryIdPutResponses, UpdateObservabilityQueryAdminObservabilityQueriesQueryIdPutErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/queries/{query_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Track Query Usage
 *
 * Track usage of a saved query (increments use count and updates last_used_at).
 *
 * Args:
 * request: FastAPI request object
 * query_id: ID of the query being used
 * user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Updated query usage stats
 *
 * Raises:
 * HTTPException: 404 if query not found or unauthorized
 */
export const trackQueryUsageAdminObservabilityQueriesQueryIdUsePost = <ThrowOnError extends boolean = false>(options: Options<TrackQueryUsageAdminObservabilityQueriesQueryIdUsePostData, ThrowOnError>) => (options.client ?? client).post<TrackQueryUsageAdminObservabilityQueriesQueryIdUsePostResponses, TrackQueryUsageAdminObservabilityQueriesQueryIdUsePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/queries/{query_id}/use',
    ...options
});

/**
 * Get Latency Percentiles
 *
 * Get latency percentiles (p50, p90, p95, p99) over time.
 *
 * Args:
 * request: FastAPI request object
 * hours: Number of hours to look back (1-168)
 * interval_minutes: Aggregation interval in minutes (5-1440)
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Time-series data with percentiles
 *
 * Raises:
 * HTTPException: 500 if calculation fails
 */
export const getLatencyPercentilesAdminObservabilityMetricsPercentilesGet = <ThrowOnError extends boolean = false>(options?: Options<GetLatencyPercentilesAdminObservabilityMetricsPercentilesGetData, ThrowOnError>) => (options?.client ?? client).get<GetLatencyPercentilesAdminObservabilityMetricsPercentilesGetResponses, GetLatencyPercentilesAdminObservabilityMetricsPercentilesGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/metrics/percentiles',
    ...options
});

/**
 * Get Timeseries Metrics
 *
 * Get time-series metrics (request rate, error rate, throughput).
 *
 * Args:
 * request: FastAPI request object
 * hours: Number of hours to look back (1-168)
 * interval_minutes: Aggregation interval in minutes (5-1440)
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Time-series data with request counts, error rates, and throughput
 *
 * Raises:
 * HTTPException: 500 if calculation fails
 */
export const getTimeseriesMetricsAdminObservabilityMetricsTimeseriesGet = <ThrowOnError extends boolean = false>(options?: Options<GetTimeseriesMetricsAdminObservabilityMetricsTimeseriesGetData, ThrowOnError>) => (options?.client ?? client).get<GetTimeseriesMetricsAdminObservabilityMetricsTimeseriesGetResponses, GetTimeseriesMetricsAdminObservabilityMetricsTimeseriesGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/metrics/timeseries',
    ...options
});

/**
 * Get Top Slow Endpoints
 *
 * Get top N slowest endpoints by average duration.
 *
 * Args:
 * request: FastAPI request object
 * hours: Number of hours to look back (1-168)
 * limit: Number of results to return (1-100)
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: List of slowest endpoints with stats
 *
 * Raises:
 * HTTPException: 500 if query fails
 */
export const getTopSlowEndpointsAdminObservabilityMetricsTopSlowGet = <ThrowOnError extends boolean = false>(options?: Options<GetTopSlowEndpointsAdminObservabilityMetricsTopSlowGetData, ThrowOnError>) => (options?.client ?? client).get<GetTopSlowEndpointsAdminObservabilityMetricsTopSlowGetResponses, GetTopSlowEndpointsAdminObservabilityMetricsTopSlowGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/metrics/top-slow',
    ...options
});

/**
 * Get Top Volume Endpoints
 *
 * Get top N highest volume endpoints by request count.
 *
 * Args:
 * request: FastAPI request object
 * hours: Number of hours to look back (1-168)
 * limit: Number of results to return (1-100)
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: List of highest volume endpoints with stats
 *
 * Raises:
 * HTTPException: 500 if query fails
 */
export const getTopVolumeEndpointsAdminObservabilityMetricsTopVolumeGet = <ThrowOnError extends boolean = false>(options?: Options<GetTopVolumeEndpointsAdminObservabilityMetricsTopVolumeGetData, ThrowOnError>) => (options?.client ?? client).get<GetTopVolumeEndpointsAdminObservabilityMetricsTopVolumeGetResponses, GetTopVolumeEndpointsAdminObservabilityMetricsTopVolumeGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/metrics/top-volume',
    ...options
});

/**
 * Get Top Error Endpoints
 *
 * Get top N error-prone endpoints by error count and rate.
 *
 * Args:
 * request: FastAPI request object
 * hours: Number of hours to look back (1-168)
 * limit: Number of results to return (1-100)
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: List of error-prone endpoints with stats
 *
 * Raises:
 * HTTPException: 500 if query fails
 */
export const getTopErrorEndpointsAdminObservabilityMetricsTopErrorsGet = <ThrowOnError extends boolean = false>(options?: Options<GetTopErrorEndpointsAdminObservabilityMetricsTopErrorsGetData, ThrowOnError>) => (options?.client ?? client).get<GetTopErrorEndpointsAdminObservabilityMetricsTopErrorsGetResponses, GetTopErrorEndpointsAdminObservabilityMetricsTopErrorsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/metrics/top-errors',
    ...options
});

/**
 * Get Latency Heatmap
 *
 * Get latency distribution heatmap data.
 *
 * Args:
 * request: FastAPI request object
 * hours: Number of hours to look back (1-168)
 * time_buckets: Number of time buckets (10-100)
 * latency_buckets: Number of latency buckets (5-50)
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Heatmap data with time and latency dimensions
 *
 * Raises:
 * HTTPException: 500 if calculation fails
 */
export const getLatencyHeatmapAdminObservabilityMetricsHeatmapGet = <ThrowOnError extends boolean = false>(options?: Options<GetLatencyHeatmapAdminObservabilityMetricsHeatmapGetData, ThrowOnError>) => (options?.client ?? client).get<GetLatencyHeatmapAdminObservabilityMetricsHeatmapGetResponses, GetLatencyHeatmapAdminObservabilityMetricsHeatmapGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/metrics/heatmap',
    ...options
});

/**
 * Get Tool Usage
 *
 * Get tool usage frequency statistics.
 *
 * Args:
 * request: FastAPI request object
 * hours: Number of hours to look back (1-168)
 * limit: Maximum number of tools to return (5-100)
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Tool usage statistics with counts and percentages
 *
 * Raises:
 * HTTPException: 500 if calculation fails
 */
export const getToolUsageAdminObservabilityToolsUsageGet = <ThrowOnError extends boolean = false>(options?: Options<GetToolUsageAdminObservabilityToolsUsageGetData, ThrowOnError>) => (options?.client ?? client).get<GetToolUsageAdminObservabilityToolsUsageGetResponses, GetToolUsageAdminObservabilityToolsUsageGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/tools/usage',
    ...options
});

/**
 * Get Tool Performance
 *
 * Get tool performance metrics (avg, min, max duration).
 *
 * Args:
 * request: FastAPI request object
 * hours: Number of hours to look back (1-168)
 * limit: Maximum number of tools to return (5-100)
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Tool performance metrics
 *
 * Raises:
 * HTTPException: 500 if calculation fails
 */
export const getToolPerformanceAdminObservabilityToolsPerformanceGet = <ThrowOnError extends boolean = false>(options?: Options<GetToolPerformanceAdminObservabilityToolsPerformanceGetData, ThrowOnError>) => (options?.client ?? client).get<GetToolPerformanceAdminObservabilityToolsPerformanceGetResponses, GetToolPerformanceAdminObservabilityToolsPerformanceGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/tools/performance',
    ...options
});

/**
 * Get Tool Errors
 *
 * Get tool error rates and statistics.
 *
 * Args:
 * request: FastAPI request object
 * hours: Number of hours to look back (1-168)
 * limit: Maximum number of tools to return (5-100)
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Tool error statistics
 *
 * Raises:
 * HTTPException: 500 if calculation fails
 */
export const getToolErrorsAdminObservabilityToolsErrorsGet = <ThrowOnError extends boolean = false>(options?: Options<GetToolErrorsAdminObservabilityToolsErrorsGetData, ThrowOnError>) => (options?.client ?? client).get<GetToolErrorsAdminObservabilityToolsErrorsGetResponses, GetToolErrorsAdminObservabilityToolsErrorsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/tools/errors',
    ...options
});

/**
 * Get Tool Chains
 *
 * Get tool chain analysis (which tools are invoked together in the same trace).
 *
 * Args:
 * request: FastAPI request object
 * hours: Number of hours to look back (1-168)
 * limit: Maximum number of chains to return (5-100)
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Tool chain statistics showing common tool sequences
 *
 * Raises:
 * HTTPException: 500 if calculation fails
 */
export const getToolChainsAdminObservabilityToolsChainsGet = <ThrowOnError extends boolean = false>(options?: Options<GetToolChainsAdminObservabilityToolsChainsGetData, ThrowOnError>) => (options?.client ?? client).get<GetToolChainsAdminObservabilityToolsChainsGetResponses, GetToolChainsAdminObservabilityToolsChainsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/tools/chains',
    ...options
});

/**
 * Get Tools Partial
 *
 * Render the tool invocation metrics dashboard HTML partial.
 *
 * Args:
 * request: FastAPI request object
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * HTMLResponse: Rendered tool metrics dashboard partial
 */
export const getToolsPartialAdminObservabilityToolsPartialGet = <ThrowOnError extends boolean = false>(options?: Options<GetToolsPartialAdminObservabilityToolsPartialGetData, ThrowOnError>) => (options?.client ?? client).get<GetToolsPartialAdminObservabilityToolsPartialGetResponses, GetToolsPartialAdminObservabilityToolsPartialGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/tools/partial',
    ...options
});

/**
 * Get Prompt Usage
 *
 * Get prompt rendering frequency statistics.
 *
 * Args:
 * request: FastAPI request object
 * hours: Number of hours to look back (1-168)
 * limit: Maximum number of prompts to return (5-100)
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Prompt usage statistics with counts and percentages
 *
 * Raises:
 * HTTPException: 500 if calculation fails
 */
export const getPromptUsageAdminObservabilityPromptsUsageGet = <ThrowOnError extends boolean = false>(options?: Options<GetPromptUsageAdminObservabilityPromptsUsageGetData, ThrowOnError>) => (options?.client ?? client).get<GetPromptUsageAdminObservabilityPromptsUsageGetResponses, GetPromptUsageAdminObservabilityPromptsUsageGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/prompts/usage',
    ...options
});

/**
 * Get Prompt Performance
 *
 * Get prompt performance metrics (avg, min, max duration).
 *
 * Args:
 * request: FastAPI request object
 * hours: Number of hours to look back (1-168)
 * limit: Maximum number of prompts to return (5-100)
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Prompt performance metrics
 *
 * Raises:
 * HTTPException: 500 if calculation fails
 */
export const getPromptPerformanceAdminObservabilityPromptsPerformanceGet = <ThrowOnError extends boolean = false>(options?: Options<GetPromptPerformanceAdminObservabilityPromptsPerformanceGetData, ThrowOnError>) => (options?.client ?? client).get<GetPromptPerformanceAdminObservabilityPromptsPerformanceGetResponses, GetPromptPerformanceAdminObservabilityPromptsPerformanceGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/prompts/performance',
    ...options
});

/**
 * Get Prompts Errors
 *
 * Get prompt error rates.
 *
 * Args:
 * hours: Time range in hours to analyze
 * limit: Maximum number of prompts to return
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Prompt error statistics
 */
export const getPromptsErrorsAdminObservabilityPromptsErrorsGet = <ThrowOnError extends boolean = false>(options?: Options<GetPromptsErrorsAdminObservabilityPromptsErrorsGetData, ThrowOnError>) => (options?.client ?? client).get<GetPromptsErrorsAdminObservabilityPromptsErrorsGetResponses, GetPromptsErrorsAdminObservabilityPromptsErrorsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/prompts/errors',
    ...options
});

/**
 * Get Prompts Partial
 *
 * Render the prompt rendering metrics dashboard HTML partial.
 *
 * Args:
 * request: FastAPI request object
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * HTMLResponse: Rendered prompt metrics dashboard partial
 */
export const getPromptsPartialAdminObservabilityPromptsPartialGet = <ThrowOnError extends boolean = false>(options?: Options<GetPromptsPartialAdminObservabilityPromptsPartialGetData, ThrowOnError>) => (options?.client ?? client).get<GetPromptsPartialAdminObservabilityPromptsPartialGetResponses, GetPromptsPartialAdminObservabilityPromptsPartialGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/prompts/partial',
    ...options
});

/**
 * Get Resource Usage
 *
 * Get resource fetch frequency statistics.
 *
 * Args:
 * request: FastAPI request object
 * hours: Number of hours to look back (1-168)
 * limit: Maximum number of resources to return (5-100)
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Resource usage statistics with counts and percentages
 *
 * Raises:
 * HTTPException: 500 if calculation fails
 */
export const getResourceUsageAdminObservabilityResourcesUsageGet = <ThrowOnError extends boolean = false>(options?: Options<GetResourceUsageAdminObservabilityResourcesUsageGetData, ThrowOnError>) => (options?.client ?? client).get<GetResourceUsageAdminObservabilityResourcesUsageGetResponses, GetResourceUsageAdminObservabilityResourcesUsageGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/resources/usage',
    ...options
});

/**
 * Get Resource Performance
 *
 * Get resource performance metrics (avg, min, max duration).
 *
 * Args:
 * request: FastAPI request object
 * hours: Number of hours to look back (1-168)
 * limit: Maximum number of resources to return (5-100)
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Resource performance metrics
 *
 * Raises:
 * HTTPException: 500 if calculation fails
 */
export const getResourcePerformanceAdminObservabilityResourcesPerformanceGet = <ThrowOnError extends boolean = false>(options?: Options<GetResourcePerformanceAdminObservabilityResourcesPerformanceGetData, ThrowOnError>) => (options?.client ?? client).get<GetResourcePerformanceAdminObservabilityResourcesPerformanceGetResponses, GetResourcePerformanceAdminObservabilityResourcesPerformanceGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/resources/performance',
    ...options
});

/**
 * Get Resources Errors
 *
 * Get resource error rates.
 *
 * Args:
 * hours: Time range in hours to analyze
 * limit: Maximum number of resources to return
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * dict: Resource error statistics
 */
export const getResourcesErrorsAdminObservabilityResourcesErrorsGet = <ThrowOnError extends boolean = false>(options?: Options<GetResourcesErrorsAdminObservabilityResourcesErrorsGetData, ThrowOnError>) => (options?.client ?? client).get<GetResourcesErrorsAdminObservabilityResourcesErrorsGetResponses, GetResourcesErrorsAdminObservabilityResourcesErrorsGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/resources/errors',
    ...options
});

/**
 * Get Resources Partial
 *
 * Render the resource fetch metrics dashboard HTML partial.
 *
 * Args:
 * request: FastAPI request object
 * _user: Authenticated user (required by dependency)
 *
 * Returns:
 * HTMLResponse: Rendered resource metrics dashboard partial
 */
export const getResourcesPartialAdminObservabilityResourcesPartialGet = <ThrowOnError extends boolean = false>(options?: Options<GetResourcesPartialAdminObservabilityResourcesPartialGetData, ThrowOnError>) => (options?.client ?? client).get<GetResourcesPartialAdminObservabilityResourcesPartialGetResponses, GetResourcesPartialAdminObservabilityResourcesPartialGetErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/admin/observability/resources/partial',
    ...options
});

/**
 * Root Redirect
 *
 * Redirects the root path ("/") to "/admin".
 *
 * Logs a debug message before redirecting.
 *
 * Args:
 * request (Request): The incoming HTTP request (used only to build the
 * target URL via :pymeth:`starlette.requests.Request.url_for`).
 *
 * Returns:
 * RedirectResponse: Redirects to /admin.
 *
 * Raises:
 * HTTPException: If there is an error during redirection.
 */
export const rootRedirectGet = <ThrowOnError extends boolean = false>(options?: Options<RootRedirectGetData, ThrowOnError>) => (options?.client ?? client).get<RootRedirectGetResponses, unknown, ThrowOnError>({ url: '/', ...options });

/**
 * Initialize
 *
 * Initialize a protocol.
 *
 * This endpoint handles the initialization process of a protocol by accepting
 * a JSON request body and processing it. The `require_auth` dependency ensures that
 * the user is authenticated before proceeding.
 *
 * Args:
 * request (Request): The incoming request object containing the JSON body.
 * user (str): The authenticated user (from `require_auth` dependency).
 *
 * Returns:
 * InitializeResult: The result of the initialization process.
 *
 * Raises:
 * HTTPException: If the request body contains invalid JSON, a 400 Bad Request error is raised.
 */
export const initializeInitializePost = <ThrowOnError extends boolean = false>(options?: Options<InitializeInitializePostData, ThrowOnError>) => (options?.client ?? client).post<InitializeInitializePostResponses, InitializeInitializePostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/initialize',
    ...options
});

/**
 * Handle Notification
 *
 * Handles incoming notifications from clients. Depending on the notification method,
 * different actions are taken (e.g., logging initialization, cancellation, or messages).
 *
 * Args:
 * request (Request): The incoming request containing the notification data.
 * user (str): The authenticated user making the request.
 */
export const handleNotificationNotificationsPost = <ThrowOnError extends boolean = false>(options?: Options<HandleNotificationNotificationsPostData, ThrowOnError>) => (options?.client ?? client).post<HandleNotificationNotificationsPostResponses, HandleNotificationNotificationsPostErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/notifications',
    ...options
});
