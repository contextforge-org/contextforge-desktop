# Resources Page Implementation Plan

## Overview

This document outlines the detailed plan for implementing a new **Resources Page** in the Context Forge Electron application, following the same design patterns and architecture as the existing Tools Page.

## 1. Type Analysis & Comparison

### ResourceRead Type Structure

Based on the autogenerated client types, the `ResourceRead` interface includes:

**Core Fields:**
- `id`: number - Database identifier
- `uri`: string - Unique URI for the resource
- `name`: string - Human-readable name
- `description`: string | null - Optional description
- `mimeType`: string | null - MIME type (e.g., "text/plain", "application/json")
- `size`: number | null - Content size in bytes
- `isActive`: boolean - Active/inactive status
- `metrics`: ResourceMetrics - Performance metrics

**Organizational Fields:**
- `tags`: Array<string> - Categorization tags
- `teamId`: string | null - Team ownership
- `team`: string | null - Team name
- `ownerEmail`: string | null - Owner email
- `visibility`: string | null - "private" | "team" | "public"

**Audit Fields:**
- `createdAt`: string - Creation timestamp
- `updatedAt`: string - Last update timestamp
- `createdBy`: string | null - Creator username
- `modifiedBy`: string | null - Last modifier username
- `version`: number | null - Version tracking

**MCP Protocol Fields:**
- `title`: string | null - Human-readable title
- `annotations`: Annotations | null - Client rendering hints
- `_meta`: object | null - Protocol extension metadata

### Comparison with Tool Interface

| Feature | Tool | Resource | Notes |
|---------|------|----------|-------|
| **Identifier** | `id`, `gatewayName`, `name` | `id`, `uri`, `name` | Resources use URI as unique identifier |
| **Content** | `url`, `inputSchema`, `outputSchema` | `uri`, `mimeType`, `size` | Resources store actual content |
| **Type** | `type`, `requestMethod`, `integrationType` | `mimeType` | Resources categorized by MIME type |
| **Execution** | `authenticationType`, `headers` | N/A | Resources are data, not executable |
| **Display** | `displayName` | `title` | Similar concept, different naming |
| **Metadata** | `annotations`, `jsonPathFilter` | `annotations`, `_meta` | Both support MCP protocol |

### Key Differences

1. **Purpose**: Tools are executable operations; Resources are data/content
2. **Content Storage**: Resources store actual content (text/binary)
3. **MIME Types**: Resources categorized by content type instead of request method
4. **No Authentication**: Resources don't require auth configuration
5. **Size Tracking**: Resources track content size

## 2. Component Architecture

### 2.1 Main Component: ResourcesPage.tsx

**Location**: `src/components/ResourcesPage.tsx`

**Structure** (following ToolsPage pattern):
```typescript
interface Resource {
  id: number;
  uri: string;
  name: string;
  title?: string;
  description: string | null;
  mimeType: string | null;
  size: number | null;
  tags: string[];
  owner: string;
  team: string;
  teamId?: string | null;
  visibility: 'public' | 'team' | 'private';
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  metrics: ResourceMetrics;
  annotations?: any;
}
```

**State Management**:
- `resourcesData`: Resource[] - Main data array
- `isLoading`: boolean - Loading state
- `error`: string | null - Error messages
- `showSidePanel`: boolean - Side panel visibility
- `selectedResource`: Resource | null - Currently selected resource
- `panelMode`: 'view' | 'add' | 'edit' - Panel mode
- `viewMode`: 'table' | 'grid' - Display mode
- `searchQuery`: string - Search filter
- `showBulkImport`: boolean - Bulk import dialog

**Filter States**:
- `selectedMimeTypes`: string[] - Filter by MIME type
- `selectedVisibility`: string[] - Filter by visibility
- `selectedTags`: string[] - Filter by tags

**Editor States** (for add/edit):
- `editedUri`: string
- `editedName`: string
- `editedTitle`: string
- `editedDescription`: string
- `editedMimeType`: string
- `editedContent`: string
- `editedTags`: string[]
- `editedVisibility`: 'public' | 'team' | 'private'
- `editedActive`: boolean

### 2.2 View Components

#### Table View
- Columns: Name, URI, MIME Type, Size, Description, Tags, Status
- Sortable columns
- Row actions: View, Edit, Toggle, Delete
- Inline status badges

#### Grid View
- Card-based layout
- Display: Name, MIME type badge, size, description preview
- Tags as colored badges
- Action buttons on hover

### 2.3 Side Panels

#### Details Panel (View Mode)
**Sections**:
1. **Header**: Name, URI, status badge
2. **Content Info**: MIME type, size, description
3. **Content Preview**: 
   - Text content: Syntax-highlighted display
   - JSON: Formatted JSON viewer
   - Binary: Download button
4. **Metadata**: Tags, visibility, team
5. **Metrics**: Usage stats, performance data
6. **Audit Trail**: Created/modified info
7. **Actions**: Edit, Toggle, Delete, Test

#### Editor Panel (Add/Edit Mode)
**Form Fields**:
1. URI (required, unique)
2. Name (required)
3. Title (optional)
4. Description (textarea)
5. MIME Type (dropdown with common types)
6. Content (textarea or file upload)
7. Tags (multi-select with creation)
8. Visibility (radio: public/team/private)
9. Team (dropdown, if team visibility)
10. Active status (toggle)

**Validation**:
- URI format validation
- Required field checks
- Content size limits
- MIME type validation

## 3. API Integration

### 3.1 Add to contextforge-api-ipc.ts

```typescript
import { 
  type ResourceRead, 
  type ResourceCreate, 
  type ResourceUpdate 
} from '../contextforge-client-ts';

// Resource operations
export async function listResources(): Promise<ResourceRead[]> {
  if (!isElectron) {
    throw new Error('This API wrapper requires Electron environment');
  }
  const response = await window.electronAPI.api.listResources();
  if (!response.success) {
    throw new Error('Failed to list resources: ' + response.error);
  }
  return response.data || [];
}

export async function createResource(resourceData: ResourceCreate) {
  if (!isElectron) {
    throw new Error('This API wrapper requires Electron environment');
  }
  const response = await window.electronAPI.api.createResource(resourceData);
  if (!response.success) {
    throw new Error('Failed to create resource: ' + response.error);
  }
  return response.data;
}

export async function updateResource(resourceId: string, resourceData: ResourceUpdate) {
  if (!isElectron) {
    throw new Error('This API wrapper requires Electron environment');
  }
  const response = await window.electronAPI.api.updateResource(resourceId, resourceData);
  if (!response.success) {
    throw new Error('Failed to update resource: ' + response.error);
  }
  return response.data;
}

export async function deleteResource(resourceId: string) {
  if (!isElectron) {
    throw new Error('This API wrapper requires Electron environment');
  }
  const response = await window.electronAPI.api.deleteResource(resourceId);
  if (!response.success) {
    throw new Error('Failed to delete resource: ' + response.error);
  }
  return response.data;
}

export async function toggleResourceStatus(resourceId: string, activate?: boolean) {
  if (!isElectron) {
    throw new Error('This API wrapper requires Electron environment');
  }
  const response = await window.electronAPI.api.toggleResourceStatus(resourceId, activate);
  if (!response.success) {
    throw new Error('Failed to toggle resource status: ' + response.error);
  }
  return response.data;
}

export async function readResource(resourceId: string): Promise<ResourceRead> {
  if (!isElectron) {
    throw new Error('This API wrapper requires Electron environment');
  }
  const response = await window.electronAPI.api.readResource(resourceId);
  if (!response.success) {
    throw new Error('Failed to read resource: ' + response.error);
  }
  return response.data;
}
```

### 3.2 Add IPC Handlers (ipc-handlers.ts)

```typescript
// Resource handlers
ipcMain.handle('api:list-resources', async () => {
  try {
    const response = await mainApi.listResources();
    return { success: true, data: response };
  } catch (error) {
    return { success: false, error: (error as Error).message };
  }
});

ipcMain.handle('api:create-resource', async (_event, resourceData) => {
  try {
    const response = await mainApi.createResource(resourceData);
    return { success: true, data: response };
  } catch (error) {
    return { success: false, error: (error as Error).message };
  }
});

ipcMain.handle('api:update-resource', async (_event, resourceId, resourceData) => {
  try {
    const response = await mainApi.updateResource(resourceId, resourceData);
    return { success: true, data: response };
  } catch (error) {
    return { success: false, error: (error as Error).message };
  }
});

ipcMain.handle('api:delete-resource', async (_event, resourceId) => {
  try {
    const response = await mainApi.deleteResource(resourceId);
    return { success: true, data: response };
  } catch (error) {
    return { success: false, error: (error as Error).message };
  }
});

ipcMain.handle('api:toggle-resource-status', async (_event, resourceId, activate) => {
  try {
    const response = await mainApi.toggleResourceStatus(resourceId, activate);
    return { success: true, data: response };
  } catch (error) {
    return { success: false, error: (error as Error).message };
  }
});

ipcMain.handle('api:read-resource', async (_event, resourceId) => {
  try {
    const response = await mainApi.readResource(resourceId);
    return { success: true, data: response };
  } catch (error) {
    return { success: false, error: (error as Error).message };
  }
});
```

### 3.3 Update preload.ts

```typescript
api: {
  // ... existing methods ...
  listResources: () => ipcRenderer.invoke('api:list-resources'),
  createResource: (resourceData: any) => ipcRenderer.invoke('api:create-resource', resourceData),
  updateResource: (resourceId: string, resourceData: any) => ipcRenderer.invoke('api:update-resource', resourceId, resourceData),
  deleteResource: (resourceId: string) => ipcRenderer.invoke('api:delete-resource', resourceId),
  toggleResourceStatus: (resourceId: string, activate?: boolean) => ipcRenderer.invoke('api:toggle-resource-status', resourceId, activate),
  readResource: (resourceId: string) => ipcRenderer.invoke('api:read-resource', resourceId),
}
```

## 4. UI Components & Features

### 4.1 MIME Type Badge Component

**Purpose**: Display MIME type with appropriate icon and color

```typescript
interface MimeTypeBadgeProps {
  mimeType: string | null;
  theme: 'light' | 'dark';
}

// MIME type categories with icons and colors
const mimeTypeConfig = {
  'text/': { icon: FileText, color: 'blue' },
  'application/json': { icon: Code, color: 'green' },
  'image/': { icon: Image, color: 'purple' },
  'video/': { icon: Video, color: 'red' },
  'audio/': { icon: Music, color: 'orange' },
  'application/pdf': { icon: FileText, color: 'red' },
  'default': { icon: File, color: 'gray' }
};
```

### 4.2 Content Preview Component

**Purpose**: Display resource content based on MIME type

**Features**:
- Text content: Syntax highlighting (using react-syntax-highlighter)
- JSON: Formatted JSON viewer with collapsible sections
- Images: Image preview with dimensions
- Binary: Download button with size info
- Large content: Truncated with "Show More" option

### 4.3 Size Display Component

**Purpose**: Format byte sizes in human-readable format

```typescript
function formatBytes(bytes: number | null): string {
  if (bytes === null) return 'Unknown';
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}
```

### 4.4 Resource Metrics Display

**Purpose**: Show usage and performance metrics

**Metrics to Display**:
- Total invocations
- Success rate
- Average response time
- Last accessed timestamp
- Failure count

### 4.5 Filter Dropdown

**MIME Type Filters**:
- Text (text/*)
- JSON (application/json)
- Images (image/*)
- Videos (video/*)
- Audio (audio/*)
- PDFs (application/pdf)
- Other

**Visibility Filters**:
- Public
- Team
- Private

## 5. Search & Filtering

### 5.1 Search Implementation

**Search Fields**:
- Name
- URI
- Description
- Tags
- MIME type

**Search Logic**:
```typescript
const filteredResources = useMemo(() => {
  return teamFilteredResources.filter(resource => {
    // Search query filter
    const matchesSearch = !searchQuery || 
      resource.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
      resource.uri.toLowerCase().includes(searchQuery.toLowerCase()) ||
      (resource.description?.toLowerCase().includes(searchQuery.toLowerCase())) ||
      resource.tags.some(tag => tag.toLowerCase().includes(searchQuery.toLowerCase()));
    
    // MIME type filter
    const matchesMimeType = selectedMimeTypes.length === 0 ||
      selectedMimeTypes.some(type => resource.mimeType?.startsWith(type));
    
    // Visibility filter
    const matchesVisibility = selectedVisibility.length === 0 ||
      selectedVisibility.includes(resource.visibility);
    
    return matchesSearch && matchesMimeType && matchesVisibility;
  });
}, [teamFilteredResources, searchQuery, selectedMimeTypes, selectedVisibility]);
```

### 5.2 Sorting

**Sortable Columns**:
- Name (alphabetical)
- URI (alphabetical)
- Size (numerical)
- Created date (chronological)
- Updated date (chronological)
- Usage count (numerical)

## 6. Bulk Import

### 6.1 Import Format

**JSON Structure**:
```json
{
  "resources": [
    {
      "uri": "file://config/settings.json",
      "name": "Application Settings",
      "description": "Main application configuration",
      "mimeType": "application/json",
      "content": "{\"key\": \"value\"}",
      "tags": ["config", "settings"],
      "visibility": "team"
    }
  ]
}
```

### 6.2 Import Validation

**Checks**:
- Valid JSON format
- Required fields present (uri, name, content)
- URI uniqueness
- MIME type validity
- Content size limits
- Tag format validation

### 6.3 Import UI

**Component**: `BulkImportForm` (reuse existing pattern)

**Features**:
- File upload or paste JSON
- Validation preview
- Error highlighting
- Import progress indicator
- Success/failure summary

## 7. Content Management

### 7.1 Content Upload

**Methods**:
1. **Text Input**: Direct textarea input for text content
2. **File Upload**: Upload files and auto-detect MIME type
3. **URL Import**: Fetch content from URL

**File Upload Flow**:
```typescript
const handleFileUpload = async (file: File) => {
  // Read file content
  const content = await file.text();
  
  // Auto-detect MIME type
  const mimeType = file.type || 'application/octet-stream';
  
  // Set form fields
  setEditedContent(content);
  setEditedMimeType(mimeType);
  setEditedName(file.name);
  
  // Generate URI suggestion
  const suggestedUri = `file://${file.name}`;
  setEditedUri(suggestedUri);
};
```

### 7.2 Content Size Limits

**Limits**:
- Text content: 10 MB
- Binary content: 50 MB
- Warning at 5 MB
- Compression for large text

### 7.3 Content Encoding

**Text Content**: UTF-8 encoding
**Binary Content**: Base64 encoding for API transport

## 8. Navigation Integration

### 8.1 Update SideNav.tsx

**Change**:
```typescript
// Line 259-264: Enable Resources navigation
<NavItem 
  icon={<Package size={18} strokeWidth={1.5} />} 
  label="Resources" 
  active={currentPage === 'resources'}  // Changed from 'Resources'
  onClick={(e) => {
    e?.stopPropagation();
    onNavigate('resources');  // Changed from 'Resources'
  }}
  isCollapsed={isCollapsed}
  theme={theme}
/>
```

### 8.2 Update mainapp.tsx

**Add Route**:
```typescript
import { ResourcesPage } from './components/ResourcesPage';

// In navigation handler
const handleNavigate = (page: 'servers' | 'mcp-servers' | 'tools' | 'prompts' | 'resources' | 'settings') => {
  setCurrentPage(page);
};

// In render
{currentPage === 'resources' && <ResourcesPage />}
```

## 9. Testing Strategy

### 9.1 Unit Tests

**Test Coverage**:
- Resource CRUD operations
- Filter logic
- Search functionality
- MIME type detection
- Content validation
- Size formatting

### 9.2 Integration Tests

**Test Scenarios**:
1. Create resource with text content
2. Create resource with file upload
3. Update resource content
4. Toggle resource status
5. Delete resource
6. Bulk import resources
7. Filter by MIME type
8. Search resources
9. View resource details
10. Team filtering

### 9.3 E2E Tests

**User Flows**:
1. Navigate to Resources page
2. Create new text resource
3. Upload file as resource
4. Edit existing resource
5. Search and filter resources
6. View resource metrics
7. Bulk import from JSON
8. Delete resource

## 10. Implementation Phases

### Phase 1: Core Structure (Days 1-2)
- [ ] Create ResourcesPage component skeleton
- [ ] Implement basic table view
- [ ] Add API integration layer
- [ ] Set up state management

### Phase 2: CRUD Operations (Days 3-4)
- [ ] Implement create resource
- [ ] Implement update resource
- [ ] Implement delete resource
- [ ] Implement toggle status
- [ ] Add form validation

### Phase 3: UI Components (Days 5-6)
- [ ] Create MIME type badge component
- [ ] Implement content preview
- [ ] Add size display formatting
- [ ] Create metrics display
- [ ] Implement grid view

### Phase 4: Advanced Features (Days 7-8)
- [ ] Add search functionality
- [ ] Implement filtering
- [ ] Add sorting
- [ ] Create bulk import
- [ ] Add file upload

### Phase 5: Polish & Testing (Days 9-10)
- [ ] Add loading states
- [ ] Implement error handling
- [ ] Add toast notifications
- [ ] Write tests
- [ ] Performance optimization
- [ ] Documentation

## 11. File Structure

```
src/
├── components/
│   ├── ResourcesPage.tsx          # Main page component
│   ├── ResourceDetailsPanel.tsx   # Details view panel
│   ├── ResourceEditorPanel.tsx    # Add/edit panel
│   ├── ResourceTableView.tsx      # Table view
│   ├── ResourceGridView.tsx       # Grid view
│   └── common/
│       ├── MimeTypeBadge.tsx      # MIME type display
│       ├── ContentPreview.tsx     # Content viewer
│       └── SizeDisplay.tsx        # Size formatter
├── hooks/
│   ├── useResourceActions.ts      # CRUD operations
│   ├── useResourceFilters.ts      # Filter logic
│   └── useResourceEditor.ts       # Editor state
└── lib/
    └── api/
        └── contextforge-api-ipc.ts # API integration
```

## 12. Key Considerations

### 12.1 Performance
- Lazy load large content
- Virtualize long lists
- Debounce search input
- Cache resource list
- Optimize re-renders

### 12.2 Security
- Validate MIME types
- Sanitize content display
- Check file size limits
- Validate URIs
- Escape user input

### 12.3 Accessibility
- Keyboard navigation
- Screen reader support
- Focus management
- ARIA labels
- Color contrast

### 12.4 Error Handling
- Network errors
- Validation errors
- File upload errors
- Content size errors
- Duplicate URI errors

## 13. Success Criteria

- [ ] All CRUD operations working
- [ ] Search and filtering functional
- [ ] Bulk import operational
- [ ] Content preview working for common types
- [ ] Metrics displayed correctly
- [ ] Team filtering integrated
- [ ] Responsive design
- [ ] Error handling robust
- [ ] Performance acceptable (<100ms interactions)
- [ ] Tests passing (>80% coverage)

## 14. Future Enhancements

1. **Content Versioning**: Track resource content changes
2. **Content Diff**: Show differences between versions
3. **Resource Templates**: Pre-defined resource templates
4. **Content Transformation**: Convert between formats
5. **Resource Sharing**: Share resources with other teams
6. **Resource Collections**: Group related resources
7. **Advanced Search**: Full-text search in content
8. **Resource Analytics**: Detailed usage analytics
9. **Content Validation**: Schema validation for JSON/XML
10. **Resource Dependencies**: Track resource relationships

## 15. References

- **Tools Page**: `src/components/ToolsPage.tsx` - Primary reference implementation
- **Prompts Page**: `src/components/PromptsPage.tsx` - Similar pattern
- **Generated Types**: `src/lib/contextforge-client-ts/types.gen.ts` - Type definitions
- **API SDK**: `src/lib/contextforge-client-ts/sdk.gen.ts` - API functions
- **Design System**: Existing UI components in `src/components/ui/`

---

**Document Version**: 1.0  
**Last Updated**: 2025-11-25  